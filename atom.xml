<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>新生代农民工</title>
  
  <subtitle>依山慕雪的个人博客</subtitle>
  <link href="https://laysan.site/atom.xml" rel="self"/>
  
  <link href="https://laysan.site/"/>
  <updated>2021-04-21T08:23:23.000Z</updated>
  <id>https://laysan.site/</id>
  
  <author>
    <name>依山慕雪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AutoJob 使用文档</title>
    <link href="https://laysan.site/2021/04/autojob/"/>
    <id>https://laysan.site/2021/04/autojob/</id>
    <published>2021-04-21T15:30:00.000Z</published>
    <updated>2021-04-21T08:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里是AutoJob小程序的一个简单的使用手册</p><h2 id="支持项目"><a href="#支持项目" class="headerlink" title="支持项目"></a>支持项目</h2><ul><li>时光相册</li><li>天翼网盘</li><li>有道笔记</li><li>WPS签到</li></ul><h3 id="Server酱推送"><a href="#Server酱推送" class="headerlink" title="Server酱推送"></a>Server酱推送</h3><p>可选配置,填写SCKEY可以推送签到消息到微信</p><p>小程序默认会推送订阅消息,需要手动确认下,勾选同意不再询问则每天自动签到完成都会推送消息</p><p>自行配置<code>SCKEY</code>,<a href="http://sc.ftqq.com/">Server酱官网</a></p><h3 id="时光相册"><a href="#时光相册" class="headerlink" title="时光相册"></a>时光相册</h3><p>直接新增配置账号密码即可</p><h3 id="天翼网盘"><a href="#天翼网盘" class="headerlink" title="天翼网盘"></a>天翼网盘</h3><p>使用账号密码登录</p><p><strong>没有设置密码的请去cloud.189.cn设置一下</strong></p><p><strong>签到提示验证码的请 <a href="https://cloud.189.cn/udb/udb_login.jsp?pageId=1&redirectURL=/main.action">点击这里</a> 选择账号密码登录,一般会有验证码弹出来,退出多登录几次一般就不需要验证码了</strong></p><h3 id="有道笔记"><a href="#有道笔记" class="headerlink" title="有道笔记"></a>有道笔记</h3><p>使用账号密码登录</p><p><strong>没有设置密码的请去<a href="https://note.youdao.com/">https://note.youdao.com/web</a>设置一下</strong></p><h3 id="WPS签到"><a href="#WPS签到" class="headerlink" title="WPS签到"></a>WPS签到</h3><p>账号填写WPS的UID,密码填写sid<br>获取SID 电脑流量器打开<a href="https://zt.wps.cn/2018/clock_in?csource=pc_clock_oldactivity">https://zt.wps.cn/2018/clock_in?csource=pc_clock_oldactivity</a>登录账号 打开F12 查看cookie 拿到wps_sid的值</p>]]></content>
    
    
    <summary type="html">AutoJob 使用文档</summary>
    
    
    
    <category term="Other" scheme="https://laysan.site/categories/Other/"/>
    
    
    <category term="Other" scheme="https://laysan.site/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>iview-admin 2.x 兼容IE11的方法</title>
    <link href="https://laysan.site/2019/01/iview-admin-ie/"/>
    <id>https://laysan.site/2019/01/iview-admin-ie/</id>
    <published>2019-01-28T15:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用iview-admin搭建的项目突然说要兼容ie,瀑汗.经过一番查阅资料,暂时找到一个可行的方法.记录如下</p><p>一般开源项目遇到问题首先想到去Issue中去寻找答案,兼容IE肯定是个普遍问题,issue中已经有很多类似问题和解决方案了.<a href="https://github.com/iview/iview-admin/issues?utf8=%E2%9C%93&q=is:issue+ie">https://github.com/iview/iview-admin/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+ie</a></p><p>整理了一下本人成功兼容IE11 的方案:</p><ol><li>更改webpack-dev-server版本为2.71</li></ol><p><code>npm install --save-dev webpack-dev-server@2.7.1 </code></p><ol start="2"><li>安装@babel/polyfill </li></ol><p><code>npm install --save @babel/polyfill</code></p><ol start="3"><li>main.js代码最前面加入</li></ol><p><code>import &#39;@babel/polyfill&#39;</code></p><ol start="4"><li>main.js相关的语言包全部删除</li></ol><pre><code>1.main.js中的以下三部分注释掉：//import i18n from &#39;@/locale&#39;Vue.use(iView, &#123;// i18n: (key, value) =&gt; i18n.t(key, value)&#125;)new Vue(&#123;el: &#39;#app&#39;,router,// i18n,store,render: h =&gt; h(App)&#125;)2.还需要把components\main下的：// this.setLocal(this.$i18n.locale)两段注释掉</code></pre><ol start="5"><li>修改配置文件</li></ol><pre><code>编辑.babelrc&#123;  &quot;presets&quot;: [[&quot;@vue/app&quot;, &#123; &quot;useBuiltIns&quot;: &quot;entry&quot; &#125;]]&#125;编辑vue.config.js  transpileDependencies: [&#39;tree-table-vue&#39;, &#39;iview&#39;],  chainWebpack: config =&gt; &#123;    config.entry(&#39;polyfill&#39;).add(&#39;@babel/polyfill&#39;)    config.resolve.alias      .set(&#39;@&#39;, resolve(&#39;src&#39;)) // key,value自行定义，比如.set(&#39;@@&#39;, resolve(&#39;src/components&#39;))      .set(&#39;_c&#39;, resolve(&#39;src/components&#39;))  &#125;,</code></pre><ol start="6"><li>删除TreeTable依赖</li></ol><p>TreeTable 插件不兼容ie需要注释掉</p><pre><code>在main.js注释掉// import TreeTable from &#39;tree-table-vue&#39;// import VOrgTree from &#39;v-org-tree&#39;以及// Vue.use(TreeTable)// Vue.use(VOrgTree)</code></pre>]]></content>
    
    
    <summary type="html">iview-admin 2.x 兼容IE11的方法</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="Web" scheme="https://laysan.site/tags/Web/"/>
    
    <category term="Vue" scheme="https://laysan.site/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>2018 前端性能检查表</title>
    <link href="https://laysan.site/2018/04/front-end-performance-checklist-for-2018/"/>
    <id>https://laysan.site/2018/04/front-end-performance-checklist-for-2018/</id>
    <published>2018-04-04T04:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://juejin.im/post/5ac1d117f265da2396128b9f">https://juejin.im/post/5ac1d117f265da2396128b9f</a></p></blockquote><p>众所周知，性能十分重要。然而，我们真的知道性能瓶颈具体在哪儿吗？是执行复杂的 JavaScript，下载缓慢的 Web 字体，巨大的图片，还是卡顿的渲染？研究摇树（Tree Shaking），作用域提升（Scope Hoisting），或是各种各样的与 IntersectionObserver、Clients Hints、CSS containment、HTTP/2 和 Service Worker 一同工作的华丽的加载模式真的有价值吗？最重要的是，<strong>我们从哪里开始优化性能</strong>，以及我们如何建立长期的性能文化呢？</p><p>以前，性能往往只是事后的想法。通常直到项目最后的时候才会被考虑，然后被归结为压缩、合并、静态资源优化或者对服务器配置文件的一些细微调整。现在回想起来，事情似乎已经发生了很大的变化。</p><p>性能不仅仅是一个技术问题：它很重要，而且当把它引入到工作流时，设计决策必须根据其性能影响来决定。<strong>我们必须不断的测量、监视和改进性能</strong>，而且 Web 日益复杂的情况带来了新的挑战，使得性能指标难以被跟踪，因为性能指标将因设备、浏览器、协议、网络类型和延迟（CDN、运营商、缓存、代理、防火墙、负载平衡器和服务器都在其中发挥作用）而有很大差异。</p><p>因此，如果我们创作一个在提高性能时必须牢记的所有事项的概述——从流程的一开始到网站的最终发布——这样的列表将是什么样子？下面就是 2018 前端性能检查表（但愿不偏不倚和足够客观）——说明您可能需要考虑的问题，以确保您的站点响应时间快、用户交互流畅，并且不会用尽用户的带宽。</p><p>下面是您可能需要考虑的<strong>前端性能问题</strong>的概述，以确保您的响应时间快速而流畅。</p><p>（译注：原文详细地阐述了文中所涉及的所有优化策略的原理和来龙去脉。此处仅翻译了原文中附带的 PDF 检查表文件，意在提供一个快速、简洁的性能优化清单。）</p><h2 id="一、准备：规划和指标"><a href="#一、准备：规划和指标" class="headerlink" title="一、准备：规划和指标"></a>一、准备：规划和指标</h2><h3 id="01-建立性能文化"><a href="#01-建立性能文化" class="headerlink" title="01 建立性能文化"></a>01 建立性能文化</h3><p>只要团队之间没有协作，高性能就无法长期维持。研究用户反馈中常见的抱怨，看看提高性能是否可以帮助缓解其中一些问题。用真实数据来建立适合自己的案例和模型。在设计过程中就开始规划加载顺序和权衡。</p><h3 id="02-选择正确的性能指标"><a href="#02-选择正确的性能指标" class="headerlink" title="02 选择正确的性能指标"></a>02 选择正确的性能指标</h3><p>并非每个指标都同等重要。研究最重要的度量标准：一般而言，它与您开始渲染最重要像素的速度以及提供输入响应的速度有关。根据客户的感受确定页面加载的优先级。可交互时间、页面大标题元素的渲染时间、首次有效绘制时间（FMP）、速度指数（Speed Index）一般都很重要。</p><h3 id="03-比你的竞争对手快至少-20"><a href="#03-比你的竞争对手快至少-20" class="headerlink" title="03 比你的竞争对手快至少 20%"></a>03 比你的竞争对手快至少 20%</h3><p>收集代表您受众的设备上的数据。在数据来源上，真实设备比模拟数据更好。选择一台 Moto G4、中端三星设备或者 Nexus 5X 等性能良好的中端设备。或者，也可以通过在电脑上，通过设置网络限速（例如：150ms RTT，1.5Mbps 下载，0.7Mbps 上传）和 CPU 限速（5 倍慢速）以模拟移动体验。最后在常规 3G、4G 和 Wi-Fi 之间切换。收集数据、设置电子表格、将指标提高 20% 并设置目标（即，“性能预算”）。</p><h3 id="04-把这张检查表分享给你的同事"><a href="#04-把这张检查表分享给你的同事" class="headerlink" title="04 把这张检查表分享给你的同事"></a>04 把这张检查表分享给你的同事</h3><p>确保团队中的每个成员都熟悉该清单。每一个决策都涉及性能问题，前端开发人员的积极参与将使您的项目受益匪浅。将你的性能预算映射到设计决策上。</p><h2 id="二、制定现实的目标"><a href="#二、制定现实的目标" class="headerlink" title="二、制定现实的目标"></a>二、制定现实的目标</h2><h3 id="05-100-毫秒的响应时间-每秒60帧"><a href="#05-100-毫秒的响应时间-每秒60帧" class="headerlink" title="05 100 毫秒的响应时间 + 每秒60帧"></a>05 100 毫秒的响应时间 + 每秒60帧</h3><p>每帧动画应在少于 16 毫秒（理想情况下为 10 毫秒）内完成，从而达到每秒 60 帧（1 秒 ÷ 60 = 16.6毫秒）。保持乐观，明智地利用空闲时间。对于像动画这样的高压点，只要能，就不要做任何其它事情。预计输入延迟时间（Estimated Input Latency）应低于 50 毫秒。</p><h3 id="06-速度指数（SpeedIndex）小于-1250，可交互时间（Time-To-Interactive）在-3G-上小于-5-秒"><a href="#06-速度指数（SpeedIndex）小于-1250，可交互时间（Time-To-Interactive）在-3G-上小于-5-秒" class="headerlink" title="06 速度指数（SpeedIndex）小于 1250，可交互时间（Time-To-Interactive）在 3G 上小于 5 秒"></a>06 速度指数（SpeedIndex）小于 1250，可交互时间（Time-To-Interactive）在 3G 上小于 5 秒</h3><p>目标是在 1 秒内（在高速网络下）完成首次绘制（FMP），速度指数（SpeedIndex）低于 1250 毫秒。考虑速度基线是一台有着 3G 网络的，价格为 200 美元左右的 Android 手机（译注：国产千元机水平），那么可以以 400 毫秒 RTT 和 400kb/s 的传输速度进行网络模拟，以达成可交互时间（Time-To-Interactive）小于 5 秒，第二次打开的速度低于 2 秒。尽你所能地降低这些指标。</p><h3 id="07-核心块-15kb，关键文件-lt-170-kb"><a href="#07-核心块-15kb，关键文件-lt-170-kb" class="headerlink" title="07 核心块 = 15kb，关键文件 &lt; 170 kb"></a>07 核心块 = 15kb，关键文件 &lt; 170 kb</h3><p>HTML 的前 14<del>15kb 是最关键的核心块（chunk），也是整个文件中唯一可以在第一个 RTT 内被下载的部分。要实现上述目标，请设定关键文件的最大尺寸“预算”。170kb gzip 后的文件（原始文件尺寸 0.8</del>1mb），在普通手机上可能需要 1 秒才能解析和编译完成。</p><h2 id="三、定义环境"><a href="#三、定义环境" class="headerlink" title="三、定义环境"></a>三、定义环境</h2><h3 id="08-选择并设置你的构建工具"><a href="#08-选择并设置你的构建工具" class="headerlink" title="08 选择并设置你的构建工具"></a>08 选择并设置你的构建工具</h3><p>不要太注意所谓的“酷”。只要您能够快速获得结果，而且在维护构建过程上没有问题就很好了。</p><h3 id="09-渐进增强"><a href="#09-渐进增强" class="headerlink" title="09 渐进增强"></a>09 渐进增强</h3><p>首先设计和构建核心功能，然后再在此基础上为功能强大的浏览器的高级功能增强效果，从而创建弹性的体验。如果您的网站在性能差、网络差的机器上还能运行得比较快，那在性能好、网络棒的机器上只会运行得更快。</p><h3 id="10-设定硬性的性能基准"><a href="#10-设定硬性的性能基准" class="headerlink" title="10 设定硬性的性能基准"></a>10 设定硬性的性能基准</h3><p>用 JavaScript 实现交互效果的成本相当高昂。170kb 的尺寸预算已经包含了核心的 HTML / CSS / JavaScript、路由、状态管理、工具函数、框架还有产品逻辑，因此，请彻底检查我们选择的框架的网络传输成本、解析 / 编译时间和其运行时的时间成本。</p><h3 id="11-圣战止于智者：Angular-React-还是-Ember"><a href="#11-圣战止于智者：Angular-React-还是-Ember" class="headerlink" title="11 圣战止于智者：Angular, React 还是 Ember"></a>11 圣战止于智者：Angular, React 还是 Ember</h3><p>并不是每个项目都需要框架。但是如果你的项目需要框架，那么最好选择使用一个支持服务器端渲染（SSR）的框架。在使用框架之前，请确保在移动设备上以服务器端渲染和客户端渲染两种模式来评估框架的启动时间。了解您将依赖的框架的具体细节。了解 PRPL 模式和 App Shell 模型。</p><h3 id="12-你会使用-AMP-或者-Instant-Articles-吗"><a href="#12-你会使用-AMP-或者-Instant-Articles-吗" class="headerlink" title="12 你会使用 AMP 或者 Instant Articles 吗"></a>12 你会使用 AMP 或者 Instant Articles 吗</h3><p>（译注：AMP 为 Google 的开源项目，意在以组件化的形式以提升移动设备对网站的访问速度；Instant Articles 是 Facebook 的协议，意在通过渲染页面的精简版本以提升页面在 Facebook App 内的打开速度。在国内，MIP 是和 AMP 类似的解决方案。）</p><p>没有它们，你也可以获得良好的性能。但是 AMP 提供了一个可靠的性能框架，有免费的 CDN ，而 Instant Articles 将提高你在 Facebook 上的知名度和性能。你也可以构建一个渐进式 AMP（译注：Progressive Web AMP，PWA 和 AMP 的结合体）。</p><h3 id="13-选择合适的-CDN"><a href="#13-选择合适的-CDN" class="headerlink" title="13 选择合适的 CDN"></a>13 选择合适的 CDN</h3><p>您可以将部分内容“外包”给静态站点生成器，然后将其推送到 CDN，并从CDN 提供静态版本，从而避免数据库请求（即 JAMStack）。当然，这取决于您拥有的动态数据量。仔细检查 CDN 是否为您执行了内容压缩和转换、智能 HTTP/2 和边缘端包含（ESI, edge-side includes）。</p><h2 id="四、优化构建"><a href="#四、优化构建" class="headerlink" title="四、优化构建"></a>四、优化构建</h2><h3 id="14-合理安排优先级"><a href="#14-合理安排优先级" class="headerlink" title="14 合理安排优先级"></a>14 合理安排优先级</h3><p>把你所有的静态资源（JavaScript，图片，字体，第三方脚本，尺寸大的模块）列成一个表，然后把它们按优先级分成三组：基本核心功能（老浏览器也能浏览的核心内容）、增强体验效果（为现代浏览器设计的强大功能和丰富体验）、附加功能（不一定需要并且可以惰性加载的资源，比如字体、轮播脚本、视频播放器、分享按钮等）。</p><h3 id="15-使用“符合标准”技术"><a href="#15-使用“符合标准”技术" class="headerlink" title="15 使用“符合标准”技术"></a>15 使用“符合标准”技术</h3><p>（译注：<a href="https://link.juejin.im/?target=http://responsivenews.co.uk/post/18948466399/cutting-the-mustard">“符合标准”技术（cutting-the-mustard technique）</a>是 BBC News 开发者博客提出的，一种基于浏览器特性来检测其支持程度，并以此选择要加载哪些功能的技术。）</p><p>对老旧的浏览器，仅输出核心功能代码；对现代浏览器输出增强的功能代码。严格按标准加载静态资源：直接加载核心代码，在 DOMContentLoaded 事件中加载增强代码，并在 load 事件中加载剩下的代码。注意：廉价的 Android 手机虽然很符合标准，但这些手机的内存和 CPU 性能有限。因此，您可能需要使用读取设备内存大小的 JavaScript API 来检测设备性能，只有不支持的时候才按“符合标准”技术来。</p><h3 id="16-减少-JavaScript-体积"><a href="#16-减少-JavaScript-体积" class="headerlink" title="16 减少 JavaScript 体积"></a>16 减少 JavaScript 体积</h3><p>由于解析 JavaScript 很耗时，所以请尽可能的减少 JavaScript 的体积。在构建 SPA 时，您可能需要用一定时间初始化应用程序之后，才能开始渲染页面。寻找可以加快初始渲染事件的模块和技术（在低端移动设备上，这可以轻松将速度提高 2-5 倍）。彻底检查每一个 JavaScript 依赖，以找出谁在消耗初始化的宝贵时间。</p><h3 id="17-使用微优化和渐进式启动"><a href="#17-使用微优化和渐进式启动" class="headerlink" title="17 使用微优化和渐进式启动"></a>17 使用微优化和渐进式启动</h3><p>使用服务器端渲染来获得快速的首次有效绘制时间（FMP），但也在页面里输出一些最小功能的 JavaScript 来保持交互时间（TTI）接近首次有效绘制时间（FMP）。然后，如果有需要或者有多余的时间，才开始启动应用程序的非必要部分。在加载时显示一个骨架屏幕，而不是“加载中”动画。</p><h3 id="18-使用摇树和代码分割"><a href="#18-使用摇树和代码分割" class="headerlink" title="18 使用摇树和代码分割"></a>18 使用摇树和代码分割</h3><p>使用摇树（Tree Shaking）技术和代码分割（Code Splitting）技术以减少代码体积。</p><p>摇树（Tree Shaking）技术是一种通过丢弃未使用的代码以在构建过程清理代码的方法。代码分割（Code Splitting）技术将您的代码拆分为按需加载的“chunks（块）”。作用域提升（Scope Hoisting）技术使得链式的依赖能被无缝地转换成行内函数。通过 WebPack 将上述技术用于您的代码。使用 AOT 编译器（译注：例如 Closure Compiler）将一些客户端计算移到服务端。</p><h3 id="19-异步加载-JavaScript"><a href="#19-异步加载-JavaScript" class="headerlink" title="19 异步加载 JavaScript"></a>19 异步加载 JavaScript</h3><p>作为开发者，我们必须显式地使用 <code>defer</code> 和 <code>async</code> 属性来告诉浏览器不要等待脚本下载、开始渲染页面。如果你不需要关注 IE 9 及以下版本的浏览器，那么使用 <code>defer</code> 更好；否则，使用 <code>async</code> 更好。使用静态的分享按钮、静态链接交互式地图而不是使用第三方库。</p><h3 id="20-HTTP-缓存头是否设置好了"><a href="#20-HTTP-缓存头是否设置好了" class="headerlink" title="20 HTTP 缓存头是否设置好了"></a>20 HTTP 缓存头是否设置好了</h3><p>重新检查你是否正确的设置了 Expires, Cache-Control, Max-Age 等 HTTP 缓存控制响应头。通常而言，一个资源要么只被缓存很短的时间（比如经常修改的资源），要么永久缓存（比如不会被更改的那种资源）。使用专为带哈希指纹的静态文件设计的响应头 <code>Cache-Control: imuutable</code> 以避免浏览器重新请求文件。</p><h2 id="五、静态资源优化"><a href="#五、静态资源优化" class="headerlink" title="五、静态资源优化"></a>五、静态资源优化</h2><h3 id="21-是否使用了-Brotli-或-Zopfli-压缩"><a href="#21-是否使用了-Brotli-或-Zopfli-压缩" class="headerlink" title="21 是否使用了 Brotli 或 Zopfli 压缩"></a>21 是否使用了 Brotli 或 Zopfli 压缩</h3><p>Brotli 是一种新的无损压缩格式。现在，所有的现代浏览器都支持它。它比 Gzip 和 Deflate 压缩率更高，压缩非常慢，但是解压速度很快。使用最高压缩比的 Brotli+Gzip 预压缩静态文件，并使用 1~4 级的 Brotli 实时压缩动态内容。也顺便检查一下 CDN 是否支持 Brotli。或者，你也可以试试在不常变化的资源上使用 Zopfli —— 它将数据用 Deflate、Gzip 和 Zlib 格式压缩，并且被设计为一次压缩、多次下载。</p><h3 id="22-图片是否被正确优化"><a href="#22-图片是否被正确优化" class="headerlink" title="22 图片是否被正确优化"></a>22 图片是否被正确优化</h3><p>尽可能使用通过 <code>srcset</code>、<code>sizes</code> 和 <code>&lt;picture&gt;</code> 元素实现的响应式图片。使用 WebP 格式的图片；这可通过 <code>&lt;picutre&gt;</code> 标签配合 JPEG fallback，或者通过 <code>Accept</code> 请求头来实现。对于核心图片，使用渐进式的 JPEG 并用高斯滤镜模糊掉不重要的部分。</p><h3 id="23-Web-Font-是否被正确优化"><a href="#23-Web-Font-是否被正确优化" class="headerlink" title="23 Web Font 是否被正确优化"></a>23 Web Font 是否被正确优化</h3><p>您使用的 Web Font 很可能包含未真正被使用的执行和额外的特性。制作字体的子集（译注：仅包含部分文字的字体，如 fontmin 等方案）。优先使用 WOFF2 并使用 WOFF 作为后备。立即使用后备字体显示文字、异步加载字体（例如，使用 loadCSS），然后再切换字体。同时也考虑本地操作系统中已经安装了的字体。不要忘记在 CSS 中写 <code>font-display: optional</code>；如果你无法从您的服务器加载字体，请记得使用 Font Load Events。</p><h2 id="六、分发优化"><a href="#六、分发优化" class="headerlink" title="六、分发优化"></a>六、分发优化</h2><h3 id="24-快速推送核心-CSS"><a href="#24-快速推送核心-CSS" class="headerlink" title="24 快速推送核心 CSS"></a>24 快速推送核心 CSS</h3><p>将所有首屏渲染所需要的 CSS 放在一起，然后方法在 <code>&lt;head&gt;</code> 标签中。考虑有选择的内联的方法。或者，使用 HTTP/2 服务端推送；但这样你可能需要构建一个可感知缓存的 HTTP/2 服务端推送机制。</p><h3 id="25-使用-babel-preset-env-以仅转译-ES2015-特性"><a href="#25-使用-babel-preset-env-以仅转译-ES2015-特性" class="headerlink" title="25 使用 babel-preset-env 以仅转译 ES2015+ 特性"></a>25 使用 babel-preset-env 以仅转译 ES2015+ 特性</h3><p>由于 ES2015 已被广泛支持了，您可以考虑使用 <code>babel-preset-env</code> 以仅转译现代浏览器不支持的 ES2015+ 特性。然后你可以编译两份，一份是 ES6 ，另一份是 ES5。使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 使得有 ESM 支持的浏览器加载新文件，剩下的老的浏览器可以使用 <code>&lt;script nomodule&gt;</code> 来加载老的文件。</p><h3 id="26-提升渲染性能"><a href="#26-提升渲染性能" class="headerlink" title="26 提升渲染性能"></a>26 提升渲染性能</h3><p>使用 CSS 包含（CSS Containment）隔离渲染十分耗时的组件。请保证在滑动页面或者元素动画的时候，页面不会卡顿，而且你的页面能持续以 60fps 的速度渲染。如果那不可能，那么至少也要把 fps 控制在 15~60 之间。使用 CSS 的 <code>will-change</code> 属性通知浏览器哪个元素将会变化。</p><h3 id="27-使用-Intersection-Observer-懒加载大型脚本"><a href="#27-使用-Intersection-Observer-懒加载大型脚本" class="headerlink" title="27 使用 Intersection Observer 懒加载大型脚本"></a>27 使用 Intersection Observer 懒加载大型脚本</h3><p>Intersection Observer API 提供了异步监听目标元素与祖先元素或顶层文档视口交点中的更改的能力。浏览器支持？Chrome, Firefox, Edge 和三星浏览器都支持了。WebKit 还在开发。浏览器不支持？懒加载一个 polyfill。</p><h3 id="28-是否优化了渲染体验"><a href="#28-是否优化了渲染体验" class="headerlink" title="28 是否优化了渲染体验"></a>28 是否优化了渲染体验</h3><p>不要低估感知性能的作用。在加载静态文件时，尽量始终领先用户一步，这样在后台发生很多事情时，会感觉体验上很快。例如，要让用户持续关注你的页面，请使用骨架屏幕而不是一些加载中的动画。</p><h3 id="29-预热连接以加快分发速度"><a href="#29-预热连接以加快分发速度" class="headerlink" title="29 预热连接以加快分发速度"></a>29 预热连接以加快分发速度</h3><p>使用骨架屏幕，然后懒加载所有的大型组件，比如字体、JavaScript、轮播图、视频和 iframe 等。使用资源提示（Resource Hints），如 <code>dns-prefetch</code>、<code>preconnect</code>、<code>prefetch</code> 和 <code>preload</code>来节省时间。</p><h2 id="七、HTTP-2"><a href="#七、HTTP-2" class="headerlink" title="七、HTTP/2"></a>七、HTTP/2</h2><h3 id="30-为-HTTP-2-做准备"><a href="#30-为-HTTP-2-做准备" class="headerlink" title="30 为 HTTP/2 做准备"></a>30 为 HTTP/2 做准备</h3><p>HTTP/2 支持很好，而且提供了不小的性能提升。缺点是，您必须迁移到 HTTPS；根据您不支持 HTTP/2 的用户群大小，你可能需要为 HTTP/1.1 和 HTTP/2 的用户返回不同版本的代码，这就要求您调整您的编译工具。</p><h3 id="31-正确地部署-HTTP-2"><a href="#31-正确地部署-HTTP-2" class="headerlink" title="31 正确地部署 HTTP/2"></a>31 正确地部署 HTTP/2</h3><p>您需要在打包模块和并行加载许多小模块之间找到一个良好的平衡。将整个界面分解为许多小模块；然后分组、压缩和打包。整个网站分为大约 6 到 10 个包应该是一个不错的折衷方案（对于传统浏览器来说也不错）。通过实验和数据监测来为您的网站找到正确的平衡。</p><h3 id="32-你为-Save-Data-头节约数据流量了吗"><a href="#32-你为-Save-Data-头节约数据流量了吗" class="headerlink" title="32 你为 Save-Data 头节约数据流量了吗"></a>32 你为 Save-Data 头节约数据流量了吗</h3><p>Save-Data 请求提示头可以让我们为关心流量费用和性能的用户提供个性化的响应。例如，你可以把所有高清的图片都改成低清的，不用 Web Font 和华丽的动效，关掉视频自动播放和服务器推送，甚至修改你的应用界面。</p><h3 id="34-确保服务器上的安全性是无懈可击的"><a href="#34-确保服务器上的安全性是无懈可击的" class="headerlink" title="34 确保服务器上的安全性是无懈可击的"></a>34 确保服务器上的安全性是无懈可击的</h3><p>再次检查安全标头是否设置正确，消除已知漏洞，并检查 SSL 证书。确保所有外部插件和跟踪脚本都是通过 HTTPS 加载的、没有 XSS，并且 HSTS 响应头和内容安全策略（CSP）响应头都已正确设置。</p><h3 id="35-你的服务器和-CDN-都支持-HTTP-2-吗"><a href="#35-你的服务器和-CDN-都支持-HTTP-2-吗" class="headerlink" title="35 你的服务器和 CDN 都支持 HTTP/2 吗"></a>35 你的服务器和 CDN 都支持 HTTP/2 吗</h3><p>不同的服务器和 CDN 可能对 HTTP/2 有不同的支持。使用 <a href="https://link.juejin.im/?target=https://istlsfastyet.com/">Is TLS Fast Yet?</a> 来检查你的设置，或者直接看看你的服务器性能如何，支持的特性情况怎么样。</p><h3 id="36-是否启用了-OCSP-Stapling"><a href="#36-是否启用了-OCSP-Stapling" class="headerlink" title="36 是否启用了 OCSP Stapling"></a>36 是否启用了 OCSP Stapling</h3><p>在服务器上启用 OCSP Stapling 有助于提升 TLS 握手速度。OCSP 协议可以让浏览器无需下载并检索证书信息，从而减少握手时间。</p><h3 id="37-你使用-IPv6-了吗"><a href="#37-你使用-IPv6-了吗" class="headerlink" title="37 你使用 IPv6 了吗"></a>37 你使用 IPv6 了吗</h3><p>研究标明，IPv6 的邻居发现（NDP）和路由优化可以使网站快 10% ~ 15%。升级到支持 IPv6 的 DNS 以为未来做好准备。只需确保双栈网络能正常工作——这使得 IPv6 和 IPv4 能同时运行。毕竟，IPv6 不是向后兼容的。</p><h3 id="38-HPACK-压缩启用了吗"><a href="#38-HPACK-压缩启用了吗" class="headerlink" title="38 HPACK 压缩启用了吗"></a>38 HPACK 压缩启用了吗</h3><p>如果你使用了 HTTP/2，再次检查你的服务器是否实现了 HPACK 压缩。HPACK 压缩可以压缩 HTTP 响应头，以减少不必要的开支。由于 HTTP/2 服务器现在都很新，他们可能不能完全支持包括 HPACK 压缩在内的所有标准。H2spec 是一个非常好的用于检测标准支持程度的工具。</p><h3 id="39-你使用了-Service-Worker-来缓存或者提供离线内容吗"><a href="#39-你使用了-Service-Worker-来缓存或者提供离线内容吗" class="headerlink" title="39 你使用了 Service Worker 来缓存或者提供离线内容吗"></a>39 你使用了 Service Worker 来缓存或者提供离线内容吗</h3><p>网络再怎么优化，也不会比本地缓存更快。如果你的网站使用了 HTTPS，那么你可以把静态资源放在 Service Worker 的缓存中，而不用请求网络。</p><h2 id="八、测试和监控"><a href="#八、测试和监控" class="headerlink" title="八、测试和监控"></a>八、测试和监控</h2><h3 id="40-监控混合内容警告"><a href="#40-监控混合内容警告" class="headerlink" title="40 监控混合内容警告"></a>40 监控混合内容警告</h3><p>如果您最近从 HTTP 迁移到了 HTTPS，请确保使用类似 Report-URI.io 之类的服务监控了严格的或被动的混合内容报警。你也可以用 <a href="https://link.juejin.im/?target=https://github.com/bramus/mixed-content-scan">Mixed Content Scan</a> 来扫描你的 HTTPS 站点上是否有非 HTTPS 的混合内容。</p><h3 id="41-使用-DevTools-的开发工作流是优化过的吗"><a href="#41-使用-DevTools-的开发工作流是优化过的吗" class="headerlink" title="41 使用 DevTools 的开发工作流是优化过的吗"></a>41 使用 DevTools 的开发工作流是优化过的吗</h3><p>选择一个调试工具，并试着点击每一个按钮。请确保您理解如何分析渲染性能、控制台输出、调试 JavaScript 和编辑 CSS 样式。</p><h3 id="42-是否在代理浏览器和老式浏览器上测试过了"><a href="#42-是否在代理浏览器和老式浏览器上测试过了" class="headerlink" title="42 是否在代理浏览器和老式浏览器上测试过了"></a>42 是否在代理浏览器和老式浏览器上测试过了</h3><p>在 Chrome 和 Firefox 上测试是不够的。请看看你的网站在代理浏览器和老式浏览器（包括 UC 浏览器和 Opera Mini 等。译者注：此处的代理浏览器即指国内浏览器中常见的云加速功能）上是什么样子。统计你受众国家的网络平均速度，避免出现重大意外。使用网络节流并模拟高 DPI 设备。虽然 BrowserStack 很好，但也得在真机上测试。</p><h3 id="43-是否设置了持续的监控"><a href="#43-是否设置了持续的监控" class="headerlink" title="43 是否设置了持续的监控"></a>43 是否设置了持续的监控</h3><p>良好的性能指标是被动和主动监控工具的组合。拥有 WebPagetest 的私有实例和使用 Lighthouse 确实有利于快速测试，但也需要使用诸如 Calibre、speedscurve 等 RUM 工具建立持续的监控体系。设置您自己的用户计时打点以监控特定的业务速度指标。</p><h2 id="九、速战速决"><a href="#九、速战速决" class="headerlink" title="九、速战速决"></a>九、速战速决</h2><p>此列表相当全面，完成所有优化可能需要相当长的时间。如果你只有一个小时的时间，但又想获得显著的提升，你应该怎么做？我们挑出了 10 个最容易实现的方法。显然，在开始之前和完成之后，请统计结果，包括 3G 和有线连接上的开始渲染时间和速度指数（SpeedIndex）。</p><ol><li> 统计真实的用户体验，设置可接受的目标。一个好的目标大致是：FMP &lt; 1s，速度指数 &lt; 1250，TTI 在 3G 网络上 &lt; 5s 、二次访问 &lt; 2s。优化开始渲染时间和 TTI。</li><li> 为你的主模板准备核心 CSS，并放在 <code>&lt;head&gt;</code> 标签里（你的预算是 14KB）。对于 CSS/JS，请保证核心文件尺寸最大为 170kb （gzip 后的尺寸；压缩前 0.8~1Mb）</li><li> 延迟或懒加载尽可能多的脚本，不管是你自己的还是第三方的——特别是分享按钮、视频播放器和其它的复杂模块。</li><li> 增加资源提示，包括 <code>dns-lookup</code>, <code>preconnect</code>, <code>prefetch</code> 和 <code>preload</code>。</li><li> 为 Web Font 创建子集，并异步加载（或者干脆别用）。</li><li> 优化图片。考虑在关键的页面（比如落地页）上用 WebP 格式。</li><li> 检查 HTTP 缓存头和安全头是否正确设置了。</li><li> 在服务器上启用 Brotli 或者 Zopfli 压缩。如果不支持，别忘了开 gzip。</li><li> 如果有 HTTP/2，启用 HPACK 压缩并上报混合内容警告。如果使用了 LTS，那么请打开 OCSP 装订。</li><li> 如果可能，将静态资源（包括字体、样式、脚本和图片等）尽可能多地在 service worker 里缓存起来。</li></ol><p><em>Huge thanks to Yoav Weiss, Addy Osmani, Artem Denysov, Denys Mishunov, Ilya Pukhalski, Jeremy Wagner, Colin Bendell, Mark Zeman, Patrick Meenan, Leonardo Losoviz, Guy Podjarny, Andy Davies, Rachel Andrew, Anselm Hannemann, Patrick Hamann, Andy Davies, Tim Kadlec, Rey Bango, Matthias Ott, Mariana Peralta, Philipp Tellis, Ryan Townsend, Mohamed Hussain S H, Jacob Groß, Tim Swalling, Bob Visser, Kev Adamson and Rodney Rehm for reviewing this article, as well as our fantastic community, which has shared techniques and lessons learned from its work in performance optimization for everybody to use. You are truly smashing!</em></p>]]></content>
    
    
    <summary type="html">以前，性能往往只是事后的想法。通常直到项目最后的时候才会被考虑，然后被归结为压缩、合并、静态资源优化或者对服务器配置文件的一些细微调整。现在回想起来，事情似乎已经发生了很大的变化。</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="前端" scheme="https://laysan.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能" scheme="https://laysan.site/tags/%E6%80%A7%E8%83%BD/"/>
    
    <category term="优化" scheme="https://laysan.site/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>2018 面试总结及技术规划</title>
    <link href="https://laysan.site/2018/03/interview-summary%20/"/>
    <id>https://laysan.site/2018/03/interview-summary%20/</id>
    <published>2018-03-17T04:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>一晃博客又是大半年没有更新了。主要还是自己的惰性造成的，另外自己也是不善于总结，很多学习到的知识都没有及时的总结，形成文字记录下来，以后还是要多督促一下自己。</p><h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><p>各种原因年后离职了，面试了半个月目前定了一家，趁着周末总结下这次的面试过程和经验。</p><h2 id="面试前的准备"><a href="#面试前的准备" class="headerlink" title="面试前的准备"></a>面试前的准备</h2><p>准备工作还是很重要的，除了准备面试题目，还需要针对性的对面试公司做一定的了解。</p><p>面试的时候经常会问道 <code>你对我们公司了解多少？</code>，如果不稍微准备下这个还真的不好回答。最好面试之前先关注下公司的官网和产品，稍作了解免得什么都说不出来。</p><h2 id="夯实的基础"><a href="#夯实的基础" class="headerlink" title="夯实的基础"></a>夯实的基础</h2><p>不论面试的初级还是高级开发，基础都是必不可少的。</p><p>一些基础知识笔试和面试的时候都会遇上。比如说闭包、this的用法等。</p><h2 id="知识的深度和广度"><a href="#知识的深度和广度" class="headerlink" title="知识的深度和广度"></a>知识的深度和广度</h2><p>我在面试的过程中主要就是吃了这一点的亏，相关的技术了解的很多，但是很多内容都是局限在了解的层面上。</p><p>我说我熟悉React、VUE，然后面试官就问了那给我说一下他们两个的区别，再说下Redux的原理。<br>一时完全答不上来，会用并不代表就理解，而会用只是初级的表现。想要有所提高必须在某方面有比较深入的研究和理解。</p><h2 id="工作经历的多少"><a href="#工作经历的多少" class="headerlink" title="工作经历的多少"></a>工作经历的多少</h2><p>很多公司很关注以前的工作经历以及必问的一个问题 <code>为什么从商家公司离职？</code><br>关于这个问题的回答还是比较讲究的，如果是自己的原因，嫌工资太低了，直说人家觉得你只关注钱。<br>如果是公司的问题，直说人家觉得你一离职就在说公司坏话。<br>所以不管是因为什么，表达的时候还是需要委婉的说出来。</p><p>更重要的一点，在一家公司工作时间的长短和跳槽的频率对找工作还是有一定的影响。<br>一个频繁跳槽，工作不稳定的人公司自然不乐意招。</p><h2 id="常见的面试题"><a href="#常见的面试题" class="headerlink" title="常见的面试题"></a>常见的面试题</h2><ul><li>JS 部分：闭包、this、事件、原型、继承、Promise</li><li>CSS 部分：@import和link、less和sass、Flex布局、动画</li><li>框架部分： Redux流程和原理、虚拟DOM原理、React和VUE对比、ES6</li><li>其他：H5属性、浏览器加载过程、ajax、get和post、系统优化和提速、打包工具、模块化、组件化、浏览器缓存、storage和cookies</li><li>移动端：RN相关技术、小程序相关、微信SDK相关</li></ul><h1 id="2018年技术规划"><a href="#2018年技术规划" class="headerlink" title="2018年技术规划"></a>2018年技术规划</h1><ul><li>深入理解原生JS基础</li><li>深入学习 VUE 相关的使用，理解流程和原理</li><li>阅读 VUE 和 lodash 源码</li><li>深入学习 React 相关的使用（个人比较喜欢React，但是面试过程中大部分公司都是VUE使用的比较多）</li><li>熟悉小程序的开发</li><li>坚持更新博客内容，至少保证两周一篇</li></ul>]]></content>
    
    
    <summary type="html">记录个人2018年初的面试经验并总结，以及规划下这一年的技术发展方向</summary>
    
    
    
    <category term="Other" scheme="https://laysan.site/categories/Other/"/>
    
    
    <category term="Interview" scheme="https://laysan.site/tags/Interview/"/>
    
    <category term="面试" scheme="https://laysan.site/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="总结" scheme="https://laysan.site/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 的装饰器：它们是什么及如何使用</title>
    <link href="https://laysan.site/2017/06/js-decorator/"/>
    <id>https://laysan.site/2017/06/js-decorator/</id>
    <published>2017-06-23T04:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>装饰器的流行应该感谢在Angular 2+中使用，在Angular中，装饰器因TypeScript能使用。但是在JavaScript中，还处于提议阶段。本文将介绍装饰器是什么，及装饰器如何让代码更加简洁和容易理解。</p><h1 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h1><p>装饰器是用一个代码包装另一个代码的简单方式。</p><p>这个概念与之前所听过的函数复合和高阶组件相似。</p><p>这已经用于很多情况，就是简单的将一个函数包装成另一个函数：</p><pre><code class="js">function doSomething(name) &#123;  console.log(&#39;Hello, &#39; + name);&#125;function loggingDecorator(wrapped) &#123;  return function() &#123;    console.log(&#39;Starting&#39;);    const result = wrapped.apply(this, arguments);    console.log(&#39;Finished&#39;);    return result;  &#125;&#125;const wrapped = loggingDecorator(doSomething);</code></pre><p>上个例子产生新函数<code>wrapped</code>，此函数与<code>doSomething</code>做同样事情，但是他们不同在于在包装函数之前和之后输出一些语句。</p><pre><code class="js">doSomething(&#39;Graham&#39;);// Hello, Grahamwrapped(&#39;Graham&#39;);// Starting// Hello, Graham// Finished</code></pre><h1 id="如何使用JavaScript装饰器"><a href="#如何使用JavaScript装饰器" class="headerlink" title="如何使用JavaScript装饰器"></a>如何使用JavaScript装饰器</h1><p>JavaScript中装饰器使用特殊的语法，使用<code>@</code>作为标识符，且放置在被装饰代码之前。</p><blockquote><p><strong>注意：</strong>现在装饰器还处于提议阶段，意味着还有可以变化之处</p></blockquote><p>可以放置许多装饰器在同样代码之前，然后解释器会按照顺序相应执行</p><pre><code class="js">@log()@immutable()class Example &#123;  @time(&#39;demo&#39;)  doSomething() &#123;  &#125;&#125;</code></pre><p>上例中定义了一个类，采用了三个装饰器：两个用于类本身，一个用于类的属性：</p><ul><li>  <code>@log</code>能记录所有所有访问类</li><li>  <code>@immutable</code>让类不可变-也许新实例调用了<code>Object.freeze</code></li><li>  <code>@time</code>会记录一个方法从执行到输出一个独特标签</li></ul><p>现在，虽然现在浏览器或Node还没支持。但是如果使用Babel，能使用 <a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy">transform-decorators-legacy</a>插件使用装饰器。</p><blockquote><p>插件中使用legacy是因为Babel 5支持处理装饰器，但是它也许会跟最终的标准有区别，所以才使用legacy这个词。</p></blockquote><h1 id="为什么使用装饰器"><a href="#为什么使用装饰器" class="headerlink" title="为什么使用装饰器"></a>为什么使用装饰器</h1><p>函数复合在JavaScript已经成为可能，但是它相当困难或不可能用于另一个代码（如类或类属性）。</p><p>装饰器提议可以用于类或属性，未来JavaScript版本可能会增加用于其他地方。</p><p>装饰器也考虑到采用较为简洁的语法。</p><h1 id="不同类型的装饰器"><a href="#不同类型的装饰器" class="headerlink" title="不同类型的装饰器"></a>不同类型的装饰器</h1><p>现在，装饰器只支持类和类属性，这包含属性、方法、get函数和set函数</p><p>装饰器只会在程序第一次运行时执行一次，装饰的代码会被返回的值代替</p><h2 id="类属性装饰器"><a href="#类属性装饰器" class="headerlink" title="类属性装饰器"></a>类属性装饰器</h2><p>属性装饰器适用于类的单独成员-无论是属性、方法、get函数或set函数。<br>装饰器函数调用三个参数：</p><ul><li>  target-被修饰的类</li><li>  name-类成员的名字</li><li>  descriptor-成员描述符。对象会将这个参数传给<code>Object.defineProperty</code></li></ul><p><code>@readonly</code>是经典的例子：</p><pre><code class="js">function readonly(target, name, descriptor) &#123;  descriptor.writable = false;  return descriptor;&#125;</code></pre><p>上例会将成员描述符中的<code>writable</code>设为<code>false</code>。</p><p>接着用于类中属性：</p><pre><code class="js">class Example &#123;  a() &#123;&#125;  @readonly  b() &#123;&#125;&#125;const e = new Example();e.a = 1;e.b = 2;// TypeError: Cannot assign to read only property &#39;b&#39; of object &#39;#&lt;Example&gt;&#39;</code></pre><p>但是我们可以做的更好，可以用别的形式代替装饰函数。例如，记录所有的输入和输出：</p><pre><code class="js">function log(target, name, descriptor) &#123;  const original = descriptor.value;  if (typeof original === &#39;function&#39;) &#123;    descriptor.value = function(...args) &#123;      console.log(`Arguments: $&#123;args&#125;`);      try &#123;        const result = original.apply(this, args);        console.log(`Result: $&#123;result&#125;`);        return result;      &#125; catch (e) &#123;        console.log(`Error: $&#123;e&#125;`);        throw e;      &#125;    &#125;  &#125;  return descriptor;&#125;</code></pre><p>注意我们使用了扩展运算符，会自动将所有参数转为数组。</p><pre><code class="js">class Example &#123;    @log    sum(a, b) &#123;        return a + b;    &#125;&#125;const e = new Example();e.sum(1, 2);// Arguments: 1,2// Result: 3</code></pre><p>可以让装饰器获取一些参数，例如重写<code>log</code>装饰器如下：</p><pre><code class="js">function log(name) &#123;  return function decorator(t, n, descriptor) &#123;    const original = descriptor.value;    if (typeof original === &#39;function&#39;) &#123;      descriptor.value = function(...args) &#123;        console.log(`Arguments for $&#123;name&#125;: $&#123;args&#125;`);        try &#123;          const result = original.apply(this, args);          console.log(`Result from $&#123;name&#125;: $&#123;result&#125;`);          return result;        &#125; catch (e) &#123;          console.log(`Error from $&#123;name&#125;: $&#123;e&#125;`);          throw e;        &#125;      &#125;    &#125;    return descriptor;  &#125;;&#125;</code></pre><p>这与之前的<code>log</code>装饰器相同，只是利用了外部函数的<code>name</code>参数。</p><pre><code class="js">class Example &#123;  @log(&#39;some tag&#39;)  sum(a, b) &#123;    return a + b;  &#125;&#125;const e = new Example();e.sum(1, 2);// Arguments for some tag: 1,2// Result from some tag: 3</code></pre><h1 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h1><p>类装饰器用于整个类，装饰器函数的参数为被装饰的构造器函数。</p><p>注意只用于构造器函数，而不适用于类的每个实例。这就意味着如果想控制实例，就必须返回一个包装版本的构造器函数。</p><p>通常，类装饰器没什么用处，因为你所需要做的，同样可以用一个简单函数来处理。你所做的只需要在结束时返回一个新的构造函数来代替类的构造函数。</p><p>回到我们记录那个例子，编写一个记录构造函数参数：</p><pre><code class="js">function log(Class) &#123;  return (...args) =&gt; &#123;    console.log(args);    return new Class(...args);  &#125;;&#125;</code></pre><p>这里接收一个类作为参数，返回新函数作为构造器。此函数打印出参数，返回这些参数构造的实例。</p><p>例如：</p><pre><code class="js">@logclass Example &#123;  constructor(name, age) &#123;  &#125;&#125;const e = new Example(&#39;Graham&#39;, 34);// [ &#39;Graham&#39;, 34 ]console.log(e);// Example &#123;&#125;</code></pre><p>构造<code>Example</code>类时会输出提供的参数，构造值<code>e</code>也确实是<code>Example</code>的实例。</p><p>传递参数到类装饰器与类成员一样。</p><pre><code class="js">function log(name) &#123;  return function decorator(Class) &#123;    return (...args) =&gt; &#123;      console.log(`Arguments for $&#123;name&#125;: args`);      return new Class(...args);    &#125;;  &#125;&#125;@log(&#39;Demo&#39;)class Example &#123;  constructor(name, age) &#123;&#125;&#125;const e = new Example(&#39;Graham&#39;, 34);// Arguments for Demo: argsconsole.log(e);// Example &#123;&#125;</code></pre><h1 id="真实例子"><a href="#真实例子" class="headerlink" title="真实例子"></a>真实例子</h1><h2 id="Core-decorators"><a href="#Core-decorators" class="headerlink" title="Core decorators"></a>Core decorators</h2><p><a href="https://www.npmjs.com/package/core-decorators">Core decorators</a>是一个库，提供了几个常见的修饰器，通过它可以更好地理解修饰器。</p><p>想理解此库，也可以去看看阮老师的关于<a href="http://es6.ruanyifeng.com/#docs/decorator#core-decorators-js">此库的介绍</a></p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React广泛运用了高阶组件，这让React组件成为一个函数，并且能包含另一个组件。<br>使用装饰器是不错的替代法，例如，Redux库有一个<code>connect</code>函数，用于连接React组件和React store。</p><p>通常，是这么使用的：</p><pre><code class="js">class MyReactComponent extends React.Component &#123;&#125;export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</code></pre><p>然而，可以使用装饰器代替：</p><pre><code class="js">@connect(mapStateToProps, mapDispatchToProps)export default class MyReactComponent extends React.Component &#123;&#125;</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.sitepoint.com/javascript-decorators-what-they-are/">JavaScript Decorators: What They Are and When to Use Them</a><br><a href="http://es6.ruanyifeng.com%2F%23docs%2Fdecorator">阮老师ES6入门-修饰器</a></p>]]></content>
    
    
    <summary type="html">装饰器的流行应该感谢在Angular 2+中使用，在Angular中，装饰器因TypeScript能使用。但是在JavaScript中，还处于提议阶段。本文将介绍装饰器是什么，及装饰器如何让代码更加简洁和容易理解。</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="JavaScript" scheme="https://laysan.site/tags/JavaScript/"/>
    
    <category term="Decorator" scheme="https://laysan.site/tags/Decorator/"/>
    
    <category term="装饰器" scheme="https://laysan.site/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局之-水平垂直居中</title>
    <link href="https://laysan.site/2017/04/css-vertical-align/"/>
    <id>https://laysan.site/2017/04/css-vertical-align/</id>
    <published>2017-04-05T13:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>对一个元素水平垂直居中，在我们的工作中是会经常遇到的，也是 CSS 布局中很重要的一部分，本文就来讲讲 CSS 水平垂直居中的一些方法。</p><span id="more"></span><p>另外，文中的 css 都是用 less 书写的，如果看不懂 less，可以把我给的 demo 链接打开，然后在控制台中查看最终的 css，或者是点击 codepen 上的“View Compiled”按钮，可以查看编译后的 css</p><p>先看一张图，这是去年 cssConf 大会时阿里的 @寒冬 winter 老师放出来的：</p><p><img data-src="//img.souche.com/20160316/png/75f94274a6a7095538eb10cbd18eb4a8.png" alt="alt"></p><p>如图所示，CSS 布局是可以分为几大块的：</p><ul><li>盒子内部的布局<ul><li>文本的布局</li><li>盒模型本身的布局</li></ul></li><li>盒子之间的布局 visual formatting<ul><li>脱离正常流 normal flow 的盒子的布局<ul><li>absolute 布局上下文下的布局</li><li>float 布局上下文下的布局</li></ul></li><li>正常流 normal flow 下的盒子的布局<ul><li>BFC 布局上下文下的布局</li><li>IFC 布局上下文下的布局</li><li>FFC 布局上下文下的布局</li><li>table 布局上下文下的布局</li><li>css grid 布局上下文下的布局</li></ul></li></ul></li></ul><p>所有的 CSS 布局其实都是围绕着这些布局模块来的，水平垂直居中也一样。</p><h4 id="一-文本的水平垂直居中"><a href="#一-文本的水平垂直居中" class="headerlink" title="一. 文本的水平垂直居中"></a>一. 文本的水平垂直居中</h4><p><strong>line-height + text-align:center</strong></p><p><a href="http://codepen.io/Dudy/pen/aOKWWO?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;水平垂直居中水平垂直居中&lt;/div&gt;</code></pre><pre><code class="js">html,body&#123;  margin: 0;&#125;.wrap&#123;  line-height: 400px;  text-align:center;  height: 400px;  font-size: 36px;  background-color: #ccc;&#125;</code></pre><p>这种方法只适合单行文字的水平垂直居中</p><h4 id="二-利用盒模型的水平垂直居中"><a href="#二-利用盒模型的水平垂直居中" class="headerlink" title="二. 利用盒模型的水平垂直居中"></a>二. 利用盒模型的水平垂直居中</h4><p>我们一般讲的盒模型都是说的块级盒的盒模型，也只有块级盒的盒模型用得多一点，块级盒 block-level box 又是分别由 content-box、padding-box、border-box、margin-box 组成的，如下图：</p><p><img data-src="//img.souche.com/20160316/png/93a4055545278d504a8add63bc0883bf.png" alt="Alt text"></p><p>也就说我任一个子盒子的水平和垂直方向的边与最外面盒子的间距都是可以控制的，因此也就有如下居中方法：</p><p><strong>padding 填充</strong></p><p><a href="http://codepen.io/Dudy/pen/EjRvgp?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;content&quot; /&gt;&lt;/div&gt;</code></pre><pre><code class="js">@wrapWidth : 400px;.wrap&#123;  margin-left: auto;  margin-right: auto;  margin-top: 20px;  width: @wrapWidth;  height: @wrapWidth;  background-color: #ccc;&#125;.content&#123;  @contentWidth : 100px;  width: @contentWidth;  height: @contentWidth;  padding: (@wrapWidth - @contentWidth) / 2;  background-color: #333;  background-clip:content-box;&#125;</code></pre><p>也可以用 css3 的 calc()动态计算:</p><p><a href="http://codepen.io/Dudy/pen/RPJZVw?editors=110">DEMO 链接</a></p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;content&quot; /&gt;&lt;/div&gt;</code></pre><pre><code class="js">.wrap&#123;  margin-top: 20px;  margin-left: auto;  margin-right: auto;  width: 400px;  height: 400px;  background-color: #ccc;  .content&#123;    padding: -webkit-calc(~&quot;(100% - 100px) / 2&quot;);    padding: calc(~&quot;(100% - 100px) / 2&quot;);    width: 100px;    height: 100px;    background-color: #333;    background-clip: content-box;  &#125;&#125;</code></pre><p>注意这里我在 calc 中使用了一个~””的写法，这是 less 中的一个语法，告诉 less 这里不被 less 所编译，要是被 less 编译了的话，css 的 calc 函数的参数就不是 100% - 100px，而是 0%了。</p><p><strong>margin 填充</strong></p><p><a href="http://codepen.io/Dudy/pen/jPKxYL?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;ele&quot; /&gt;&lt;/div&gt;</code></pre><pre><code class="js">.wrap&#123;  @wrapHeight : 400px;  @contenHeight : 100px;  overflow: hidden;  width: 100%;  height: @wrapHeight;  background-color: #ccc;  .ele&#123;    margin-left: auto;    margin-right: auto;    margin-top: (@wrapHeight - @contenHeight) / 2;    width: 100px;    height: @contenHeight;    background-color: #333;    color: #fff;  &#125;&#125;</code></pre><p>使用 margin 填充我们需要知道元素的宽度，这点不太灵活，不过 CSS3 搞出了一个加 fit-content 的属性值，可以动态计算元素的宽度，<a href="http://codepen.io/Dudy/pen/yNEZVQ">DEMO 链接</a></p><p>使用盒模型进行布局不会产生 reflow，兼容也好，使用盒模型布局是一种布局思想，其实仅仅靠它就能实现很多 visual formatting 才能实现的布局，这是另一个话题，这里不展开。</p><h4 id="三-absolute-布局上下文下的水平垂直居中"><a href="#三-absolute-布局上下文下的水平垂直居中" class="headerlink" title="三. absolute 布局上下文下的水平垂直居中"></a>三. absolute 布局上下文下的水平垂直居中</h4><p><strong>50% + -50%</strong></p><p>原理很简单，就是利用 left：50%将盒子的左边先置于父容器的中点，然后再将盒子往左偏移盒子自身宽度的 50%，这里有三种具体实现：</p><p><a href="http://codepen.io/Dudy/pen/VLdzRv?editors=110">DEMO 链接</a></p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;ele margin&quot;&gt;水平垂直居中水平垂直&lt;br&gt;居中水平垂直居中水平&lt;br&gt;垂直居中水平垂直居&lt;br&gt;中水平垂直居中&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;ele translate&quot;&gt;水平垂直居中水平垂直&lt;br&gt;居中水平垂直居中水平&lt;br&gt;垂直居中水平垂直居&lt;br&gt;中水平垂直居中&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;ele relative&quot;&gt;    &lt;div class=&quot;ele-inner&quot;&gt;水平垂直居中水平垂直&lt;br&gt;居中水平垂直居中水平&lt;br&gt;垂直居中水平垂直居&lt;br&gt;中水平垂直居中&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="js">.wrap&#123;  position: relative;  width: 100%;  height: 200px;  border:1px solid;  background-color: #ccc;  .ele&#123;    position: absolute;    left: 50%;    top: 50%;    background-color: #333;    &amp;.margin&#123;      width: 160px;      height: 100px;      margin-left: -80px;      margin-top: -50px;    &#125;    &amp;.translate&#123;      -webkit-transform:translate3d(-50%, -50%, 0);      transform:translate3d(-50%, -50%, 0);    &#125;    .ele-inner&#123;      position: relative;      left: -50%;      top: -50%;      width: 100%;      height: 100%;      background-color: #333;    &#125;    &amp;.relative&#123;      width: 150px;      height: 100px;      background-color: transparent;    &#125;  &#125;&#125;</code></pre><p>上面三个方法中，margin 方法和 relative 方法都需要知道元素的宽高才行(relative 方法只知道高也行)，适用于固定式布局，而 transform 方法则可以不知道元素宽高</p><p><strong>text-align:center + absolute</strong></p><p>text-aign:center 本来是不能直接作用于 absolute 元素的，但是没有给其 left 等值的行级 absolute 元素是会受文本的影响的，可以参考张老师的<a href="http://www.zhangxinxu.com/wordpress/2011/12/position-absolute-text-align-center/">这篇文章</a></p><p><a href="http://codepen.io/Dudy/pen/BNVwJx?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;ele&quot; /&gt;&lt;/div&gt;</code></pre><pre><code class="js">.wrap&#123;  text-align: center;  width: 100%;  height: 400px;  background-color: #ccc;  font-size: 0;&#125;.ele&#123;  position: absolute;  margin-left: -(100px / 2);  margin-top: (400px - 100px) / 2;  width: 100px;  height: 100px;  display: inline-block;  background-color: #333;&#125;</code></pre><p>简单解释下，首先，text-align:center 作用的是文本而不是 absolute 的元素，但是，当 absolute 元素为 inline-block 的时候，它会受到文本的影响，然后你可能会问这里没文本啊，我只能告诉你说这下面是有的，是个匿名的文本节点。具体的这里不展开，可以参考<a href="http://www.w3.org/TR/CSS2/visudet.html#propdef-line-height">标准</a>，然后理解这句话:</p><blockquote><p>If the inline box contains no glyphs at all, it is considered to contain a strut (an invisible glyph of zero width) with the A and D of the element’s first available font</p></blockquote><p>然后这个匿名文本由于受到 text-align:center 影响居中了，这个时候 absolute 盒子的左边跟父容器的中点对齐了，所以就还需要往回拉 50%，这里用的是 margin-left，你也可以用其它方式拉。然后就是垂直方向的对齐，垂直方向是不能被操作文本的属性影响的，所以我这里用的是 margin-top 来让它偏移下去。</p><p><strong>absolute + margin : auto</strong></p><p><a href="http://codepen.io/Dudy/pen/mJKqXa?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;ele&quot; /&gt;&lt;/div&gt;</code></pre><pre><code class="js">html,body&#123;  width: 100%;  height: 100%;  margin: 0;&#125;.wrap&#123;  position: relative;  width: 100%;  height: 100%;  background-color: #ccc;  .ele&#123;    position: absolute;    left: 0;    right: 0;    top: 0;    bottom: 0;    margin: auto;    width: 100px;    height: 100px;    background-color: #333;  &#125;&#125;</code></pre><p>关于这种布局的原理，在标准中能找到如下解释：</p><p><a href="http://www.w3.org/TR/CSS21/visudet.html#abs-non-replaced-width">w3c.org</a>中有这样一句话：</p><blockquote><p>The constraint that determines the used values for these elements is:<br>‘left’ + ‘margin-left’ + ‘border-left-width’ + ‘padding-left’ + ‘width’ + ‘padding-right’ + ‘border-right-width’ + ‘margin-right’ + ‘right’ = width of containing block</p></blockquote><p>这句话说的是 absolute 性质的盒子，它的包含块的宽度等于它的盒模型的宽度 + left + right 值，包含块的高度同理，盒模型包括 margin-box、border-box、padding-box、content-box，而在这个居中方法中，.ele 的 left + right 值是 0，width 是定值，width 所在盒子包括了除了 margin-box 外的那三个 box，margin 都是 auto 值，按照上面那个公式，margin-left + margin-right 的值应该等于包含块的宽度 - left 的值 - right 的值 - width 的值，也就是说 margin-left + margin-right 的值等于除了 width 所占宽度外的剩下宽度，拥有剩下宽度后，就是平分其宽度，以让左右两边相等，达到居中，标准中给出了答案：</p><blockquote><p>If none of the three is ‘auto’: If both ‘margin-left’ and ‘margin-right’ are ‘auto’, solve the equation under the extra constraint that the two margins get equal values, unless this would make them negative, in which case when direction of the containing block is ‘ltr’ (‘rtl’), set ‘margin-left’ (‘margin-right’) to zero and solve for ‘margin-right’ (‘margin-left’)</p></blockquote><p>这里的”three”指的是 left, width, right。如果 left、right 和 width 都不为 auto，同时 margin-left 和 margin-right 都是 auto，除非特别情况，它们俩就是相等的，而这个例子中不在特殊情况之列，因此两者平分，此时达到了水平居中。而对于垂直方向的 margin 的 auto 值的计算，标准中也有如下两句话，跟水平方向的同理(这里的“three”指的是“top, height, bottom”)：</p><blockquote><p>the used values of the vertical dimensions must satisfy this constraint:<br>‘top’ + ‘margin-top’ + ‘border-top-width’ + ‘padding-top’ + ‘height’ + ‘padding-bottom’ + ‘border-bottom-width’ + ‘margin-bottom’ + ‘bottom’ = height of containing block</p><p>if none of the three are ‘auto’: If both ‘margin-top’ and ‘margin-bottom’ are ‘auto’, solve the equation under the extra constraint that the two margins get equal values.</p></blockquote><p>垂直方向也就因此也居中了。</p><p>这种方法能简单的做到居中，但是必须有 width 和 height 值</p><p><strong>适用于图片居中的网易 nec 的一个方法</strong></p><p><a href="http://codepen.io/Dudy/pen/GJGzJr?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;p&gt;    &lt;img src=&quot;http://nec.netease.com/img/s/1.jpg&quot; alt=&quot;&quot; /&gt;    &lt;img src=&quot;http://nec.netease.com/img/s/1.jpg&quot; alt=&quot;&quot; /&gt;  &lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="js">html,body&#123;  width: 100%;  height: 100%;  margin: 0;&#125;.wrap&#123;  position:relative;  width: 100%;  height: 100%;  p&#123;    position:absolute;    left:50%;    top:50%;  &#125;  img&#123;    &amp;:nth-child(1)&#123;      position:static;      visibility:hidden;    &#125;    &amp;:nth-child(2)&#123;      position:absolute;      right:50%;      bottom:50%;    &#125;  &#125;&#125;</code></pre><p>这种方法主要是利用了一个图片进行占位，以让父容器获得高宽，从而让进行-50%偏移的图片能有一个参照容器作百分比计算。优点是可以不知道图片的大小，随便放张尺寸不超过父容器的图片上去都能做到居中。另外，兼容性好，如果是不使用 nth-child 选择器的花，IE6 都是能顺利兼容的</p><h4 id="四-float-布局上下文下的水平垂直居中"><a href="#四-float-布局上下文下的水平垂直居中" class="headerlink" title="四. float 布局上下文下的水平垂直居中"></a>四. float 布局上下文下的水平垂直居中</h4><p><strong>float + -50%</strong></p><p><a href="http://codepen.io/Dudy/pen/xGzjZa?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;ele&quot;&gt;    &lt;div class=&quot;ele-inner&quot;&gt;居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中居中居&lt;br&gt;中居中居中居中居中居中居中居中居中居&lt;br&gt;中居中居中居中居中居中居中&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="js">.wrap&#123;  float: left;  width: 100%;  height: 400px;  background-color: #ccc;  .ele&#123;    float: left;    position: relative;    left: 50%;    top: 50%;  &#125;  .ele-inner&#123;    position: relative;    left: -50%;    -webkit-transform : translate3d(0, -50%, 0);    transform : translate3d(0, -50%, 0);    background-color: #333;    color: #fff;  &#125;&#125;</code></pre><p>这种方法的原理，首先是利用 float 属性将需要居中的元素的父元素.ele 的宽度收缩，然后 left:50%将.ele 的左边和水平中线对齐，这个时候还没居中，还需要将其往回拉自身宽度的 50%，于是.ele-inner 便是真正需要水平居中的元素，我给它一个 position:relative，将其往回拉自身宽度 50%就行了。对于垂直方向，依然是先将.ele top:50%到垂直方向中点，但是这时给.ele-inner top:50%是不起作用的，因为如果没给父元素明确高度的话，这个 50%是计算不出来的，因此，就有了 transform : translate3d(0, -50%, 0)。</p><p>这种方法的好处是元素可以不定宽，任何时候都可以做到居中</p><p>我当时在 w3cplus 的站上发现这个方法后，当时觉得这个方法很好，兼容性好，又还可以不定宽，但当我用了一段时间后，发现了一个问题：</p><p>就是当居中元素的父元素 left:50%时，如果元素宽度足够大，会超出外面的容器，而如果外面的容器又正好是 overflow:auto 的话，那就会在外面产生滚动条，问题 DEMO 链接<a href="http://codepen.io/Dudy/pen/vENMwr?editors=110">在这里</a>，后来我找到了一个办法：<a href="http://codepen.io/Dudy/pen/YPWeYY?editors=110">DEMO 链接</a> ，基本思想就是利用元素超出父元素的左边不会产生滚动条的特性，有点奇淫技巧，但是能解决问题，有兴趣的可以看看</p><p><strong>margin-bottom : -50%</strong></p><p><a href="http://codepen.io/Dudy/pen/bdKMrB?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;placeholder&quot; /&gt;  &lt;div class=&quot;content&quot; /&gt;&lt;/div&gt;</code></pre><pre><code class="js">.wrap&#123;  float: left;  width: 100%;  height: 400px;  background-color: #ccc;  @contentHeight : 100px;  .placeholder&#123;    float: left;    width: 100%;    height: 50%;    /*居中元素.content高度一半*/    margin-bottom: -(@contentHeight / 2);  &#125;  .content&#123;    position: relative;    left: 50%;    transform:translate3d(-50%, 0, 0);    clear: both;    /*演示用，实际不需要定宽*/    max-width: 100px;    height: @contentHeight;    background-color: #333;  &#125;&#125;</code></pre><p>这种方法是先让占位元素.placeholder 占据 50%高度，然后给一个居中元素高度一半的负的 margin-bottom，然后下面的元素只要跟着摆放就能垂直居中了。水平方向就是利用 translate 做偏移，这个没什么好说的，你也可以换成其他办法。</p><p>这种方法就是各种固定死，首先最外层的父容器需要一个固定高度，以让.placeholder 的 height:50%有效，然后，margin-bottom 也需要固定死，而且得需要知道居中元素高度。单纯就水平方向来说，这个方法比较适合需要兼容低版本 IE 的固定式布局的项目，因为兼容性好。</p><h4 id="五-BFC-布局上下文下的水平垂直居中"><a href="#五-BFC-布局上下文下的水平垂直居中" class="headerlink" title="五.BFC 布局上下文下的水平垂直居中"></a>五.BFC 布局上下文下的水平垂直居中</h4><p>BFC 的全称是块级排版上下文，这里有篇<a href="http://div.io/topic/834?page=1#3261">文章</a>对齐进行了简单的介绍，BFC 布局上下文下的布局其实就是利用盒模型本身进行的布局，前面在利用盒模型布局的那一节中已经讲过了，这里就不重复了</p><h4 id="六-IFC-布局上下文下的水平垂直居中"><a href="#六-IFC-布局上下文下的水平垂直居中" class="headerlink" title="六.IFC 布局上下文下的水平垂直居中"></a>六.IFC 布局上下文下的水平垂直居中</h4><p>IFC 又是个什么概念呢，你可以看看<a href="http://www.w3.org/TR/CSS21/visuren.html#inline-formatting">官方文档</a>，也可以简单的理解为 display 为 inline 性质的行级元素的布局。</p><p><strong>text-align:center + vertical-align:middle</strong></p><p><a href="http://codepen.io/Dudy/pen/pJKVZa?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&#39;placeholder&#39;&gt;&lt;!--占位元素，用来作为居中元素的参照物--&gt;&lt;/div&gt;  &lt;div class=&quot;ele&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="js">.wrap&#123;  width: 100%;  height: 400px;  /* min-height: 400px; */  text-align:center;  font-size: 0;  background-color: #ccc;  .placeholder,  .ele&#123;    vertical-align: middle;    display: inline-block;  &#125;  .placeholder&#123;    overflow: hidden;    width: 0;    min-height: inherit;    height: inherit;  &#125;  .ele&#123;    width: 100px;    height: 100px;    background-color: #333;  &#125;&#125;</code></pre><p>行级元素会受到 text-align 和 vertical-align 的影响，关于 vertical-align，不太好理解，我多贴几篇文章：<a href="http://www.html-js.com/article/2952">@灵感 idea 的</a>，<a href="http://www.zhangxinxu.com/wordpress/2010/05/%E6%88%91%E5%AF%B9css-vertical-align%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%E4%B8%8E%E8%AE%A4%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/">张鑫旭的</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align">MDN 上的</a>，<a href="https://css-tricks.com/almanac/properties/v/vertical-align/">css-trick 上的</a>，以及<a href="http://www.w3.org/TR/CSS21/visudet.html#line-height">官方文档</a>，这里首先是用 text-center 让 inline-block 水平居中，然后给一个 vertical-align:middle，但是仅仅给 vertical-align:middle 是不够的，因为此时它还没有 vertical-align 对齐的参照物，所以就给了一个占位的 inline-block，它的高度是 100%。</p><p>这个方法对于居中元素不需要定宽高，而且元素根据 vertical-align 值的不同不仅仅可以实现居中，还可以将其放在上面下面等。缺点是父元素需定高</p><p><strong>text-align:center + line-height</strong></p><p><a href="http://codepen.io/Dudy/pen/ZGRmqL?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;ele&quot;&gt;居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中居中&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="js">.wrap&#123;  text-align: center;  line-height: 400px;  width: 100%;  height: 400px;  background-color: #ccc;  font-size: 0;  .ele&#123;    line-height: normal;    vertical-align: middle;    display: inline-block;    background-color: #333;    font-size: 18px;    color: #fff;  &#125;&#125;</code></pre><p>这个方法，首先是水平方向，text-align:center 就行了，至于垂直方向，起作用的就是父容器的一个 line-height 和居中元素的 vertical-align:middle，为什么这两个属性可以让一个 inline-block 垂直居中呢，这里重点是父容器在其下面产生了一个隐匿的文本节点，这个我在上面 text-align:center + absolute 那个方法的讲解中说到过了，然后这个这个隐匿文本节点会因 line-height 属性的作用而拥有了一个父容器一样高的行高，此时元素有了一个 vertical-align 对齐的参照物，再给其 vertical-align:middle 值就能垂直对齐了。</p><p>使用这个方法，居中元素无需定宽高，但缺点是得给父容器一个固定的行高才行。</p><p><strong>text-align:center + font-size</strong></p><p><a href="http://codepen.io/Dudy/pen/vOrvBP?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;ele&quot; /&gt;&lt;/div&gt;</code></pre><pre><code class="js">.wrap&#123;  text-align: center;  font-size: 400px * 0.873;/*约为高度的0.873*/  margin-left: auto;  margin-right: auto;  width: 400px;  height: 400px;  background-color: #ccc;  .ele&#123;    vertical-align: middle;    width: 100px;    height: 100px;    display: inline-block;    background-color: #333;  &#125;&#125;</code></pre><p>这个方法来自淘宝，基本原理还是让隐匿文本节点所占据的行高等于父容器的高度，然后给居中元素一个 vertical-align:middle 对齐的一个参照。只是这里把定义 line-height 值换成了定义 font-size 值，让 font-siz 足够大从而让其行高等于父容器高度。为了证明这个 font-size 的作用，我把居中元素换成文本</p><p><a href="http://codepen.io/Dudy/pen/JdZwGa?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;a&lt;/div&gt;</code></pre><pre><code class="js">.wrap&#123;  text-align: center;  font-size: 400px * 0.873;/*约为高度的0.873*/  margin-left: auto;  margin-right: auto;  width: 400px;  height: 400px;  background-color: #ccc;&#125;</code></pre><p>效果：</p><p><img data-src="//img.souche.com/20160316/png/12de8abcbfff3671be67c69f4353273a.png" alt="alt"></p><p>可以看到字母 a 垂直居中了，这个字母 a 就对应那个隐匿文本节点</p><h4 id="七-FFC-布局上下文下的水平垂直居中"><a href="#七-FFC-布局上下文下的水平垂直居中" class="headerlink" title="七.FFC 布局上下文下的水平垂直居中"></a>七.FFC 布局上下文下的水平垂直居中</h4><p><strong>父元素、子元素都定义 flex：</strong></p><p><a href="http://codepen.io/Dudy/pen/PqaXOZ?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;ele&quot;&gt;  居中居中居中居中居中居中居中&lt;br&gt;    居中居中居中居中居中居中居中&lt;br&gt;    居中居中居中居中居中居中居中&lt;br&gt;    居中居中居中居中居中居中居中&lt;br&gt;    居中居中居中居中居中居中居中  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="js">html,body&#123;  width: 100%;  height: 100%;&#125;.wrap&#123;  display: flex; align-items: center;  justify-content: center;  width: 100%;  height: 100%;  background-color: #ccc;  .ele&#123;    background-color: #333;  &#125;&#125;</code></pre><p><strong>只有父元素定义 flex，子元素定义 margin:auto：</strong></p><p><a href="http://codepen.io/Dudy/pen/zGLzRN?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;ele&quot;&gt;  居中居中居中居中居中居中居中&lt;br&gt;    居中居中居中居中居中居中居中&lt;br&gt;    居中居中居中居中居中居中居中&lt;br&gt;    居中居中居中居中居中居中居中&lt;br&gt;    居中居中居中居中居中居中居中  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="js">html,body&#123;  width: 100%;  height: 100%;&#125;.wrap&#123;  display: flex;  width: 100%;  height: 100%;  background-color: #ccc;  .ele&#123;    margin:auto;    background-color: #333;  &#125;&#125;</code></pre><p>flex box 的标准中有这句话(参考链接:<a href="http://www.w3.org/TR/css-flexbox-1/#item-margins">http://www.w3.org/TR/css-flexbox-1/#item-margins):</a>:)</p><blockquote><p>The margins of adjacent flex items do not collapse. Auto margins absorb extra space in the corresponding dimension and can be used for alignment and to push adjacent flex items apart; see Aligning with auto margins.</p></blockquote><p>意思就是说 flex item 的 margin 不会折叠，在 flex-item 有明确大小并且 margin:auto 时外边距吸收了伸缩包含块下的额外的空间，并且能被用于居中以及会让其相邻的 flex item 尽可能的往这个 flex item 所在的那一个方向靠。</p><p>flexbox 是个很强大的布局模块，也就三个属性就搞定居中了，而且不论父容器还是居中元素都可以不定宽高。参考链接：<a href="http://www.w3cplus.com/css3/a-visual-guide-to-css3-flexbox-properties.html">图解 CSS3 Flexbox 属性</a></p><h4 id="八-table-布局上下文下的水平垂直居中"><a href="#八-table-布局上下文下的水平垂直居中" class="headerlink" title="八.table 布局上下文下的水平垂直居中"></a>八.table 布局上下文下的水平垂直居中</h4><p><a href="http://codepen.io/Dudy/pen/EjRGRO?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;div class=&#39;wrap&#39;&gt;    &lt;div class=&#39;ele&#39;&gt;      &lt;div class=&quot;ele-inner&quot;&gt;居中居中居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中居中居中居中&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="js">.wrap&#123;  width: 100%;  height: 300px;  display: table;  background-color: #ccc;&#125;.ele&#123;  text-align:center;  vertical-align: middle;  display:table-cell;&#125;.ele-inner&#123;  display: inline-block;  background-color: #333;&#125;</code></pre><p>原理就是把 div 模拟成表格（换成真正的表格标签也是可以的），然后给那几个属性就成了，这个没什么好讲的，不懂的去翻翻手册就明白了，然后<a href="http://weibo.com/u/2945647940?topnav=1&wvr=6&topsug=1">@于江水</a>写的一篇<a href="http://yujiangshui.com/about-table/">table 那些事</a>还不错</p><h4 id="九-CSS-grid-布局上下文下的水平垂直居中"><a href="#九-CSS-grid-布局上下文下的水平垂直居中" class="headerlink" title="九.CSS grid 布局上下文下的水平垂直居中"></a>九.CSS grid 布局上下文下的水平垂直居中</h4><p>CSS3 grid layout 是 IE 搞出来的一个布局模块，目前貌似还只有 IE0 和 IE11 支持，我没有研究过其居中的方法，有兴趣的可以看看<a href="http://www.w3cplus.com/blog/tags/356.html">大漠老师的介绍文章</a></p><h4 id="十-其它未知归属的水平垂直居中方法"><a href="#十-其它未知归属的水平垂直居中方法" class="headerlink" title="十.其它未知归属的水平垂直居中方法"></a>十.其它未知归属的水平垂直居中方法</h4><p><strong>使用 button 标签</strong></p><p><a href="http://codepen.io/Dudy/pen/aOKPgr?editors=110">DEMO 链接</a></p><p>代码：</p><pre><code class="js">&lt;button&gt;  &lt;div&gt;    居中居中居中居中居中居中&lt;br&gt;    居中居中居中居中居中居中&lt;br&gt;    居中居中居中居中居中居中&lt;br&gt;    居中居中居中居中居中居中&lt;br&gt;  &lt;/div&gt;&lt;/button&gt;</code></pre><pre><code class="js">button&#123;  width: 100%;  height: 400px;  background-color: #cccccc;  border-width:0;  &amp;:focus&#123;    outline:none;  &#125;  div&#123;    display: inline-block;    font-size: 18px;    background-color: #333;    color: #fff;  &#125;&#125;</code></pre><p>这种方法属于奇淫技巧，利用 button 标签天生外挂的这一技能对其里面的元素进行居中。</p><p><strong>（本文完）</strong></p><blockquote><p>原文地址: <a href="http://div.io/topic/1155">http://div.io/topic/1155</a></p></blockquote>]]></content>
    
    
    <summary type="html">对一个元素水平垂直居中，在我们的工作中是会经常遇到的，也是CSS布局中很重要的一部分，本文就来讲讲CSS水平垂直居中的一些方法。</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="JavaScript" scheme="https://laysan.site/tags/JavaScript/"/>
    
    <category term="CSS" scheme="https://laysan.site/tags/CSS/"/>
    
    <category term="布局" scheme="https://laysan.site/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 字符串常用操作</title>
    <link href="https://laysan.site/2016/12/javascript-string-operation/"/>
    <id>https://laysan.site/2016/12/javascript-string-operation/</id>
    <published>2016-12-20T05:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 字符串用于存储和处理文本。因此在编写 JS 代码之时她总如影随形，在你处理用户的输入数据的时候，在读取或设置 DOM 对象的属性时，在操作 Cookie 时，在转换各种不同 Date 时，诸此等等，繁不能数；而她那满多的 API 呵，总有些让人不愿去记忆的冲动，既然用时常搜，倒不如烂笔头一翻，顺道也体现下博客存在的价值，由此就有了这篇纪要。</p><span id="more"></span><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><h3 id="1-substring"><a href="#1-substring" class="headerlink" title="1. substring()"></a>1. substring()</h3><p>xString.substring(start,end)</p><p>substring()是最常用到的字符串截取方法，它可以接收两个参数(参数不能为负值)，分别是要截取的开始位置和结束位置，它将返回一个新的字符串，其内容是从start处到end-1处的所有字符。若结束参数(end)省略，则表示从start位置一直截取到最后。</p><pre><code class="js">let str = &#39;www.jeffjade.com&#39;console.log(str.substring(0,3)) // wwwconsole.log(str.substring(0))   //www.jeffjade.comconsole.log(str.substring(-2))  //www.jeffjade.com (传负值则视为0)</code></pre><h3 id="2-slice"><a href="#2-slice" class="headerlink" title="2. slice()"></a>2. slice()</h3><pre><code class="js">stringObject.slice(start, end)</code></pre><p><code>slice()</code>方法与<code>substring()</code>方法非常类似，它传入的两个参数也分别对应着开始位置和结束位置。而区别在于，<code>slice()</code>中的参数可以为负值，如果参数是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符。</p><pre><code class="js">let str = &#39;www.jeffjade.com&#39;console.log(str.slice(0, 3))    // wwwconsole.log(str.slice(-3, -1))  // coconsole.log(str.slice(1, -1))   // www.jeffjade.coconsole.log(str.slice(2, 1))    // &#39;&#39; (返回空字符串,start须小于end)console.log(str.slice(-3, 0))   // &#39;&#39; (返回空字符串,start须小于end)</code></pre><h3 id="3-substr"><a href="#3-substr" class="headerlink" title="3. substr()"></a>3. substr()</h3><pre><code class="js">stringObject.substr(start,length)</code></pre><p><code>substr()</code>方法可在字符串中抽取从<code>start</code>下标开始的指定数目的字符。其返回值为一个字符串，包含从<code> stringObject</code>的<code>start</code>（包括<code>start</code>所指的字符）处开始的<code>length</code>个字符。如果没有指定 <code>length</code>，那么返回的字符串包含从<code>start</code>到<code>stringObject</code>的结尾的字符。另外如果<code>start</code>为负数，则表示从字符串尾部开始算起。</p><pre><code class="js">let str = &#39;www.jeffjade.com&#39;console.log(webStr.substr(1, 3))   // ww.console.log(webStr.substr(0))      // www.jeffjade.comconsole.log(webStr.substr(-3, 3))  // comconsole.log(webStr.substr(-1, 5))  // m  (目标长度较大的话，以实际截取的长度为准)</code></pre><h3 id="4-split"><a href="#4-split" class="headerlink" title="4. split()"></a>4. split()</h3><pre><code class="js">str.split([separator][, limit])</code></pre><p><code>separator</code> 指定用来分割字符串的字符（串）。<code>separator</code> 可以是一个字符串或正则表达式。 如果忽略 <code>separator</code>，则返回整个字符串的数组形式。如果 <code>separator</code> 是一个空字符串，则 str 将会把原字符串中每个字符的数组形式返回。<br>limit 一个整数，限定返回的分割片段数量。split 方法仍然分割每一个匹配的 <code>separator</code>，但是返回的数组只会截取最多 limit 个元素。</p><pre><code class="js">let str = &#39;www.jeffjade.com&#39;str.split(&#39;.&#39;)      // [&quot;www&quot;, &quot;jeffjade&quot;, &quot;com&quot;]str.split(&#39;.&#39;, 1)   // [&quot;www&quot;]str.split(&#39;.&#39;).join(&#39;&#39;) // wwwjeffjadecom</code></pre><p>话说这个函数真心好用，很多时候的字符截取需求，就是依赖于某个字符；而以上三个函数都需知道其位置。我们当然可以借助 indexOf 等方法获取，很显然这很繁琐；而借助 split 则显得更轻而易举。</p><h2 id="查找类方法"><a href="#查找类方法" class="headerlink" title="查找类方法"></a>查找类方法</h2><h3 id="1-indexOf-amp-includes"><a href="#1-indexOf-amp-includes" class="headerlink" title="1. indexOf() &amp; includes()"></a>1. indexOf() &amp; includes()</h3><pre><code class="js">stringObject.indexOf(searchValue,fromIndex)</code></pre><p><code>indexOf()</code>用来检索指定的字符串值在字符串中首次出现的位置。它可以接收两个参数，<code>searchValue</code>表示要查找的子字符串，<code>fromIndex</code> 表示查找的开始位置，省略的话则从开始位置进行检索。</p><pre><code class="js">let str = &#39;www.jeffjade.com&#39;console.log(str.indexOf(&#39;.&#39;))     // 3console.log(str.indexOf(&#39;.&#39;, 1))  // 3console.log(str.indexOf(&#39;.&#39;, 5))  // 12console.log(str.indexOf(&#39;.&#39;, 12)) // -1</code></pre><p>虽然 <code>indexOf()</code>用来检索指定的字符串值在字符串中首次出现的位置 ，然而很多时候，使用它的场景在于判断字符串中是否存在指定的字符串；因此代码就会如此：</p><pre><code class="js">if (str.indexOf(&#39;yoursPecifiedStr&#39;) !== -1) &#123;    // do something&#125;</code></pre><p>要知道在这样的场景下，ES6 语言中的<code>includes()</code>就显得更优雅许多；<code>includes()</code> 方法用于判断一个字符串是否被包含在另一个字符串中，如果是返回true，否则返回false。</p><pre><code class="js">str.includes(searchString[, position])</code></pre><p><code>searchString</code> 将要搜寻的子字符串。<code>position</code> 可选。从当前字符串的哪个索引位置开始搜寻子字符串；默认为0。需要注意的是，<code>includes()</code> 是区分大小写的。</p><pre><code class="js">&#39;Blue Whale&#39;.includes(&#39;blue&#39;); // returns false&#39;乔峰乔布斯乔帮主&#39;.includes(&#39;乔布斯&#39;); // returns trueif (str.includes(&#39;yoursPecifiedStr&#39;)) &#123;    // do something(这样写是不是更为人性化？Yeah，这是一个更趋向人性化的时代嘛)&#125;</code></pre><h3 id="2-lastIndexOf"><a href="#2-lastIndexOf" class="headerlink" title="2. lastIndexOf()"></a>2. lastIndexOf()</h3><pre><code class="js">stringObject.lastIndexOf(searchValue,fromIndex)</code></pre><p><code>lastIndexOf()</code>语法与<code>indexOf()</code>类似，它返回的是一个指定的子字符串值最后出现的位置，其检索顺序是从后向前。</p><pre><code class="js">let str = &#39;www.jeffjade.com&#39;console.log(str.lastIndexOf(&#39;.&#39;))     // 12console.log(str.lastIndexOf(&#39;.&#39;, 1))  // -1console.log(str.lastIndexOf(&#39;.&#39;, 5))  // 3console.log(str.lastIndexOf(&#39;.&#39;, 12)) // 12</code></pre><h3 id="3-search"><a href="#3-search" class="headerlink" title="3. search()"></a>3. search()</h3><pre><code class="js">stringObject.search(substr)stringObject.search(regexp)</code></pre><p>search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。它会返回第一个匹配的子字符串的起始位置，如果没有匹配的，则返回-1。</p><pre><code class="js">let str = &#39;www.jeffjade.com&#39;console.log(str.search(&#39;w&#39;))    // 0console.log(str.search(/j/g))   // 4console.log(str.search(/\./g))  // 3</code></pre><h3 id="4-match-方法"><a href="#4-match-方法" class="headerlink" title="4. match()方法"></a>4. match()方法</h3><pre><code class="js">stringObject.match(substr)stringObject.match(regexp)</code></pre><p><code>match()</code>方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p><p>如果参数中传入的是子字符串或是没有进行全局匹配的正则表达式，那么match()方法会从开始位置执行一次匹配，如果没有匹配到结果，则返回null。否则则会返回一个数组，该数组的第0个元素存放的是匹配文本，除此之外，返回的数组还含有两个对象属性index和input，分别表示匹配文本的起始字符索引和stringObject 的引用(即原字符串)。</p><pre><code class="js">let str = &#39;#1a2b3c4d5e#&#39;;console.log(str.match(&#39;A&#39;));    //返回nullconsole.log(str.match(&#39;b&#39;));    //返回[&quot;b&quot;, index: 4, input: &quot;#1a2b3c4d5e#&quot;]console.log(str.match(/b/));    //返回[&quot;b&quot;, index: 4, input: &quot;#1a2b3c4d5e#&quot;]</code></pre><p>如果参数传入的是具有全局匹配的正则表达式，那么match()从开始位置进行多次匹配，直到最后。如果没有匹配到结果，则返回null。否则则会返回一个数组，数组中存放所有符合要求的子字符串，并且没有index和input属性。</p><pre><code class="js">let str = &#39;#1a2b3c4d5e#&#39;console.log(str.match(/h/g))     //返回nullconsole.log(str.match(/\d/g))    //返回[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</code></pre><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h3><pre><code class="js">stringObject.replace(regexp/substr,replacement)</code></pre><p><code>replace()</code>方法用来进行字符串替换操作，它可以接收两个参数，前者为被替换的子字符串（可以是正则），后者为用来替换的文本。</p><p>如果第一个参数传入的是子字符串或是没有进行全局匹配的正则表达式，那么replace()方法将只进行一次替换（即替换最前面的），返回经过一次替换后的结果字符串。</p><pre><code class="js">let str = &#39;www.jeffjade.com&#39;console.log(str.replace(&#39;w&#39;, &#39;W&#39;))   // Www.jeffjade.comconsole.log(str.replace(/w/, &#39;W&#39;))   // Www.jeffjade.com</code></pre><p>如果第一个参数传入的全局匹配的正则表达式，那么replace()将会对符合条件的子字符串进行多次替换，最后返回经过多次替换的结果字符串。</p><pre><code class="js">let str = &#39;www.jeffjade.com&#39;console.log(str.replace(/w/g, &#39;W&#39;))   // WWW.jeffjade.com</code></pre><h3 id="toLowerCase-amp-toUpperCase"><a href="#toLowerCase-amp-toUpperCase" class="headerlink" title="toLowerCase() &amp; toUpperCase()"></a>toLowerCase() &amp; toUpperCase()</h3><pre><code class="js">stringObject.toLowerCase()stringObject.toUpperCase()</code></pre><p><code>toLowerCase()</code>方法可以把字符串中的大写字母转换为小写，<code>toUpperCase()</code>方法可以把字符串中的小写字母转换为大写。</p><pre><code class="js">let str = &#39;www.jeffjade.com&#39;console.log(str.toLowerCase())   // www.jeffjade.comconsole.log(str.toUpperCase())   // WWW.JEFFJADE.COM</code></pre><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>这个也是 ES6 才引入进来的新语法，来解决传统输出String模板的蹩脚问题；其功能之强大，设计之贴心，着实令人得到极大满足感，好如久旱逢甘霖一般的舒畅。更何况，在当今 MVVM 前端框架大行其道的时代，使用 ES6 语法也是不用自己个儿去操心兼容性问题，对于塑造 Dom Template 更是如虎添翼，令人爱不释手。</p><p>对于她的使用，阮一峰在ECMAScript 6 入门有过详细的描述以及示例，在此就不赘述。只需要明白我们可以像这样去操作了，试问爽否？</p><pre><code class="js">function ncieFunc() &#123;  return &quot;四海无人对夕阳&quot;;&#125;var niceMan = &quot;陈寅恪&quot;;var jadeTalk = `一生负气成今日 \n $&#123;ncieFunc()&#125; ,语出 $&#123;niceMan&#125; 的《忆故居》。`console.log(jadeTalk)</code></pre><p>运行之，Chrome Console 输出结果如下：</p><pre><code>    一生负气成今日    四海无人对夕阳 ,    语出 陈寅恪 的《忆故居》。</code></pre><h2 id="组合其法"><a href="#组合其法" class="headerlink" title="组合其法"></a>组合其法</h2><p>细看 JavaScript 提供的String Api，还是有蛮多的，也有些许废弃的，也有将在未来版本会出来的；这其中不乏很多也挺有用的，譬如： charAt(x)、charCodeAt(x)、concat(v1, v2,…)、fromCharCode(c1, c2,…) 等等,还有 ES6 对字符串的扩展，比如 字符串的遍历器接口，repeat() 等等，这可以参见 ES6-string，这里就不多赘述。</p><p>在实际代码生产中，很多时候需要用这些提供的基本方法，来打出一套组合拳，以解决其需求所需。很显然又可以借助 prototype 属性，将自造的各路拳法，其归置于 String 对象，然后天亮啦。这一步就看个人喜好了，这里抛出一二段，以引大玉。</p><h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><pre><code class="js">String.prototype.reverse = function () &#123;    return this.split(&#39;&#39;).reverse().join(&#39;&#39;)&#125;</code></pre><h3 id="去除空白行"><a href="#去除空白行" class="headerlink" title="去除空白行"></a>去除空白行</h3><pre><code class="js">String.prototype.removeBlankLines = function () &#123;    return this.replace(/(\n[\s\t]*\r*\n)/g, &#39;\n&#39;).replace(/^[\n\r\n\t]*|[\n\r\n\t]*$/g, &#39;&#39;)&#125;</code></pre><h3 id="String转化为数组"><a href="#String转化为数组" class="headerlink" title="String转化为数组"></a>String转化为数组</h3><h4 id="1-转化为一维数组"><a href="#1-转化为一维数组" class="headerlink" title="1, 转化为一维数组"></a>1, 转化为一维数组</h4><p>场景是根据某子字符串转化，直接就用 split 就好；如果转换规则不统一，那么请自求多福吧。</p><pre><code class="js">let Str = &#39;陈寅恪,鲁迅,钱钟书,胡适,王国维,梁启超,吴宓,季羡林&#39;let hallAllOfFameArr = Str.split(&#39;,&#39;)console.log(hallAllOfFameArr)// [&quot;陈寅恪&quot;, &quot;鲁迅&quot;, &quot;钱钟书&quot;, &quot;胡适&quot;, &quot;王国维&quot;, &quot;梁启超&quot;, &quot;吴宓&quot;, &quot;季羡林&quot;]</code></pre><h4 id="2-转化为二维数组"><a href="#2-转化为二维数组" class="headerlink" title="2, 转化为二维数组"></a>2, 转化为二维数组</h4><pre><code class="js">String.prototype.removeBlankLines = function () &#123;    return this.replace(/(\n[\s\t]*\r*\n)/g, &#39;\n&#39;).replace(/^[\n\r\n\t]*|[\n\r\n\t]*$/g, &#39;&#39;)&#125;String.prototype.strTo2dArr = function(firstSplit, secondSplit)&#123;    var contentStr = this.removeBlankLines(),        contentStrArr = contentStr.split(firstSplit),        resultArr = contentStrArr.map((element) =&gt; &#123;            return element.split(secondSplit)        &#125;)    return resultArr&#125;var str = `渺渺钟声出远方,依依林影万鸦藏。一生负气成今日,四海无人对夕阳。破碎山河迎胜利,残馀岁月送凄凉。松门松菊何年梦,且认他乡作故乡。`console.log(str.strTo2dArr(&#39;\n&#39;, &#39;,&#39;))</code></pre><p>运行之，输出结果如下：</p><pre><code>[ [ ‘渺渺钟声出远方’, ‘依依林影万鸦藏。’ ],[ ‘一生负气成今日’, ‘四海无人对夕阳。’ ],[ ‘破碎山河迎胜利’, ‘残馀岁月送凄凉。’ ],[ ‘松门松菊何年梦’, ‘且认他乡作故乡。’ ] ]</code></pre>]]></content>
    
    
    <summary type="html">JavaScript 字符串用于存储和处理文本。因此在编写 JS 代码之时她总如影随形，在你处理用户的输入数据的时候，在读取或设置 DOM 对象的属性时，在操作 Cookie 时，在转换各种不同 Date 时，诸此等等，繁不能数.</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="JavaScript" scheme="https://laysan.site/tags/JavaScript/"/>
    
    <category term="String" scheme="https://laysan.site/tags/String/"/>
    
    <category term="字符串" scheme="https://laysan.site/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>深入了解 JavaScript 中的 for 循环</title>
    <link href="https://laysan.site/2016/12/javascript-for-loop/"/>
    <id>https://laysan.site/2016/12/javascript-for-loop/</id>
    <published>2016-12-12T05:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://link.zhihu.com/?target=http://ecma-international.org/ecma-262/5.1/">ECMAScript5（简称 ES5）</a>中，有三种 for 循环，分别是：</p><ul><li>  简单for循环</li><li>  for-in</li><li>  forEach</li></ul><p>在2015年6月份发布的<a href="https://link.zhihu.com/?target=https://people.mozilla.org/~jorendorff/es6-draft.html">ECMAScript6（简称 ES6）</a>中，新增了一种循环，是：</p><ul><li>  for-of</li></ul><p>下面我们就来看看这 4 种 for 循环。</p><span id="more"></span><h2 id="简单-for-循环"><a href="#简单-for-循环" class="headerlink" title="简单 for 循环"></a>简单 for 循环</h2><p>下面先来看看大家最常见的一种写法：</p><pre><code class="js">const arr = [1, 2, 3];for(let i = 0; i　&lt; arr.length; i++) &#123;    console.log(arr[i]);&#125;</code></pre><p>当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率，下面是改进的写法：</p><pre><code class="js">const arr = [1, 2, 3];for(let i = 0, len = arr.length; i &lt; len; i++) &#123;    console.log(arr[i]);&#125;</code></pre><h2 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h2><p>通常情况下，我们可以用 for-in 来遍历一遍数组的内容，代码如下：</p><pre><code class="js">const arr = [1, 2, 3];let index;for(index in arr) &#123;    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);&#125;</code></pre><p>一般情况下，运行结果如下：</p><pre><code class="js">arr[0] = 1arr[1] = 2arr[2] = 3</code></pre><p>但这么做往往会出现问题。</p><p><strong>for-in 的真相</strong></p><p>for-in 循环遍历的是对象的属性，而不是数组的索引。因此， for-in 遍历的对象便不局限于数组，还可以遍历对象。例子如下：</p><pre><code class="js">const person = &#123;    fname: &quot;san&quot;,    lname: &quot;zhang&quot;,    age: 99&#125;;let info;for(info in person) &#123;    console.log(&quot;person[&quot; + info + &quot;] = &quot; + person[info]);&#125;</code></pre><p>结果如下：</p><pre><code class="js">person[fname] = sanperson[lname] = zhangperson[age] = 99</code></pre><p>需要注意的是， for-in 遍历属性的顺序并不确定，即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。</p><p><strong>Array 的真相</strong></p><p>Array 在 Javascript 中是一个对象， Array 的索引是属性名。事实上， Javascript 中的 “array” 有些误导性， Javascript 中的 Array 并不像大部分其他语言的数组。首先， Javascript 中的 Array 在内存上并不连续，其次， Array 的索引并不是指偏移量。实际上， Array 的索引也不是 Number 类型，而是 String 类型的。我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0″ 。所以，在 Javascript 中从来就没有 Array 的索引，而只有类似 “0″ 、 “1″ 等等的属性。有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。</p><p>现在，我们再回过头来看看用 for-in 来循环数组的例子,我们修改一下前面遍历数组的例子：</p><pre><code class="js">const arr = [1, 2, 3];arr.name = &quot;Hello world&quot;;let index;for(index in arr) &#123;    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);&#125;</code></pre><p>运行结果是：</p><pre><code class="js">arr[0] = 1arr[1] = 2arr[2] = 3arr[name] = Hello world</code></pre><p>我们看到 for-in 循环访问了我们新增的 “name” 属性，因为 for-in 遍历了对象的所有属性，而不仅仅是“索引”。同时需要注意的是，此处输出的索引值，即 “0″、 “1″、 “2″不是 Number 类型的，而是 String 类型的，因为其就是作为属性输出，而不是索引。那是不是说不在我们的 Array 对象中添加新的属性，我们就可以只输出数组中的内容了呢？答案是否定的。因为 for-in 不仅仅遍历 array 自身的属性，其还遍历 array 原型链上的所有可枚举的属性。下面我们看个例子：</p><pre><code class="js">Array.prototype.fatherName = &quot;Father&quot;;const arr = [1, 2, 3];arr.name = &quot;Hello world&quot;;let index;for(index in arr) &#123;    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);&#125;</code></pre><p>运行结果是：</p><pre><code class="js">arr[0] = 1arr[1] = 2arr[2] = 3arr[name] = Hello worldarr[fatherName] = Father</code></pre><p>写到这里，我们可以发现 for-in 并不适合用来遍历 Array 中的元素，其更适合遍历对象中的属性，这也是其被创造出来的初衷。却有一种情况例外，就是稀疏数组。考虑下面的例子：</p><pre><code class="js">let key;const arr = [];arr[0] = &quot;a&quot;;arr[100] = &quot;b&quot;;arr[10000] = &quot;c&quot;;for(key in arr) &#123;    if(arr.hasOwnProperty(key)  &amp;&amp;            /^0$|^[1-9]\d*$/.test(key) &amp;&amp;            key &lt;= 4294967294                       ) &#123;        console.log(arr[key]);    &#125;&#125;</code></pre><p>for-in 只会遍历存在的实体，上面的例子中， for-in 遍历了3次（遍历属性分别为”0″、 “100″、 “10000″的元素，普通 for 循环则会遍历 10001 次）。所以，只要处理得当， for-in 在遍历 Array 中元素也能发挥巨大作用。</p><p>为了避免重复劳动，我们可以包装一下上面的代码：</p><pre><code class="js">function arrayHasOwnIndex(array, prop) &#123;    return array.hasOwnProperty(prop) &amp;&amp;        /^0$|^[1-9]\d*$/.test(prop) &amp;&amp;        prop &lt;= 4294967294; // 2^32 - 2&#125;</code></pre><p>使用示例如下：</p><pre><code class="js">for (let key in arr) &#123;    if (arrayHasOwnIndex(arr, key)) &#123;        console.log(arr[key]);    &#125;&#125;</code></pre><p><strong>for-in 性能</strong></p><p>正如上面所说，每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢，一般速度为其他类型循环的 1/7。因此，除非明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快，比如下面的例子：</p><pre><code class="js">const obj = &#123;    &quot;prop1&quot;: &quot;value1&quot;,    &quot;prop2&quot;: &quot;value2&quot;&#125;;const props = [&quot;prop1&quot;, &quot;prop2&quot;];for(let i = 0; i &lt; props.length; i++) &#123;    console.log(obj[props[i]]);&#125;</code></pre><p>上面代码中，将对象的属性都存入一个数组中，相对于 <code>for-in</code> 查找每一个属性，该代码只关注给定的属性，节省了循环的开销和时间。</p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>在 ES5 中，引入了新的循环，即 forEach 循环。</p><pre><code class="js">const arr = [1, 2, 3];arr.forEach((data) =&gt; &#123;    console.log(data);&#125;);</code></pre><p>运行结果：</p><pre><code class="js">123</code></pre><p>forEach 方法为数组中含有有效值的每一项执行一次 callback 函数，那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。 callback 函数会被依次传入三个参数：</p><ul><li>  数组当前项的值；</li><li>  数组当前项的索引；</li><li>  数组对象本身；</li></ul><p>需要注意的是，forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。</p><pre><code class="js">const arr = [];arr[0] = &quot;a&quot;;arr[3] = &quot;b&quot;;arr[10] = &quot;c&quot;;arr.name = &quot;Hello world&quot;;arr.forEach((data, index, array) =&gt; &#123;    console.log(data, index, array);&#125;);</code></pre><p>运行结果：</p><pre><code class="js">a 0 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]b 3 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]c 10 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]</code></pre><p>这里的 index 是 Number 类型，并且也不会像 for-in 一样遍历原型链上的属性。</p><p>所以，使用 forEach 时，我们不需要专门地声明 index 和遍历的元素，因为这些都作为回调函数的参数。</p><p>另外，forEach 将会遍历数组中的所有元素，但是 ES5 定义了一些其他有用的方法，下面是一部分：</p><ul><li>  every: 循环在第一次 return false 后返回</li><li>  some: 循环在第一次 return true 后返回</li><li>  filter: 返回一个新的数组，该数组内的元素满足回调函数</li><li>  map: 将原数组中的元素处理后再返回</li><li>  reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果。</li></ul><p><strong>forEach 性能</strong></p><p>大家可以看 <a href="https://jsperf.com/for-vs-foreach/66">jsPerf</a> ，在不同浏览器下测试的结果都是 forEach 的速度不如 for。如果大家把测试代码放在控制台的话，可能会得到不一样的结果，主要原因是控制台的执行环境与真实的代码执行环境有所区别。</p><h2 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h2><p>先来看个例子：</p><pre><code class="js">const arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];for(let data of arr) &#123;    console.log(data);&#125;</code></pre><p>运行结果是：</p><pre><code class="js">abc</code></pre><p><strong>为什么要引进 for-of？</strong></p><p>要回答这个问题，我们先来看看ES6之前的 3 种 for 循环有什么缺陷：</p><ul><li>  forEach 不能 break 和 return；</li><li>  for-in 缺点更加明显，它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。而且，遍历数组元素的顺序可能是随机的。</li></ul><p>所以，鉴于以上种种缺陷，我们需要改进原先的 for 循环。但 ES6 不会破坏你已经写好的 JS 代码。目前，成千上万的 Web 网站依赖 for-in 循环，其中一些网站甚至将其用于数组遍历。如果想通过修正 for-in 循环增加数组遍历支持会让这一切变得更加混乱，因此，标准委员会在 ES6 中增加了一种新的循环语法来解决目前的问题，即 for-of 。</p><p>那 for-of 到底可以干什么呢？</p><ul><li>  跟 forEach 相比，可以正确响应 break, continue, return。</li><li>  for-of 循环不仅支持数组，还支持大多数类数组对象，例如 DOM nodelist 对象。</li><li>  for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。</li><li>  for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历。</li></ul><p>总结一下，for-of 循环有以下几个特征：</p><ul><li>  这是最简洁、最直接的遍历数组元素的语法。</li><li>  这个方法避开了 for-in 循环的所有缺陷。</li><li>  与 forEach 不同的是，它可以正确响应 break、continue 和 return 语句。</li><li>  其不仅可以遍历数组，还可以遍历类数组对象和其他可迭代对象。</li></ul><p>但需要注意的是，for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用</p><p>for-in 循环（这也是它的本职工作）。</p><p>最后要说的是，ES6 引进的另一个方式也能实现遍历数组的值，那就是 Iterator。上个例子：</p><pre><code class="js">const arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];const iter = arr[Symbol.iterator]();iter.next() // &#123; value: &#39;a&#39;, done: false &#125;iter.next() // &#123; value: &#39;b&#39;, done: false &#125;iter.next() // &#123; value: &#39;c&#39;, done: false &#125;iter.next() // &#123; value: undefined, done: true &#125;</code></pre><p>不过，这个内容超出了本文的范围，而且 Iterator 要讲的也有很多，以后有时间专门写一篇文章介绍，欢迎关注。</p>]]></content>
    
    
    <summary type="html">深入了解 JavaScript 中的 for 循环</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="JavaScript" scheme="https://laysan.site/tags/JavaScript/"/>
    
    <category term="For" scheme="https://laysan.site/tags/For/"/>
    
  </entry>
  
  <entry>
    <title>10个习惯助你成为一名优秀的程序员</title>
    <link href="https://laysan.site/2016/11/10-behaviors-will-make-unstoppable-programmer/"/>
    <id>https://laysan.site/2016/11/10-behaviors-will-make-unstoppable-programmer/</id>
    <published>2016-11-22T01:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>当谈到编程时，很多人应该都有听过10x程序员的说法。 据说一个10x程序员的效率大约是其他程序员的10倍。</p><p>这是一个有争议的话题，无论你选择相信10x程序员，还是认为这十分可笑，下面的10个习惯可以在一定程度上助你成为一名势不可挡的优秀程序员。</p><span id="more"></span><h2 id="1、积极使用搜索工具"><a href="#1、积极使用搜索工具" class="headerlink" title="1、积极使用搜索工具"></a>1、积极使用搜索工具</h2><p>作为开发人员，你需要了解如何利用搜索解惑，查看其他人对你正在研究的主题所讨论的话题和内容，并将学到的知识应用于手头的项目。</p><p>当面临一个问题，优秀的程序员应该知道如何花很少时间去查验和解决手头的问题。</p><h2 id="2、保持初学者心态"><a href="#2、保持初学者心态" class="headerlink" title="2、保持初学者心态"></a>2、保持初学者心态</h2><p>技术发展如此之快，需要不断地学习新技术。 因此，当没有经验的时候，你需要适当地用新的视角看待事情。优秀的开发人员享受作为新技术的初学者的过程，并掌握自我教育的节奏，以尽快自给自足。</p><p>每个专家在某个时间点都可能是一个初学者。 而且有这么多的技术，即使在某个技术领域是专家，在另一个可能就是菜鸟。</p><h2 id="3、将小事做好"><a href="#3、将小事做好" class="headerlink" title="3、将小事做好"></a>3、将小事做好</h2><p>当编写程序时，它通常会让你觉得需要做出十亿个决定，即使你只是添加一个小功能。 你需要考虑诸如命名变量、调用函数、命名CSS属性、使用hash与使用数组、命名事物等等。</p><p>为你干的事情做好命名是编程中一个重要的部分。 这不容易， 但很重要。有开发人员还开玩笑说，在计算机科学领域有两个难题：缓存无效+命名。</p><p>新程序员通常不会对变量和函数命名足够重视， 普通程序员会花更多的时间去思考它，而优秀的程序员已经通过之前遇到错误和问题学到了经验。 他们找到了来帮助他们命名变量的模式，他们甚至不需要再去考虑它，因为一直沿用相同的方式命名就好。</p><h2 id="4、收放自如"><a href="#4、收放自如" class="headerlink" title="4、收放自如"></a>4、收放自如</h2><p>在构建应用程序的过程中，往往需要做出重大决策，这将影响你如何编写大多数代码。例如，在ruby中，你可能需要权衡MiniTest和RSpec之间的区别。 人们对于这些类型都有着强烈的自我意见和看法，因此容易引起争执。 但是优秀的开发人员想法不同，往往不太在意这些，他们重视编写、测试的习惯，他们知道你使用的具体工具其实不那么重要。</p><p>优秀的程序员往往不参与其他开发者的相互争执和指责中，他们更收放自如。</p><h2 id="5、使用正确的工具"><a href="#5、使用正确的工具" class="headerlink" title="5、使用正确的工具"></a>5、使用正确的工具</h2><p>在编程中，有许多不同的开源库、工具和框架可供使用。 优秀的程序员不断地评估他们正在使用的工具，并找出为工作选择正确工具的方法。 由于他们习惯自给自足，他们愿意承受学习新东西的痛苦，只要它们能帮其提升效率。</p><p>有很多的开发人员喜欢去搜索和查看相关的文档、博客文章来比较工具，并最终选择一个单一的工具。但优秀的开发人员会将他们的研究缩小到2-3个选项，并迅速将这些工具应用到他们的项目，以了解它们是如何在他们的环境中工作的。</p><h2 id="6、理解“code-is-cheap”"><a href="#6、理解“code-is-cheap”" class="headerlink" title="6、理解“code is cheap”"></a>6、理解“code is cheap”</h2><p>优秀的程序员往往可以产生更多的产出，因为他们不会被沉没成本误导。这些东西很容易导致人们做出不合理的行为，特别是在编写代码的时候……</p><p>在编码中，沉没成本的误导涉及到花费在解决某个问题上的时间。例如，考虑一个场景，其中某人开始为项目编写代码，并预计需要大约一个星期。他们根据这个预期做出决定，在完成项目一整个星期后，他们意识到它实际上需要一个月。大多数开发人员将继续他们已经开始的路径走下去，证明他们的决定，并展示已经做了一个星期的进展来进行说服自己。</p><p>但是优秀的开发者思考方向不同：</p><p>“有一种其它的方法，我认为只需要半个月就能搞定。这意味着如果采取这种方法，它将可能比我保持现在的路径一直走到底要快两倍。”</p><h2 id="7、使用正确的技术"><a href="#7、使用正确的技术" class="headerlink" title="7、使用正确的技术"></a>7、使用正确的技术</h2><p>一群人在屋里评估技术，然后忽略掉一个在特定技术里的大拿这种情况并不罕见。</p><p>例如，我非常有声望，我对 Elixir 编程语言很是看好。但是这项技术很新，如果想要实际构建复杂的功能，可能会相对其它更难找到相应的开源技术，这将提升团队构建的难度。</p><p>解决问题需要最实际的决定，使用的技术应该是基于它能够很容易在2016年，在目前实现。在2017年、2018年、2020年，技术可能会有所不同，那时候再根据需要进行调整。</p><h2 id="8、不知道就说“不知道”"><a href="#8、不知道就说“不知道”" class="headerlink" title="8、不知道就说“不知道”"></a>8、不知道就说“不知道”</h2><p>拒绝承认你不知道的东西是很容易导致浪费你时间的事情。 作为一个优秀的程序员，你要明白你的自我价值并不受那些你不懂的东西束缚。</p><p>初学者经常难以发现最新技术的发展趋势，优秀的开发者会意识到，他们所知道的每一种技术（编程语言，框架，库等）都可能不再是明天的可行选择。 他们会提前考虑更高级别的编程方式和问题解决方式。</p><h2 id="9、始终分析错误消息中提示的线索"><a href="#9、始终分析错误消息中提示的线索" class="headerlink" title="9、始终分析错误消息中提示的线索"></a>9、始终分析错误消息中提示的线索</h2><p>传统教育告诉我们，失败是不可取的。当学习代码时，错误消息通常与失败相关联。学习如何排除故障和调试错误消息是一个重要的技能。</p><p>还值得注意的是，开发人员可能会再次遇到类似的错误消息。你应该专注于学习如何解决问题，以及为什么你需要解决它们。这样做将允许你以更快的速度修复类似的错误。</p><h2 id="10、不安于目前的成功"><a href="#10、不安于目前的成功" class="headerlink" title="10、不安于目前的成功"></a>10、不安于目前的成功</h2><p>错误往往是最好的学习机会， 所以不要把错误当作失败。 相反，将他们当作可学习的机会，并评估如何防止情况下一次发生。成长的关键是理解如何使同样的错误只有一次。</p><p>编程，就像生活中的许多事情一样。这就是为什么这么多的行为，能帮助你做好一名优秀的程序员，也能帮你在日常生活中做一个优秀的人。</p><p>参考资料：<a href="http://blog.thefirehoseproject.com/posts/">http://blog.thefirehoseproject.com/posts/</a></p><p>文章转载自: 开源中国社区<a href="/">[http://www.oschina.net]</a></p><p>本文标题：10个习惯助你成为一名优秀的程序员</p><p>本文地址:<a href="https://www.oschina.net/news/79264/10-behaviors-will-make-unstoppable-programmer">https://www.oschina.net/news/79264/10-behaviors-will-make-unstoppable-programmer</a></p>]]></content>
    
    
    <summary type="html">当谈到编程时，很多人应该都有听过10x程序员的说法。 据说一个10x程序员的效率大约是其他程序员的10倍。这是一个有争议的话题，无论你选择相信10x程序员，还是认为这十分可笑，下面的10个习惯可以在一定程度上助你成为一名势不可挡的优秀程序员。</summary>
    
    
    
    <category term="Other" scheme="https://laysan.site/categories/Other/"/>
    
    
    <category term="杂谈" scheme="https://laysan.site/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="程序员" scheme="https://laysan.site/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>提升你的开发效率，10 个 NPM 使用技巧</title>
    <link href="https://laysan.site/2016/11/npm-tips-and-tricks/"/>
    <id>https://laysan.site/2016/11/npm-tips-and-tricks/</id>
    <published>2016-11-21T01:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个项目，常用的一些npm简单命令包含的功能有：初始化一个文件夹(<a href="https://docs.npmjs.com/cli/init">npm init</a>)，下载npm模块(<a href="https://docs.npmjs.com/cli/install">npm install</a>)，创建测试(<a href="https://docs.npmjs.com/cli/test">npm test</a>) 和自定义脚本(<a href="https://docs.npmjs.com/cli/run-script">npm run</a>)。但是，进一步了解一些 npm 的使用技巧可以彻底改变你的日常开发任务。</p><span id="more"></span><p><strong>注:</strong><br> 如果你需要关于初学npm的参考，可以参阅我们的<br><a href="https://www.sitepoint.com/beginners-guide-node-package-manager/">初学者指南</a><br>。如果你对 npm 和 Yarn 之间的差异感到困扰，可以参阅我们发表的文章：<br><a href="https://www.sitepoint.com/yarn-vs-npm/">Yarn vs npm:你需要知道的一切</a></p><h2 id="1-获取帮助"><a href="#1-获取帮助" class="headerlink" title="1. 获取帮助"></a>1. 获取帮助</h2><p><a href="https://docs.npmjs.com/">npm 文档</a> 和 <a href="https://docs.npmjs.com/#cli">CLI 命令行文档</a> 是非常不错地的学习资料，但需要通过浏览器访问，这并不是很方便。因而可以通过命令行快速获取所有可选项：</p><pre><code class="js">npm help</code></pre><p>此外，还能获取特定 npm 命令的使用帮助：</p><pre><code class="js">npm help &lt;command&gt;</code></pre><p>例如：<code>npm help install</code></p><p>另一种方式是通过下面的命令：</p><pre><code class="js">npm &lt;command&gt; -h</code></pre><h2 id="2-npm-命令自动完成"><a href="#2-npm-命令自动完成" class="headerlink" title="2. npm 命令自动完成"></a>2. npm 命令自动完成</h2><p>npm 通过bash提供了命令自动完成功能(包括<a href="https://msdn.microsoft.com/en-us/commandline/wsl/about?f=255&MSPPError=-2147217396"> Bash for Windows 10</a> ):</p><pre><code class="js">npm completion &gt;&gt; ~/.bashrc//or Z shellnpm completion &gt;&gt; ~/.zshrc</code></pre><p>重新加载shell配置文件：</p><pre><code class="js">source ~/.bashrc</code></pre><p>现在，在终端注入 <code>npm ins</code> ，然后按下 <code>tab</code> 键就会出现 <code>install</code> 了，不会再浪费时间去全部输入了。</p><h2 id="3-修复全局模块的权限"><a href="#3-修复全局模块的权限" class="headerlink" title="3.修复全局模块的权限"></a>3.修复全局模块的权限</h2><p>当你试图安装全部模块时，类 Linux 系统可能会抛出权限错误，可以在npm命令之前添加 sudo 来执行，但这是一个较危险的选择。一个更高的解决方式是改变 npm 默认的模块安装目录：</p><pre><code class="js">mkdir ~/.npm-globalnpm config set prefix &#39;~/.npm-global&#39;</code></pre><p>使用适当的文本编辑器将下面的一行添加到 <code>~/.bashrc</code> 或者 <code>~/.zshrc</code> 文件中：</p><pre><code class="js">export PATH=&quot;$HOME/.npm-global/bin:$PATH&quot;</code></pre><p>重新加载配置文件(<code>source ~/.bashrc</code>)，然后重新安装npm到用户所属路径：</p><pre><code class="js">npm install -g npm</code></pre><p>这也会更新npm。</p><h2 id="4-持续更新npm"><a href="#4-持续更新npm" class="headerlink" title="4.持续更新npm"></a>4.持续更新npm</h2><p>你可以通过下面的命令显示npm当前的版本：</p><pre><code class="js">npm -v</code></pre><p>如果有需要，可以通过下面的命令更新npm：</p><pre><code class="js">npm install -g npm</code></pre><p>当 Node 的主版本 released 之后，你也可能需要重新构建 C++ 扩展：</p><pre><code class="js">npm rebuild</code></pre><p>如果你需要管理多个版本的node.js和npm，可以考虑使用 <a href="https://github.com/tj/n">n</a> 或者 <a href="https://github.com/creationix/nvm">nvm</a>。这有一篇关于 nvm 的文章：<a href="https://www.sitepoint.com/quick-tip-multiple-versions-node-nvm/">使用 nvm 安装多版本的Node.js</a></p><h2 id="5-定义默认的-npm-init"><a href="#5-定义默认的-npm-init" class="headerlink" title="5.定义默认的 npm init"></a>5.定义默认的 npm init</h2><p>使用 <code>npm init</code> 初始化一个新的项目，这会提示你关于项目的更多细节，并创建一个 <code>package.json</code> 文件。</p><p>如果你厌倦了每次开始一个新的项目都需要重新输入同样的信息，可以使用 <code>-y</code> 标记表示你能接受 <code>package.json</code> 文件的一堆默认值：</p><pre><code class="js">npm init -y</code></pre><p>或者你可以设置一些语义化的默认值：</p><pre><code class="js">npm config set init.author.name &lt;name&gt;npm config set init.author.email &lt;email&gt;</code></pre><h2 id="6-更精准的模块搜索"><a href="#6-更精准的模块搜索" class="headerlink" title="6.更精准的模块搜索"></a>6.更精准的模块搜索</h2><p>到目前为止，npm上已经有超过350000个模块了，并且每天还在持续增长。尽管有很多非常棒的模块，但是你还是想避免使用一些不受欢迎的、存在bug的或者无人维护的模块。</p><p>在<a href="https://www.npmjs.com/">npmjs</a> 和<a href="https://github.com/">Github</a> 上搜索npm模块是很实用但这还有一些其它选择：</p><h3 id="npms"><a href="#npms" class="headerlink" title="npms"></a>npms</h3><p> <a href="https://npms.io/">npms</a><br> 根据一个基于项目版本、模块下载次数、最新更新日期、提交频率、测试覆盖率、文档、贡献者数量、issues数、star数、forks数和作者在社区的地位的综合测量分数进行模块排名。</p><h3 id="npm-Discover"><a href="#npm-Discover" class="headerlink" title="npm Discover"></a>npm Discover</h3><p> <a href="http://www.npmdiscover.com/">npm Discover</a><br> 定位于快速搜索和其它模块通常一起使用的模块，如<br><a href="https://www.npmjs.com/package/body-parser">body-parser</a><br> 通常和Express一起使用。</p><h3 id="Packages-by-PageRank"><a href="#Packages-by-PageRank" class="headerlink" title="Packages by PageRank"></a>Packages by PageRank</h3><p> <a href="http://anvaka.github.io/npmrank/online/">Packages by PageRank</a><br> 按照模块的谷歌排名进行搜索和排序。</p><h3 id="Curated-npm-Lists"><a href="#Curated-npm-Lists" class="headerlink" title="Curated npm Lists"></a>Curated npm Lists</h3><p> 还一个选择就是利用别人的搜索结果。当需要一个健壮的解决方案时，我经常会参考<br><a href="https://twitter.com/sindresorhus">sindresorhus</a>的<a href="https://github.com/sindresorhus/awesome-nodejs">Awesome Node.js</a>。</p><h2 id="7-管理你的模块"><a href="#7-管理你的模块" class="headerlink" title="7.管理你的模块"></a>7.管理你的模块</h2><p>你已经安装了一些模块，看看都有啥：</p><pre><code class="js">npm list</code></pre><p>(ls、la &amp; ll 可以用作 list 的别名)</p><p>该命令会显示所有模块：(安装的)模块，子模块以及子模块的子模块等。可以限制输出的模块层级：</p><pre><code class="js">npm list --depth=0</code></pre><p>打开一个模块的主页：</p><pre><code class="js">npm home &lt;package&gt;</code></pre><p>这只有在你的系统能打开浏览器时有用–在服务端的系统上会失败。同样，可以打开一个模块的 Github 仓库：</p><pre><code class="js">npm repo &lt;package&gt;</code></pre><p>或者它的文档：</p><pre><code class="js">npm docs &lt;package&gt;</code></pre><p>或者它目前的bugs列表：</p><pre><code class="js">npm bugs &lt;package&gt;</code></pre><p>npm list 会显示和你已经安装地模块的关联模块—这些没有在 package.json文件中被引用。你可以单独 npm uninstall 每一个模块或者全部移除它们：</p><pre><code class="js">npm prune</code></pre><p>如果安装模块时你添加了 <code>--production</code> 标记或者 <code>NODE_ENV</code> 被设置成 <code>productio</code>n，package.json 文件中被指定为 <code>devDependencies</code> 的模块也会被移除。</p><h2 id="8-锁定依赖"><a href="#8-锁定依赖" class="headerlink" title="8.锁定依赖"></a>8.锁定依赖</h2><p>默认情况下，当用 –save/-S 或者 –save-dev/-D 安装一个模块时，npm 通过脱字符(^)来限定所安装模块的主版本号。例如，当运行 npm update 时， ^1.5.1 允许安装版本号大于 1.5.1 但小于 2.0.0 版本的模块。</p><p>波浪号(<del>)字符是限定模块的次要版本。例如，当运行 npm update 时， ~1.5.1 允许安装版本号大于 1.5.1但小于 1.6.0 版本的模块。可以将需要安装的模块版本前缀默认设置成波浪号(</del>):</p><pre><code class="js">npm config set save-prefix=&quot;~&quot;</code></pre><p>对于那些偏执的认为任何更新(模块的行为)会破坏系统的人，可以配置npm仅安装精确版本号的模块：</p><pre><code class="js">npm config set save-exact true</code></pre><p>另一个选择是，可以在项目中使用 shrinkwrap:</p><pre><code class="js">npm shrinkwrap</code></pre><p>这会生成一个 shrinkwrap.json 文件，该文件包含了你正在使用的模块的指定版本。当运行 npm install时，该文件所指定的模块版本会覆盖 package.json 文件中所指定的版本。</p><h2 id="9-找出过时的模块"><a href="#9-找出过时的模块" class="headerlink" title="9. 找出过时的模块"></a>9. 找出过时的模块</h2><p>怎么知道一个模块已经更新了呢？我之前的方式是先列举出项目所依赖的模块(npm list –depth=0)，然后在 npmjs.com 上找到该模块，手动检查该模块的版本是否已经更新。这非常费时。幸运的是，有一个更简单的方式：</p><pre><code class="js">npm outdated</code></pre><p>或者 npm outdated -g 来查找全局模块。</p><p>你也可以查看一个独立模块的当前版本：</p><pre><code class="js">npm list &lt;package&gt;</code></pre><p>也可以查看检验当前和历史版本：</p><pre><code class="js">npm view &lt;package&gt; versions</code></pre><p><code>npm view &lt;package&gt;</code> 会显示一个独立模块的所有信息，包括它的依赖、关键字、更新日期、贡献者、仓库地址和许可证等。</p><h2 id="10-使用开发中的模块"><a href="#10-使用开发中的模块" class="headerlink" title="10.使用开发中的模块"></a>10.使用开发中的模块</h2><p>当你正在开发一个模块时，会经常想在其它项目中尝试使用或者在任何一个目录运行它(如果你的应用支持)，这时没必要将其发布到 npm，并全局安装—仅需在该模块所在目录使用下面的命令：</p><pre><code class="js">npn link</code></pre><p>该命令会为模块在全局目录下创建一个符号链接。可以通过下面的命令查看模块引用：</p><pre><code class="js">npm list -g --depth=0</code></pre><p>或者：</p><pre><code class="js">npm outdated -g</code></pre><p>现在，就可以从命令行运行模块或者通过 require 在任何项目中引入该模块。</p><p>另一个选择是，可以通过文件路径在 package.json 文件中声明对该模块的依赖：</p><pre><code class="js">&quot;dependencies&quot;: &#123;  &quot;myproject&quot;: &quot;file:../myproject/&quot;&#125;</code></pre><p>原文：[10 Tips and Tricks That Will Make You an npm Ninja](<a href="http://0.0.0.10/">http://10</a> Tips and Tricks That Will Make You an npm Ninja)</p><p>编译：<a href="https://github.com/dwqs/blog/issues/40?hmsr=">10个 NPM 使用技巧</a><br>译者：<a href="https://github.com/dwqs">dwqs</a></p><p>文章转载自: 开源中国社区<a href="/">[http://www.oschina.net]</a></p><p>本文标题：提升你的开发效率，10 个 NPM 使用技巧</p><p>本文地址:<a href="https://www.oschina.net/news/79226/10-tips-and-tricks-that-will-make-you-an-npm-ninja">https://www.oschina.net/news/79226/10-tips-and-tricks-that-will-make-you-an-npm-ninja</a></p>]]></content>
    
    
    <summary type="html">对于一个项目，常用的一些npm简单命令包含的功能有：初始化一个文件夹( npm init )，下载npm模块( npm install )，创建测试( npm test ) 和自定义脚本( npm run )。但是，进一步了解一些 npm 的使用技巧可以彻底改变你的日常开发任务。</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="Web" scheme="https://laysan.site/tags/Web/"/>
    
    <category term="npm" scheme="https://laysan.site/tags/npm/"/>
    
    <category term="npmjs" scheme="https://laysan.site/tags/npmjs/"/>
    
  </entry>
  
  <entry>
    <title>Redux教程3：添加倒计时</title>
    <link href="https://laysan.site/2016/11/redux-learn-03/"/>
    <id>https://laysan.site/2016/11/redux-learn-03/</id>
    <published>2016-11-14T06:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面的教程里面，我们搭建了一个简单红绿灯示例，通过在console输出当面的倒计时时间；由于界面上不能显示倒计时，用户体验并不良好，本节我们就添加一个简单的倒计时改善一下。</p><p>作为本系列的最后一篇文章，将示例如何处理多个Redux、React的情形；</p><span id="more"></span><h2 id="1、创建Counter类"><a href="#1、创建Counter类" class="headerlink" title="1、创建Counter类"></a>1、创建Counter类</h2><p>我们定义倒计时的类名为 <em>Counter</em> ，创建所需要的文件（夹）：</p><pre><code class="js">mkdir actions/counter reducers/counter stores/counter components/counter views/countertouch constants/Counter.js actions/counter/index.js reducers/counter/index.js stores/counter/index.js components/counter/index.js components/counter/redux.js components/counter/index.less  components/counter/demo.js views/counter/index.hbs</code></pre><p>创建 <em>Counter</em> 的 Redux 和 React 组件的过程就相当于重复了一下之前两篇文章的过程，代码也不复杂，我这边也就不粘贴了。可自行参考代码，代码托管在 <a href="https://github.com/boycgit/demos/tree/master/traffic">https://github.com/boycgit/demos/tree/master/traffic</a> </p><p>可以通过 <a href="http://localhost:3000/counter/redux">http://localhost:3000/counter/redux</a> 检验是否正常运行；</p><p><a href="https://gw.alicdn.com/tps/TB1iUuTKVXXXXXyXXXXXXXXXXXX-248-316.gif"><img data-src="https://gw.alicdn.com/tps/TB1iUuTKVXXXXXyXXXXXXXXXXXX-248-316.gif" alt="预览效果" title="gif"></a></p><p>（这个是gif图，如果没动画请点击在新窗口打开）</p><p>在假设用户已经编写上面的代码文件的基础上，我们继续讲解如何将 <em>Counter</em> 和 <em>Light</em> 两个组件联合起来。</p><h2 id="2、创建入口文件"><a href="#2、创建入口文件" class="headerlink" title="2、创建入口文件"></a>2、创建入口文件</h2><p>Redux的三个原则之一 ： <em>单一store，单一reducer</em> 。我们创建两个文件，分别整合之前所写的 reducer 和 store 。</p><h3 id="2-1、reducer入口文件"><a href="#2-1、reducer入口文件" class="headerlink" title="2.1、reducer入口文件"></a>2.1、reducer入口文件</h3><p>创建<code>reducers/traffic.js</code>文件，作为 <em>主reducer</em> 入口文件：</p><pre><code class="js">import &#123; combineReducers &#125; from &#39;redux&#39;import light from &#39;./light/&#39;import count from &#39;./counter/&#39;const rootReducer = combineReducers(&#123;    light,    count&#125;);export default rootReducer</code></pre><p>这里包含了最佳实践法则， <em>将不同的状态转移关系写进不同的js文件，最后汇总到 index.js 中（这里名为traffic.js，地位是一样的）</em> ，比如后期如果多出一种 “汽车的状态转移” 关系，只要新建对应的js文件，然后再在index.js中的<code>combineReducers</code>函数中多添加一行配置即可；</p><blockquote><p>详细的概念及作用请参考Redux的中文文档<a href="http://camsong.github.io/redux-in-chinese/docs/basics/Reducers.html">Reducer</a></p></blockquote><h3 id="2-2、store入口文件"><a href="#2-2、store入口文件" class="headerlink" title="2.2、store入口文件"></a>2.2、store入口文件</h3><p>创建<code>stores/traffic.js</code>文件，作为 <em>主store</em> 入口文件：</p><pre><code class="js">import &#123; createStore &#125; from &#39;redux&#39;import rootReducer from &#39;../reducers/traffic&#39;export default function trafficStore(initState)&#123;    return createStore(rootReducer,initState);&#125;</code></pre><p>可以看到并没有什么工作量，只是多了几行代码而已；</p><h2 id="3、创建应用"><a href="#3、创建应用" class="headerlink" title="3、创建应用"></a>3、创建应用</h2><p>前面创建的 <em>Counter</em> 和 <em>Light</em> 算是组件，将两者结合起来，可以视作一款小应用了（假设应用名为<code>traffic</code>）；</p><p>为了方便管理，专门创建 <em>App</em> 文件夹来存放应用，并创建应用相关的等辅助内容（比如视图等）：</p><pre><code class="js">mkdir app app/traffic views/apptouch app/traffic/index.js app/traffic/index.less views/app/index.hbs views/app/traffic.hbs</code></pre><p>核心是 <em>app/traffic/index.js</em> 文件，其余文件只是其辅助作用，这边也不重点讲解，可自行到git clone后查看；</p><h3 id="3-1、初始化"><a href="#3-1、初始化" class="headerlink" title="3.1、初始化"></a>3.1、初始化</h3><p>在 <em>app/traffic/index.js</em> 中引入 <em>Counter</em> 和 <em>Light</em> 组件并设置初始化值：</p><pre><code class="js">import React, &#123;Component, PropTypes&#125; from &#39;react&#39;import &#123;render&#125; from &#39;react-dom&#39;import &#123; Provider, connect &#125; from &#39;react-redux&#39;import &#123; bindActionCreators &#125; from &#39;redux&#39;import * as LightActions from &#39;../../actions/light/&#39;import * as CounterActions from &#39;../../actions/counter/&#39;import Light from &#39;../../components/light/&#39;import Counter from &#39;../../components/counter/&#39;import trafficStore from &#39;../../stores/traffic&#39;// 初始化状态let initLight = &#123;    light:&#123;        color:&#39;green&#39;,        time:&#39;5&#39;    &#125;&#125;let initCount = &#123;    count:&#123;        num : parseInt(initLight.light.time)    &#125;&#125;let initState = Object.assign(&#123;&#125;,initLight,initCount);// 声明storelet store = trafficStore(initState);</code></pre><ul><li>  初始化的时候，我们从绿灯开始；</li><li>  倒计时的时间来自于 <em>initLight.light.time</em> ，这样在初始化状态的时候关联起来两个组件</li><li>  将两个组件的状态（initLight,initCount）合并成 <em>initState</em> ，传给应用的 store，以完成 <em>应用store的初始化</em></li></ul><h3 id="3-2、创建React组件，并链接到Redux"><a href="#3-2、创建React组件，并链接到Redux" class="headerlink" title="3.2、创建React组件，并链接到Redux"></a>3.2、创建React组件，并链接到Redux</h3><p>紧接着，使用 <em>connect</em> 方法链接 Redux 和 React组件：</p><pre><code class="js">class App extends Component&#123;    // 占位&#125;// 声明 connect 连接// 将 redux 中的 state传给 Appfunction mapStateToProps(state)&#123;    return&#123;        light:state.light,        count:state.count    &#125;&#125;// 绑定多个actionsfunction mapDispatchToProps(dispatch)&#123;    let boundLight = bindActionCreators(LightActions,dispatch);    let boundCount = bindActionCreators(CounterActions,dispatch);    return&#123;        actions : Object.assign(&#123;&#125;,boundLight,boundCount)    &#125;&#125;// 声明 connect 连接App = connect(mapStateToProps,mapDispatchToProps)(App);// 真正的连接render(    &lt;Provider store=&#123;store&#125;&gt;        &lt;App /&gt;    &lt;/Provider&gt;,    document.getElementById(&#39;demo&#39;))</code></pre><p>形式和上篇提到的类似，细节略微有些不同：</p><ul><li>   <em>mapStateToProps</em> 中返回的对象有两个属性 <em>light</em> 和 <em>count</em> ，在React组件中 对应 this.props.light 、 this.props.count</li><li>   <em>mapDispatchToProps</em> 中现将两个组件的方法先和<code>dispatch</code>绑定，合成一个对象之后再赋值，这样在React组件中使用 <em>this.props.actions</em> 可以调用这两个组件的所有的actions创造函数；</li><li>  最后使用<code>&amp;lt;Provider&amp;gt;</code>注入 store 实例；</li></ul><h3 id="3-3、完善App组件内容"><a href="#3-3、完善App组件内容" class="headerlink" title="3.3、完善App组件内容"></a>3.3、完善App组件内容</h3><p>最后，绑定store之后完善 <em>App类</em> 的代码，大部分的逻辑和前一篇的类似：</p><pre><code class="js">class App extends Component&#123;    _bind(...methods)&#123;        methods.forEach((method)=&gt;this[method] = this[method].bind(this));    &#125;    constructor()&#123;        super();        this._bind(&#39;changeColor&#39;,&#39;handleClick&#39;,&#39;autoChange&#39;);        this.state = &#123;            timeId : null        &#125;    &#125;    changeColor(light,actions)&#123; // 红路灯变换规则        switch(light.color)&#123;            case &#39;red&#39;:                actions.changeGreen();                break;            case &#39;green&#39;:                actions.changeYellow();                break;            case &#39;yellow&#39;:                actions.changeRed();                break;            default:                actions.changeRed();        &#125;           &#125;    autoChange()&#123; // 自动更改红绿灯        const &#123; light,count, actions &#125; = this.props;        let _self = this;        actions.countDown();        let curState = store.getState();        if(curState.count.num &lt; 1)&#123;            this.changeColor(light,actions);            curState = store.getState();            actions.countInit(parseInt(curState.light.time));        &#125;        // 自动更改        this.state.timeId = setTimeout(function()&#123;            _self.autoChange();        &#125;,1000);    &#125;    handleClick(e)&#123;  // 用点击模拟红路灯        if(this.state.timeId)&#123;            clearTimeout(this.state.timeId);            this.state.timeId = null;        &#125; else &#123;            this.autoChange();        &#125;    &#125;    render()&#123;        // 通过connect 注入 redux 的 dispatch 方法        const &#123; light,count, actions &#125; = this.props;        return (            &lt;div id=&quot;traffic&quot; onClick=&#123;this.handleClick&#125;&gt;                &lt;Light light=&#123;light&#125;/&gt;                &lt;Counter num=&#123;count.num&#125;/&gt;            &lt;/div&gt;        )    &#125;&#125;// 声明 connect 连接</code></pre><p>变换的逻辑都在 <em>autoChange</em> 方法中</p><ul><li>  使用 <em>actions.countDown();</em> 让倒计时减1，通过 <em>store.getState();</em> 获取更新后的状态，因为如果直接使用 <em>count.num</em> 获取的是 <em>更新之前</em> 的状态；</li><li>  当 <em>curState.count.num</em> 小于 0 的时候，调用 <em>this.changeColor(light,actions);</em> 更改红绿等的颜色，同时将 新的红绿灯的time值初始化 Counter 组件，这样就完成了两者的绑定</li></ul><h3 id="3-4、预览效果"><a href="#3-4、预览效果" class="headerlink" title="3.4、预览效果"></a>3.4、预览效果</h3><p>在 <a href="http://localhost:3000/app/traffic">http://localhost:3000/app/traffic</a> 中查看效果，效果正如此系列文章第一篇开头所展示的那样，红绿灯搭配倒计时运行：</p><p><a href="https://gw.alicdn.com/tps/TB1HYmUKVXXXXXhXXXXXXXXXXXX-224-316.gif"><img data-src="https://gw.alicdn.com/tps/TB1HYmUKVXXXXXhXXXXXXXXXXXX-224-316.gif" alt="预览效果" title="result"></a></p><p>（这个是gif图，如果没动画请点击在新窗口打开）</p><p>红绿灯初始状态是 <em>绿灯5s</em> ，继而循环 <em>黄灯3s</em> -&gt; <em>红灯7s</em> -&gt; <em>绿灯5s</em> -&gt; <em>黄灯3s</em> -&gt; …</p><p>就这样， <em>Counter</em> 和 <em>Light</em> 融洽地结合起来，完美，happy ending~</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>到这里，Redux 的入门教程算是完结；整个过程下来，你可以体会得到，React只需要关注逐渐的展示就行了，所有状态的管理交由<code>redux</code>即可，这种绑定恰好体现了<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">容器组件和展示组件相分离</a>的开发思想： <em>只在最顶层组件（如路由操作）里使用 Redux；内部组件应该像木偶一样保持“呆滞”，所有数据都通过 props 传入</em> 。</p><p>这里需要再强调一下：Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面的教程里面，我们搭建了一个简单红绿灯示例，通过在console输出当面的倒计时时间；由于界面上不能显示倒计时，用户体验并不良好，本节我们就添加一个简单的倒计时改善一下。&lt;/p&gt;
&lt;p&gt;作为本系列的最后一篇文章，将示例如何处理多个Redux、React的情形；&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="React" scheme="https://laysan.site/tags/React/"/>
    
    <category term="Redux" scheme="https://laysan.site/tags/Redux/"/>
    
    <category term="Web" scheme="https://laysan.site/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Redux教程2：链接React</title>
    <link href="https://laysan.site/2016/11/redux-learn-02/"/>
    <id>https://laysan.site/2016/11/redux-learn-02/</id>
    <published>2016-11-14T01:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面的教程，我们有了简单的环境，并且可以运行<code>Redux</code>的程序，也对 <em>如何编写Redux示例</em> 有了初步的印象；</p><p>掌握了 <em>使用Redux控制状态转移</em> ，继而驱动 <em>React</em> 组件发生改变，这才是学习Redux的初衷。</p><p>本篇我们将 Redux 和 React 联合起来，着重讲解<code>redux-react</code>模块的使用；</p><span id="more"></span><h2 id="1、编写红绿灯React组件"><a href="#1、编写红绿灯React组件" class="headerlink" title="1、编写红绿灯React组件"></a>1、编写红绿灯React组件</h2><p>在原有的基础上，我们编写红绿灯组件：</p><pre><code>touch components/light/index.js components/light/index.less</code></pre><p>在 <em>components/light/index.js</em> 中写React代码，其结构非常简单：</p><pre><code class="js">import React, &#123; PropTypes, Component &#125; from &#39;react&#39;import &#123; render &#125; from &#39;react-dom&#39;import classnames from &#39;classnames&#39;import &#39;./index.less&#39;class Light extends Component&#123;    render()&#123;        let color = this.props.light.color;        return(            &lt;div className=&quot;traffic-light&quot;&gt;                &lt;span className=&#123;classnames(&#39;light&#39;,color)&#125; /&gt;            &lt;/div&gt;        )    &#125;&#125;Light.propTypes = &#123;    light: PropTypes.object.isRequired&#125;Light.defaultProps = &#123;    light : &#123;color:&#39;red&#39;,time:&#39;4&#39;&#125;&#125;export default Light</code></pre><p>根据更改样式类名（’red’、’green’、’yellow’），从而移动 <em>sprite图</em> 产生灯变换的效果：</p><pre><code class="css">.traffic-light&#123;  .light&#123;    display: inline-block;    background: url(//lh3.googleusercontent.com/-YWLqWZXDYHU/VmWC7GHoAuI/AAAAAAAACgk/nXvEmSWAhQU/s800/light.png) no-repeat 0 0;    background-size: auto 100%;    overflow: hidden;    width:140px / 2;    height:328px / 2;    &amp;.red&#123;      background-position: 0,0;    &#125;    &amp;.yellow&#123;      background-position: -78px , 0;    &#125;    &amp;.green&#123;      background-position: -156px , 0;    &#125;  &#125;&#125;</code></pre><p>修改 <em>components/light/demo.js</em> 文件代码为：</p><pre><code class="js">import React, &#123;Component, PropTypes&#125; from &#39;react&#39;import &#123;render&#125; from &#39;react-dom&#39;import Light from &#39;./index&#39;var color = &#39;red&#39;;render(    &lt;div id=&quot;traffic&quot;&gt;        &lt;Light color=&#123;color&#125;/&gt;    &lt;/div&gt;,    document.getElementById(&#39;demo&#39;))</code></pre><p>这样就能通过 <a href="http://localhost:3000/light/demo">http://localhost:3000/light/demo</a> 预览这个组件了；</p><p><a href="https://gw.alicdn.com/tps/TB1Ca9FKVXXXXXQXFXXXXXXXXXX-252-245.jpg"><img data-src="https://gw.alicdn.com/tps/TB1Ca9FKVXXXXXQXFXXXXXXXXXX-252-245.jpg" alt="demo light" title="demo light"></a></p><h2 id="2、链接React和redux"><a href="#2、链接React和redux" class="headerlink" title="2、链接React和redux"></a>2、链接React和redux</h2><p>有了React和之前的Redux，现在就要将两者链接起来了。我们的目标是让红绿灯运行起来，就好比平时在十字路口看到的那样；</p><h3 id="2-1、创建示例文件"><a href="#2-1、创建示例文件" class="headerlink" title="2.1、创建示例文件"></a>2.1、创建示例文件</h3><p>再创建一个示例文件，就不叫demo了，叫做<code>redux</code>好了：</p><pre><code class="js">touch components/light/redux.js</code></pre><blockquote><p>之所以示例文件名称为<code>demo.js</code>或<code>redux.js</code>，是因为我在 <em>webpack.config.js</em> 中配置了，如果想用其他的文件名，只要依样画葫芦就可以；</p></blockquote><p>首先在 <em>components/light/redux.js</em> 中输入最基本的脚手架代码，引入所需要的组件或模块：</p><pre><code class="js">import React, &#123;Component, PropTypes&#125; from &#39;react&#39;import &#123;render&#125; from &#39;react-dom&#39;import &#123; Provider, connect &#125; from &#39;react-redux&#39;import &#123; bindActionCreators &#125; from &#39;redux&#39;import * as LightActions from &#39;../../actions/light/&#39;import lightStore from &#39;../../stores/light/&#39;import Light from &#39;./index&#39;// 声明storelet store = lightStore();</code></pre><h3 id="2-2、创建容器React"><a href="#2-2、创建容器React" class="headerlink" title="2.2、创建容器React"></a>2.2、创建容器React</h3><p>继而创建一个 <em>App React类</em> ，作为总的容器，将上述的 <em>Light</em> 组件放入其中：</p><pre><code class="js">import React, &#123;Component, PropTypes&#125; from &#39;react&#39;import &#123;render&#125; from &#39;react-dom&#39;import &#123; Provider, connect &#125; from &#39;react-redux&#39;import &#123; bindActionCreators &#125; from &#39;redux&#39;import * as LightActions from &#39;../../actions/light/&#39;import lightStore from &#39;../../stores/light/&#39;import Light from &#39;./index&#39;// 声明storelet store = lightStore();class App extends Component&#123;    _bind(...methods)&#123;        methods.forEach((method)=&gt;this[method] = this[method].bind(this));    &#125;    constructor()&#123;        super();        this._bind(&#39;autoChange&#39;,&#39;handleClick&#39;);        this.state = &#123;            count : 0,            timeId : null        &#125;    &#125;    autoChange()&#123; // 自动更改红绿灯        var _self = this;        // 这里放置逻辑代码        this.state.timeId = setTimeout(function()&#123;            // 递归调用，实现 setInterval 方法            _self.autoChange();        &#125;,1000);    &#125;    handleClick(e)&#123;  // 用点击模拟红路灯        if(this.state.timeId)&#123;            clearTimeout(this.state.timeId);            this.state.timeId = null;        &#125; else &#123;            this.autoChange();        &#125;    &#125;    render()&#123;        // 通过connect 注入 redux 的 dispatch 方法        return (            &lt;div id=&quot;traffic&quot; onClick=&#123;this.handleClick&#125;&gt;                &lt;Light light=&#123;&#39;yellow&#39;&#125;/&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre><p>上面的代码还是个半成品，看不到效果；简单描述一下上面的代码做了什么：</p><ul><li>  定义<code>App</code>容器，将 <em>Light</em> 组件放在其<code>render</code>方法中</li><li>   <em>constructor</em> 方法引用了 <em>_bind</em> 方法，方便一次性绑定<code>this</code>上下文，该方法来自文章<a href="http://www.newmediacampaigns.com/blog/refactoring-react-components-to-es6-classes">Refactoring React Components to ES6 Classes</a></li><li>   <em>handleClick</em> 方法是纯粹是为了演示，当用户点击红绿灯的时候，红绿灯调用 <em>autoChange方法</em> 开始自动变换，用户再次点击的时候就停止变换；</li><li>   <em>autoChange</em> 方法用于红绿灯状态自动转换的，这里占位；本质是使用<code>setTimeout</code>代替<code>setInterval</code>实现；</li></ul><h3 id="2-3、链接React组件和Redux类"><a href="#2-3、链接React组件和Redux类" class="headerlink" title="2.3、链接React组件和Redux类"></a>2.3、链接React组件和Redux类</h3><p>这是最为关键的一个步骤，</p><pre><code class="js">class App extends Component&#123;    ...&#125;// 声明 connect 连接// 将 redux 中的 state传给 Appfunction mapStateToProps(state)&#123;    return&#123;        light:state    &#125;&#125;function mapDispatchToProps(dispatch)&#123;    return&#123;        actions : bindActionCreators(LightActions,dispatch)    &#125;&#125;// 声明 connect 连接App = connect(mapStateToProps,mapDispatchToProps)(App);// 真正的连接render(    &lt;Provider store=&#123;store&#125;&gt;        &lt;App /&gt;    &lt;/Provider&gt;,    document.getElementById(&#39;demo&#39;))</code></pre><p>这里使用 <em>react-redux</em> 提供<code>connect</code>的方法 <em>链接React组件和Redux类</em> ：</p><pre><code class="js">// 声明 connect 连接App = connect(mapStateToProps,mapDispatchToProps)(App);</code></pre><ul><li>   <em>connect</em> 方法不会改变原来的组件类，反而返回一个新的 <em>已与 Redux store 连接的</em> 组件类。注意这里并没有注入<code>store</code>对象，真正<code>store</code>对象的注入靠最后的<code>&lt;Provider store&gt;</code>组件；（更多说明请参考 [react-redux 的 API][1]）</li><li>  传入 <em>connect</em> 的 <em>mapStateToProps方法</em> ，正如其名，是将 Redux 的状态 映射到 React组件的props属性。任何时候，<strong>只要 Redux store 发生改变，mapStateToProps 函数就会被调用</strong>。这里返回对象是<code>&#123;light:state&#125;</code>，这样确保 Redux 中的 state 发生改变时，组件的 props.light 都是最新的 Redux state。</li><li>   <em>mapDispatchToProps方法</em> 则是将 Store 中的 dispatch方法 直接封装成对象的一个属性，一般会用到 Redux 的辅助函数<a href="http://camsong.github.io/redux-in-chinese/docs/api/bindActionCreators.html">bindActionCreators()</a>；这里将<code>dispatch</code>绑定到<code>action</code>属性，这样在红绿灯组件内让其变成红灯的时候，不需要<code>dispatch(changeRed())</code>这么调用，直接使用<code>actions.changeRed()</code>，语义化更好；（更多说明请参考 [react-redux 的 API][1]）</li><li>  最后的<code>&lt;Provider store&gt;</code>使组件层级中的 <em>connect()</em> 方法都能够获得 <em>Redux store</em> ，这里才真正注入<code>store</code>变量，之前的只是声明而已（之前的好比store是个形参，到了这一步store就是实参了）。（更多说明请参考 [react-redux 的 API][1]）</li></ul><p>经过上面的语句，Redux就将 <em>state属性</em> 、 （<strong>store</strong> 的）<code>dispatch方法</code>与 React 组件的 <em>props</em> 绑定在一起，凡是更改 <em>redux</em> 的 states，就会更新所连接组件的<code>props</code>属性。</p><blockquote><p> <em>react-redux</em> 中的 <em>connect</em> 方法就算是HOC（High Order Component，高阶组件）了，具体原理可参考文章<a href="http://leozdgao.me/chushi-hoc/">初识React中的High Order Component</a>，这是因为如果使用ES6 写React组件的话，mixin是不支持的，因此使用High Order Component代替；</p></blockquote><h3 id="2-4、利用redux驱动react"><a href="#2-4、利用redux驱动react" class="headerlink" title="2.4、利用redux驱动react"></a>2.4、利用redux驱动react</h3><p>理解了最为困难的部分，之后的事情就水到渠成了；</p><p>现在，只要记住 <em>在App中可以直接使用Redux中的一切了</em> 就行了</p><p>我们回过头来，完善<code>App</code>组件的代码，完善 <em>autoChange</em> 方法：</p><pre><code class="js">class App extends Component&#123;    _bind(...methods)&#123;        methods.forEach((method)=&gt;this[method] = this[method].bind(this));    &#125;    constructor()&#123;        super();        this._bind(&#39;changeColor&#39;,&#39;handleClick&#39;,&#39;autoChange&#39;);        this.state = &#123;            count : 0,            timeId : null        &#125;    &#125;    changeColor(light,actions)&#123; // 红路灯变换规则        switch(light.color)&#123;            case &#39;red&#39;:                actions.changeGreen();                break;            case &#39;green&#39;:                actions.changeYellow();                break;            case &#39;yellow&#39;:                actions.changeRed();                break;            default:                actions.changeRed();        &#125;           &#125;    autoChange()&#123; // 自动更改红绿灯        const &#123; light, actions &#125; = this.props;        let _self = this;        let curCount = ++this.state.count;        // console.log(&#39;xx,&#39;,curCount);        if(this.state.count &gt; +light.time)&#123;            curCount = 0;            this.changeColor(light,actions);        &#125;        // 自动更改        this.state.timeId = setTimeout(function()&#123;            _self.setState(&#123;count:curCount&#125;);            _self.autoChange();        &#125;,1000);    &#125;    handleClick(e)&#123;  // 用点击模拟红路灯        if(this.state.timeId)&#123;            clearTimeout(this.state.timeId);        &#125; else &#123;            this.autoChange();        &#125;    &#125;    render()&#123;        // 通过connect 注入 redux 的 dispatch 方法        const &#123; light, actions &#125; = this.props;        return (            &lt;div id=&quot;traffic&quot; onClick=&#123;this.handleClick.bind(this)&#125;&gt;                &lt;Light light=&#123;light&#125;/&gt;            &lt;/div&gt;        )    &#125;&#125;</code></pre><p>至此已经完成本节示例，通过<code>npm start</code>开启服务， 在 <a href="http://localhost:3000/light/redux">http://localhost:3000/light/redux</a> 中查看。</p><p>在这个示例里，通过点击红绿灯，每隔若干秒红绿灯就会变换颜色，这说明两者已经链接起来；</p><p><a href="https://gw.alicdn.com/tps/TB1uaysKVXXXXXiaXXXXXXXXXXX-320-188.gif"><img data-src="https://gw.alicdn.com/tps/TB1uaysKVXXXXXiaXXXXXXXXXXX-320-188.gif" alt="demo light" title="demo light"></a></p><p>（这个是gif图，如果没动画请点击在新窗口打开）</p><p>在后一篇文章，将示例如何处理多个Redux、React的情形；</p><p>[1]<a href="http://camsong.github.io/redux-in-chinese/docs/react-redux/api.html">http://camsong.github.io/redux-in-chinese/docs/react-redux/api.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过前面的教程，我们有了简单的环境，并且可以运行&lt;code&gt;Redux&lt;/code&gt;的程序，也对 &lt;em&gt;如何编写Redux示例&lt;/em&gt; 有了初步的印象；&lt;/p&gt;
&lt;p&gt;掌握了 &lt;em&gt;使用Redux控制状态转移&lt;/em&gt; ，继而驱动 &lt;em&gt;React&lt;/em&gt; 组件发生改变，这才是学习Redux的初衷。&lt;/p&gt;
&lt;p&gt;本篇我们将 Redux 和 React 联合起来，着重讲解&lt;code&gt;redux-react&lt;/code&gt;模块的使用；&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="React" scheme="https://laysan.site/tags/React/"/>
    
    <category term="Redux" scheme="https://laysan.site/tags/Redux/"/>
    
    <category term="Web" scheme="https://laysan.site/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Redux教程1：环境搭建，初写Redux</title>
    <link href="https://laysan.site/2016/11/redux-learn-01/"/>
    <id>https://laysan.site/2016/11/redux-learn-01/</id>
    <published>2016-11-13T01:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果将React比喻成士兵的话，你的程序还需要一位将军，去管理士兵（的状态），而Redux恰好是一位好将军，简单高效；</p><p>相比起React的学习曲线，Redux的稍微平坦一些；本系列教程，将以“红绿灯”为示例贯穿整个demo，希望能让用户快速理解&amp;学习Redux。</p><span id="more"></span><p>强烈推荐 <a href="http://camsong.github.io/redux-in-chinese/index.html">Redux 中文文档</a>，本redux教程所有的材料和思路都来源于此；</p><p>这个系列拆分成3篇文章，最后获得的效果图为：</p><p><a href="https://gw.alicdn.com/tps/TB1HYmUKVXXXXXhXXXXXXXXXXXX-224-316.gif"><img data-src="https://gw.alicdn.com/tps/TB1HYmUKVXXXXXhXXXXXXXXXXXX-224-316.gif" alt="result" title="result"></a><br>（这个是gif图，如果没动画请点击在新窗口打开）</p><p>红绿灯初始状态是 #绿灯5s#，继而循环 #黄灯3s# -&gt; #红灯7s# -&gt; #绿灯5s# -&gt; #黄灯3s# -&gt; …</p><h2 id="1、Redux简介"><a href="#1、Redux简介" class="headerlink" title="1、Redux简介"></a>1、Redux简介</h2><p>在Redux中，最为核心的概念就是 <code>state</code>、<code>action</code> 、<code>reducer</code> 以及 <code>store</code>，单词大家都懂，就是初学者不知道该怎么用。</p><p>以常见的红路灯为例，将其应用到Redux中：</p><ul><li>  <code>action</code>：就是灯的变化，”红变绿”等，用名词表述</li><li>  <code>state</code>：就是灯的名字，红灯、绿灯等，用名词表述</li><li>  <code>reducer</code>：就是灯的变化规则，红灯之后是绿灯等，用状态转移表述，归根到底也是名词</li><li>  <code>store</code>：就像是交警，执行上述的交通规则；</li></ul><p>简单的说，Redux所想表达的就是这些内容，所以它的学习曲线不会很陡。对于程序员来讲，阅读代码会比阅读文字舒服，那么我们如何简单地用redux实现。</p><h2 id="2、文件夹结构"><a href="#2、文件夹结构" class="headerlink" title="2、文件夹结构"></a>2、文件夹结构</h2><h3 id="2-1、安装依赖"><a href="#2-1、安装依赖" class="headerlink" title="2.1、安装依赖"></a>2.1、安装依赖</h3><p>创建符合redux风格的文件夹结构：</p><pre><code class="js">mkdir actions constants components layouts reducers stores tests viewstouch server.js index.js webpack.config.js</code></pre><p>这些文件夹结构也是借鉴自官网redux的todos示例；</p><p>然后安装依赖：</p><pre><code class="js">npm initnpm install --save koa koa-handlebars koa-router react react-dom react-redux classnamesnpm install --save-dev webpack webpack-dev-server webpack-hot-middleware babel-core babel-loader babel-plugin-react-transform style-loader less-loader css-loader extract-text-webpack-plugin babel-preset-es2015 babel-preset-react</code></pre><p>最终的文件夹结构为：</p><p><a href="https://gw.alicdn.com/tps/TB1lE1DKVXXXXaDXFXXXXXXXXXX-170-352.jpg"><img data-src="https://gw.alicdn.com/tps/TB1lE1DKVXXXXaDXFXXXXXXXXXX-170-352.jpg" alt="file structor" title="file structor"></a></p><h3 id="2-2、配置开发环境"><a href="#2-2、配置开发环境" class="headerlink" title="2.2、配置开发环境"></a>2.2、配置开发环境</h3><p>这里需要启用两个服务器，一个是webpack服务器，专门用于转换代码；另外一个是web应用服务器，响应客户端的请求</p><pre><code class="js">var path = require(&#39;path&#39;);var fs = require(&#39;fs&#39;);var webpack = require(&#39;webpack&#39;);var ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);// 遍历目录var searchDir = [&#39;components&#39;,&#39;app&#39;]; // 需要webpack打包的目录var entry = &#123;&#125;;searchDir.forEach(function(dir)&#123;  var srcBasePath = path.join(__dirname, &#39;./&#39;, dir);  var files = fs.readdirSync(srcBasePath);  var ignore = [&#39;.DS_Store&#39;]; // 忽略某些文件夹  files.map(function (file) &#123;    if (ignore.indexOf(file) &lt; 0) &#123;      entry[dir+&#39;/&#39;+file] = path.join(srcBasePath, file, &#39;index.js&#39;);      var demofile = path.join(srcBasePath, file, &#39;demo.js&#39;);      if(fs.existsSync(demofile))&#123;        entry[dir+&#39;/&#39;+file + &#39;/demo&#39;] = demofile;      &#125;      var reduxfile = path.join(srcBasePath, file, &#39;redux.js&#39;);      if(fs.existsSync(reduxfile))&#123;        entry[dir+&#39;/&#39;+file + &#39;/redux&#39;] = reduxfile;      &#125;    &#125;  &#125;);&#125;);Object.keys(entry).forEach(function (key) &#123;  entry[key] = [entry[key], &#39;webpack-hot-middleware/client&#39;];&#125;);module.exports = &#123;  devtool:&#39;cheap-module-eval-source-map&#39;,  entry :entry,  output:&#123;    path:path.join(__dirname,&#39;dist&#39;),    filename:&#39;[name].js&#39;,    publicPath:&#39;/static/&#39;  &#125;,  plugins:[    new ExtractTextPlugin(&quot;[name]/index.css&quot;),    new webpack.optimize.OccurenceOrderPlugin(),    new webpack.HotModuleReplacementPlugin(),    new webpack.NoErrorsPlugin()  ],  module:&#123;    loaders:[&#123;      test:/\.js$/,      loader:&#39;babel-loader&#39;,      exclude:/node_modules/,      include:__dirname,      query:&#123;        presets: [&#39;es2015&#39;,&#39;react&#39;]      &#125;    &#125;,&#123;      test: /\.less$/,      loader: ExtractTextPlugin.extract(&#39;style-loader&#39;,&#39;css-loader!less-loader&#39;),      exclude: /node_modules/    &#125;]  &#125;&#125;</code></pre><p>注意Babel 6的配置和上一个版本有很大的不同；详见：<a href="http://babeljs.io/blog/2015/10/31/setting-up-babel-6/">Setting up Babel 6</a></p><p>这是webpack配置项，接下来专门起一个nodejs程序提供webpack服务：</p><p><code>server.js</code>：</p><pre><code class="js">var webpack = require(&#39;webpack&#39;);var WebpackDevServer = require(&#39;webpack-dev-server&#39;);var config = require(&#39;./webpack.config&#39;);new WebpackDevServer(webpack(config), &#123;  publicPath: config.output.publicPath,  hot: true,  stats: &#123; colors: true &#125;,  historyApiFallback: true&#125;).listen(3009, &#39;localhost&#39;, function (err, result) &#123;  if (err) &#123;    console.log(err);  &#125;  console.log(&#39;Listening at localhost:3009&#39;);&#125;);</code></pre><p>此webpack服务专门用于整合前端资源，顺带使用babel转换ES6的JS代码；这里的含义就不多说了，可以参考以前的文章 <a href="http://www.atatech.org/articles/37601">Webpack</a>；</p><p>使用koa作为web服务器，因为测试所以比较简单，用了最基本的代码快速搭建：</p><pre><code class="js">var koa = require(&#39;koa&#39;);var router = require(&#39;koa-router&#39;)();var handlebars = require(&quot;koa-handlebars&quot;);var app = koa();var port = 3000;// 使用handlerbars作为模板文件app.use(handlebars(&#123;  defaultLayout: &quot;index&quot;&#125;));// 定义路由router.get(&quot;/&quot;, function *(next) &#123;  yield this.render(&#39;index&#39;,&#123;    title:&#39;Redux示例-交通灯&#39;,    name:&#39;交通灯示例&#39;  &#125;);&#125;);// 定义应用路由router.get(&#39;app&#39;,&#39;/app/:name&#39;,function*(next)&#123;  this.appName = this.params.name || &#39;index&#39;; // 应用名字  yield this.render(&#39;app/&#39;+this.appName,&#123;    title:&#39;应用&#39;,    filename:this.appName  &#125;);&#125;)// 定义demo路由router.get(&#39;demo&#39;,&#39;/:name/:type&#39;, function *(next) &#123;  this.demoName = this.params.name || &#39;demo&#39;; // 获取demo名称  this.demoType = this.params.type; // 获取文件类型，&#39;demo&#39; 或者 &#39;redux&#39;  yield this.render(this.demoName + &#39;/index&#39;,&#123;    title:&#39;示例&#39;,    filename:this.demoType  &#125;);&#125;);// 启用路由app  .use(router.routes())  .use(router.allowedMethods());// 监听端口app.listen(port, function(error) &#123;  if (error) &#123;    console.error(error)  &#125; else &#123;    console.info(&quot;==&gt;   监听端口 %s. 请在浏览器里打开 http://localhost:%s/.&quot;, port, port)  &#125;&#125;)</code></pre><p>好了，在命令行里开启这两个服务吧：</p><pre><code class="js">nodemon server.js &amp; nodemon --harmony index.js</code></pre><p>在package.json中的<code>scripts</code>增加一条配置：<code>&quot;start&quot;: &quot;nodemon server.js &amp; nodemon --harmony index.js&quot;</code>，以后就可以使用 <code>npm start</code> 命令同时启动两个服务了；</p><p>这里使用了<code>nodemon</code>应用程序，方便修改后快速启动，该程序可通过<code>npm install -g nodemon</code>安装</p><h2 id="3、开始Redux吧"><a href="#3、开始Redux吧" class="headerlink" title="3、开始Redux吧"></a>3、开始Redux吧</h2><p>环境搭建好了，我们就依据最开始的设定用redux搭建红绿灯示例。</p><p>先创建所需要的文件：</p><pre><code class="js">mkdir actions/light reducers/light stores/light components/lighttouch constants/TrafficLight.js actions/light/index.js reducers/light/index.js stores/light/index.js components/light/redux.js</code></pre><h3 id="3-1、Actions"><a href="#3-1、Actions" class="headerlink" title="3.1、Actions"></a>3.1、Actions</h3><p>Action 本质是 <em>JavaScript 普通对象</em> action 内必须使用一个 <em>字符串类型</em> 的 <code>type</code> 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p><p>在 <code>constants/TrafficLight.js</code>中定义actions的名称，使用 <code>const</code> 修饰防止被修改：</p><pre><code class="js">export const CHANGE_GREEN = &#39;CHANGE_GREEN&#39;export const CHANGE_YELLOW = &#39;CHANGE_YELLOW&#39;export const CHANGE_RED = &#39;CHANGE_RED&#39;</code></pre><p>然后在 <code>actions/light/index.js</code> 文件，定义 <em>Actions</em> 对象：</p><pre><code class="js">import * as lights from &#39;../../constants/TrafficLight&#39;export function changeGreen()&#123; return &#123;type:lights.CHANGE_GREEN&#125;&#125;export function changeYellow()&#123; return &#123;type:lights.CHANGE_YELLOW&#125;&#125;export function changeRed()&#123; return &#123;type:lights.CHANGE_RED&#125;&#125;</code></pre><p>这里的 <em>{type:lights.CHANGE_GREEN}</em> 等就是Redux的 <em>action对象</em>（就是这么简单….）， 而对应的 <code>changeGreen</code>方法则称为 <em>action创建函数</em> ；</p><p>详细的概念及作用请参考Redux的中文文档 <a href="http://camsong.github.io/redux-in-chinese/docs/basics/Actions.html">Actions</a></p><h3 id="3-2、Reducer"><a href="#3-2、Reducer" class="headerlink" title="3.2、Reducer"></a>3.2、Reducer</h3><p>正所谓“不以规矩，不能方圆”，万物的运作都要符合规律，Reducer 就是描述各状态之间流转的 <em>规律</em>：</p><ul><li>  当红灯时，过n1秒会触发 <code>CHANGE_GREEN</code> 事件，灯编程绿色的</li><li>  当绿灯时，过n2秒会触发 <code>CHANGE_YELLOW</code> 事件，灯编程黄色的</li><li>  当黄灯时，过n3秒会触发 <code>CHANGE_RED</code> 事件，灯编程红色的</li><li>  …周而复始…</li></ul><p>继续在 <code>reducers/light/index.js</code>文件，描述不同等之间的转移：</p><pre><code class="js">import &#123;CHANGE_GREEN, CHANGE_YELLOW, CHANGE_RED&#125; from &#39;../../constants/TrafficLight&#39;// 定义初始化状态，初始化状态是常量// 初始状态是红灯const initState = &#123; color:&#39;red&#39;, time:&#39;7&#39; // 持续时间20ms&#125;// 定义灯转换的reducer函数export default function light(state=initState,action)&#123; switch(action.type)&#123;   case CHANGE_GREEN:     return &#123;       color:&#39;green&#39;,       time:&#39;5&#39;     &#125;   case CHANGE_YELLOW:     return &#123;       color:&#39;yellow&#39;,       time:&#39;3&#39;     &#125;   case CHANGE_RED:     return Object.assign(&#123;&#125;,initState);   default:     return state &#125;&#125;</code></pre><p>这里的<code>switch</code>语句就是典型的用于表述 <em>状态转移</em> 逻辑的代码结构，自己尝试写状态机的同学应该深有体会；</p><h3 id="3-3、Store"><a href="#3-3、Store" class="headerlink" title="3.3、Store"></a>3.3、Store</h3><p>有了交规还不行，得有付诸具体行动的载体 —— 交通信号灯 才行，在 <code>stores/light/index.js</code> ：</p><pre><code class="js">import &#123;createStore&#125; from &#39;redux&#39;import lightReducer from &#39;../../reducers/light/&#39;export default function lightStore(initState)&#123; return createStore(lightReducer,initState); // 初始化创建&#125;</code></pre><p>关键就那句<code>createStore</code>函数，接受 <code>reducer</code>（交通规则）和 <code>initState</code> （初始状态，灯的初始状态是红灯）作为参数；</p><p>这里的 “交通信号灯” 也是一种类别，并不是具体指 “灯” —— 额，希望你能理解我想表述的…</p><p>自此，恭喜你你已经成功实施了 Redux 的必要规范了，接下来我们检验一下是否正如你所愿；</p><p>此节中我们先简单的实施一下，后续文章再补充细节</p><h2 id="4、检查能否运行"><a href="#4、检查能否运行" class="headerlink" title="4、检查能否运行"></a>4、检查能否运行</h2><p>按照上面创建的一系列JS文件，你已经基于 <code>Redux</code> 完成了红绿灯的规则效果，那怎么检验呢？</p><p>来，拿一个红绿灯过来！</p><p>接通电源，给这个灯 <em>发送</em> 事件（类似于dom中的“触发事件”），假设事件的 <code>type</code> 依次是 <strong>CHANGE_GREEN</strong> 、<strong>CHANGE_GREEN</strong>，看看事件结束之后的状态是否符合期望。</p><h3 id="4-1、编写demo文件"><a href="#4-1、编写demo文件" class="headerlink" title="4.1、编写demo文件"></a>4.1、编写demo文件</h3><p>编写 <code>components/light/demo.js</code>：</p><pre><code class="js">import lightStore from &#39;../../stores/light&#39;import &#123;changeGreen, changeYellow, changeRed&#125; from &#39;../../actions/light&#39;let store = lightStore();let unsubscribe = store.subscribe(() =  console.log(store.getState()));store.dispatch(changeGreen());store.dispatch(changeYellow());store.dispatch(changeRed());</code></pre><h3 id="4-2、编写view模板"><a href="#4-2、编写view模板" class="headerlink" title="4.2、编写view模板"></a>4.2、编写view模板</h3><p>上面的都是 <code>redux</code> 的功能代码，现在为了方便在浏览器查看，使用 <code>koa</code> 搭建一个简单的服务器；使用<code>handlerbars</code> 作为模板引擎，使用下列方式创建模板和视图</p><p>在 <code>layouts/index.hbs</code> 中编写母模板，其中的 <code>&#123;@body&#125;</code> 是留给子模板填充的</p><pre><code class="js">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&#123;&#123;title&#125;&#125;&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &#123;@body&#125;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>在<code>views/light/index.hbs</code>中编写子模板内容，程序会自动将里面的内容自动替换上述模板中的 <code>&#123;@body&#125;</code> 占位符：</p><pre><code class="js">&lt;link rel=&quot;stylesheet&quot; href=&quot;http://localhost:3009/static/components/light/index.css&quot;&gt;&lt;h1交通灯示例&lt;/h1&gt;&lt;div id=&quot;demo&quot;&lt;/div&gt;&lt;script src=&quot;http://localhost:3009/static/components/light/&#123;&#123;filename&#125;&#125;.js&quot;&lt;/script&gt;</code></pre><h3 id="4-3、查看结果"><a href="#4-3、查看结果" class="headerlink" title="4.3、查看结果"></a>4.3、查看结果</h3><p>使用<code>npm start</code>开启两个服务，在浏览器URL里输入 <code>http://localhost:3000/light/demo</code> ，打开<code>console</code>，你将看到以下字符串：</p><pre><code class="js">Object &#123;color: &quot;green&quot;, time: &quot;5&quot;&#125;Object &#123;color: &quot;yellow&quot;, time: &quot;3&quot;&#125;Object &#123;color: &quot;red&quot;, time: &quot;7&quot;&#125;</code></pre><p>你get到了什么？全程你都没有涉及到红绿灯的UI，但仿佛却有红绿灯的即视感，状态完全可控可预见！redux 其实就是帮你实现了一套状态机，且逻辑清晰。由于不涉及UI，所以非常也很利于单元测试。</p><p>如果启动的时候 webpack 报错：<strong>You may need an appropriate loader to handle this file type</strong> ，请见<a href="http://stackoverflow.com/questions/33469929/you-may-need-an-appropriate-loader-to-handle-this-file-type-with-webpack-and-b">use Webpack with Babel to compile ES6 assets,</a> 这里的解决方案，因为Babel 6是相比以前是一个重大升级，配置按模块方式加载了；</p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p> 在继续后面的章节之前，稍微整理一下上面的逻辑，使用图表描述会更加清晰些：</p><p> <a href="https://gw.alicdn.com/tps/TB1HK1IKVXXXXbRXpXXXXXXXXXX-1043-623.jpg"><img data-src="https://gw.alicdn.com/tps/TB1HK1IKVXXXXbRXpXXXXXXXXXX-1043-623.jpg" alt="light" title="light"></a></p><p> 这简单的图里面还涉及到 <code>倒计时的状态</code>，此篇文章为减少复杂度，方便读者快速理解Redux的基本概念，并不牵涉倒计时的状态，后续文章示例自然会将车的状态考虑进去；</p><p> 将图中的<code>Action</code> <code>Reducer</code>以及 <code>Store</code> 和上述代码对照，一切都是那么合乎逻辑，自然而然；</p><p> 本文更多的是讲解如何快速上手Redux，并没有对其中的语法和概念进行过多的解释</p><ul><li>  一方面是语法的解释，中文文档里面的解释很全面，我没有自信能够超越它；</li><li>  另一方面让新手对这些简单的代码中的陌生概念(诸如<code>combineReducers</code> <code>dispatch</code>等）产生疑惑，带着问题来探索答案，加深印象</li></ul><p> 这里将上述操作流程大致绘制一下：</p><p> <a href="https://gw.alicdn.com/tps/TB1PEqxKVXXXXXuXVXXXXXXXXXX-1556-817.jpg"><img data-src="https://gw.alicdn.com/tps/TB1PEqxKVXXXXXuXVXXXXXXXXXX-1556-817.jpg" alt="workflow" title="workflow"></a></p><p> 顺带提及一下Redux的三大原则，看一眼就好，后续用多了自然会记住：</p><p> <a href="https://gw.alicdn.com/tps/TB1n_uzKVXXXXXBXVXXXXXXXXXX-912-388.jpg"><img data-src="https://gw.alicdn.com/tps/TB1n_uzKVXXXXXBXVXXXXXXXXXX-912-388.jpg" alt="three princel" title="three princel"></a></p><p> 最后，非常推荐<code>redux</code>库，里面有很多示例可以参考，比如经典的 <code>todos</code> 例子：</p><pre><code class="js">git clone https://github.com/rackt/redux.gitcd redux/examples/todomvcnpm installnpm startopen http://localhost:3000/</code></pre><p>  该示例包含：</p><ul><li>  Redux 中使用两个 reducer 的方法</li><li>  嵌套数据更新</li><li>  测试代码</li></ul><p>  更多参考：<a href="http://camsong.github.io/redux-in-chinese/docs/introduction/Examples.html">Redux示例</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果将React比喻成士兵的话，你的程序还需要一位将军，去管理士兵（的状态），而Redux恰好是一位好将军，简单高效；&lt;/p&gt;
&lt;p&gt;相比起React的学习曲线，Redux的稍微平坦一些；本系列教程，将以“红绿灯”为示例贯穿整个demo，希望能让用户快速理解&amp;amp;学习Redux。&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="React" scheme="https://laysan.site/tags/React/"/>
    
    <category term="Redux" scheme="https://laysan.site/tags/Redux/"/>
    
    <category term="Web" scheme="https://laysan.site/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu日常问题搜集和解决办法</title>
    <link href="https://laysan.site/2016/11/linux-mint-use/"/>
    <id>https://laysan.site/2016/11/linux-mint-use/</id>
    <published>2016-11-11T01:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>搜集了日常工作中linuxmint的使用的命令备份和遇到的问题以及解决办法.(持续更新中)</p><span id="more"></span><h2 id="保持ssh链接超时不自动断开"><a href="#保持ssh链接超时不自动断开" class="headerlink" title="保持ssh链接超时不自动断开"></a>保持ssh链接超时不自动断开</h2><p>用ssh链接服务端，一段时间不操作或屏幕没输出（比如复制文件）的时候，会自动断开.</p><p>在客户端~/.ssh/config文件(没有则新建)添加配置<code>ServerAliveInterval 30</code></p><pre><code>Host github.com     IdentityFile ~/.ssh/id_rsa_githubHost git.oschina.net     IdentityFile ~/.ssh/id_rsa_gitoscHost 192.168.1.72     IdentityFile ~/.ssh/id_rsa_deploy ServerAliveInterval 30</code></pre><h2 id="常用软件源"><a href="#常用软件源" class="headerlink" title="常用软件源"></a>常用软件源</h2><pre><code class="js">//gitsudo add-apt-repository ppa:git-core/ppa//atomsudo add-apt-repository ppa:webupd8team/atom//wizsudo add-apt-repository ppa:wiznote-team//telegramsudo add-apt-repository ppa:atareao/telegram//nodev7curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -//nodev6curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -//nginx  --stable//下载此key文件http://nginx.org/keys/nginx_signing.key//然后sudo apt-key add nginx_signing.key//firefox stablesudo add-apt-repository ppa:ubuntu-mozilla-security/ppa//firefox betasudo add-apt-repository ppa:mozillateam/firefox-next//touchpad-indicatorsudo add-apt-repository ppa:atareao/atareao</code></pre><h2 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh-My-Zsh"></a>Oh-My-Zsh</h2><pre><code class="js">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></pre><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><pre><code class="js">curl -fsSL https://get.docker.com/ | sh</code></pre><h2 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h2><pre><code class="js">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><h2 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h2><pre><code class="js">//apt 安装sudo apt install git subversion wget zsh wiznote hexo-cli guake atom rar unrar p7zip-full gshutdown//flashaptitude install pepperflashplugin-nonfree browser-plugin-freshplayer-pepperflash//需要下载deb安装的软件：brackets，mysql，jd-gui，filezilla, smartsvn, smartgit,smartsynchronize,DBeaver</code></pre><h2 id="Sublime-Text-3输入中文办法"><a href="#Sublime-Text-3输入中文办法" class="headerlink" title="Sublime Text 3输入中文办法"></a>Sublime Text 3输入中文办法</h2><p>** 使用<a href="https://github.com/lyfeyaj/sublime-text-imfix">这里的方法</a> **</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;搜集了日常工作中linuxmint的使用的命令备份和遇到的问题以及解决办法.(持续更新中)&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://laysan.site/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://laysan.site/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://laysan.site/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>React + Redux 入坑指南</title>
    <link href="https://laysan.site/2016/08/react-redux/"/>
    <id>https://laysan.site/2016/08/react-redux/</id>
    <published>2016-08-08T01:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>React + Redux 基本入坑配置</p><span id="more"></span><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>1. 单一数据源</strong></p><p><code>all states ==&gt;Store</code></p><ul><li>随着组件的复杂度上升（包括交互逻辑和业务逻辑），数据来源逐渐混乱，导致组件内部数据调用十分复杂，会产生数据冗余或者混用等情况。</li><li>Store 的基本思想是将所有的数据集中管理，数据通过 Store 分类处理更新，不再在组件内放养式生长。</li></ul><p><strong>2. 单向数据流</strong></p><p><code>dispatch(actionCreator) =&gt; Reducer =&gt; (state, action) =&gt; state</code></p><ul><li>单向数据流保证了数据的变化是有迹可循且受控制的。</li><li>通过绑定 Store 可以确定唯一数据来源。</li><li>actionCreator 通过 dispatch 触发，使组件内事件调用逻辑清晰，具体的事件处理逻辑不用放在组件写，保持 view 层的纯净。</li><li>Reducer 通过判断不同的 actionType 处理不同数据更新，保证数据有秩序更新。</li></ul><h1 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React + Redux"></a>React + Redux</h1><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><ul><li>actionType 定义操作类型</li><li>actionCreator 定义操作具体执行函数</li></ul><h3 id="1-Action-nbsp-基础写法"><a href="#1-Action-nbsp-基础写法" class="headerlink" title="1. Action&nbsp;基础写法"></a>1. Action&nbsp;基础写法</h3><ul><li>actionType 提供给 Reducer 判断动作类型</li><li>actionCreator 为可调用的执行函数，必须返回 actionType 类型</li></ul><pre><code class="js">// actionTypeexport const ACTION_TYPE = &quot;ACTION_TYPE&quot;;// actionCreatorlet actionCreator = config =&gt; &#123;  return &#123;    type: ACTION_TYPE, // 必须定义 type    config // 传递参数 =&gt; reducer  &#125;;&#125;;</code></pre><h3 id="2-Action-异步解决方法"><a href="#2-Action-异步解决方法" class="headerlink" title="2. Action 异步解决方法"></a>2. Action 异步解决方法</h3><ul><li><a href="https://github.com/gaearon/redux-thunk?spm=5176.100239.blogcont58700.7.nE2wTr">redux-thunk</a> 中间层做数据异步转换</li><li><a href="https://github.com/yelouafi/redux-saga?spm=5176.100239.blogcont58700.8.nE2wTr">redux-saga</a> 使用 ES6 generator / yield</li></ul><h3 id="2-1-redux-thunk-使用方法"><a href="#2-1-redux-thunk-使用方法" class="headerlink" title="2.1 redux-thunk 使用方法"></a>2.1 redux-thunk 使用方法</h3><ul><li><strong>redux-thunk 配置</strong><br>redux-thunk 为独立工具，需要另外安装，通过 redux 提供的中间件 applyMiddleware ，绑定到 store 中。</li></ul><pre><code class="js">import &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;import thunk from &quot;redux-thunk&quot;;import reducers from &quot;../reducers&quot;;let store = createStore(reducers, applyMiddleware(thunk));</code></pre><ul><li><strong>Action 使用 redux-thunk</strong><br>获取数据方法在异步获取数据后需要再次调用接收方法接收数据。</li></ul><pre><code class="js">// 接收方法let receiveSomething = res =&gt; &#123;  return &#123;    type: RECEIVE_SOME,    res  &#125;;&#125;;// 获取数据方法export let fetchSomething = args =&gt; &#123;  return dispatch =&gt; &#123;    return fetch(args).then(res =&gt; &#123;      return dispatch(receiveSomething(res));    &#125;);  &#125;;&#125;;</code></pre><h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><ul><li>引入 Action 中定义好的 actionType</li><li>传入 初始数据 和 actionType 后，返回更新数据<code>(initialState, action) =&gt; newState</code></li></ul><h3 id="Reducer-基础写法"><a href="#Reducer-基础写法" class="headerlink" title="Reducer 基础写法"></a>Reducer 基础写法</h3><h4 id="1-依据不同执行-ActionType-直接更新状态"><a href="#1-依据不同执行-ActionType-直接更新状态" class="headerlink" title="1.依据不同执行 ActionType 直接更新状态"></a>1.依据不同执行 ActionType 直接更新状态</h4><pre><code class="js">import &#123; ACTION_A, ACTION_B &#125; from &#39;../actions&#39;;let initialState = &#123; ... &#125;function example(state = initialState, action) &#123;    switch(action.type) &#123;        case ACTION_A:          return Object.assign(&#123;&#125;, state, action.config)        case ACTION_B:          return Object.assign(&#123;&#125;, state, action.config)    &#125;&#125;</code></pre><h4 id="2-对-Action-传递的数据多加一层处理"><a href="#2-对-Action-传递的数据多加一层处理" class="headerlink" title="2.对 Action 传递的数据多加一层处理"></a>2.对 Action 传递的数据多加一层处理</h4><pre><code class="js">let doSomething = config =&gt; &#123;  let &#123; a, b &#125; = config;  // do something with a, b  return &#123; a, b &#125;;&#125;;function example(state = initialState, action) &#123;  switch (action.type) &#123;    case ACTION_TYPE:      return Object.assign(&#123;&#125;, state, doSomething(action.config));  &#125;&#125;</code></pre><h4 id="3-合并多个-Reducer"><a href="#3-合并多个-Reducer" class="headerlink" title="3.合并多个 Reducer"></a>3.合并多个 Reducer</h4><p>通过 redux 提供的 combineReducers 将不同处理逻辑的 reducer 合并起来。</p><pre><code class="js">import &#123; combineReducers &#125; from &#39;redux&#39;;export default combineReducers(&#123;  reducerA,  reducerB&#125;);// orexport let reducer = (state = initialState, action) &#123;    a: processA(state.a, action),    b: processB(state.b, action)&#125;</code></pre><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><h3 id="1-将-Store-绑定-React"><a href="#1-将-Store-绑定-React" class="headerlink" title="1. 将 Store 绑定 React"></a>1. 将 Store 绑定 React</h3><p>使用 react-redux 提供的 Provider 可以将 Store 注入到 react 中。</p><p>Store 将合并后的 reducers 通过 createStore 创建，此外下面示例代码还使用中间件加入了一层 react-thunk 处理。</p><pre><code class="js">import ReactDOM from &quot;react-dom&quot;;import &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import thunk from &quot;redux-thunk&quot;;import reducers from &quot;./reducers&quot;;let store = createStore(reducers, applyMiddleware(thunk));ReactDOM.render(  &lt;Provider store=&#123;store&#125;&gt;// ...&lt;/Provider&gt;,  document.querySelector(&quot;#app&quot;));</code></pre><h3 id="2-将-state-绑定到-Component"><a href="#2-将-state-绑定到-Component" class="headerlink" title="2. 将 state 绑定到 Component"></a>2. 将 state 绑定到 Component</h3><p>使用 react-redux 提供的 connect 方法 将组件和所需数据绑定。</p><p><strong>需要注意的是</strong>，Store 创建时接收的是合并后的 reducers, 因此不同 reducer 上的处理数据绑定在了不同 reducer 对象上，而不是全部挂载在 Store 上。</p><p>mapStateToProps 将组件内部所需数据通过 props 传入组件内部。更多绑定机制，具体可参考<a href="http://cn.redux.js.org/docs/react-redux/api.html?spm=5176.100239.blogcont58700.9.nE2wTr">connect</a></p><pre><code class="js">import React, &#123; Component &#125; from &quot;react&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;class ComponentA extends Component &#123;  //...&#125;let mapStateToProps = state =&gt; &#123;  // attention !!!  let &#123; reducerA, reducerB &#125; = state;  return &#123;    propA: reducerA.propA,    propB: reducerB.propB  &#125;;&#125;;export default connect(mapStateToProps)(ComponentA);</code></pre><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><blockquote><p>React bindings for Redux embrace the idea of separating presentational and container components.</p><p>Redux 的 React 绑定库包含了 <strong>容器组件和展示组件相分离</strong> 的开发思想。</p></blockquote><ul><li>Presentational Components 展示型组件</li><li>Container Components 容器型组件</li></ul><p>展示型组件和容器型组件的区别在官方文档中已经给出很详细的解释了，但是中文文档的翻译有误，所以直接看英文比较更容易懂。</p><table><thead><tr><th></th><th>Presentational Components</th><th>Container Components</th></tr></thead><tbody><tr><td>Purpose</td><td>How things look (markup, styles)</td><td>How things work (data fetching, state updates)</td></tr><tr><td>Aware of Redux</td><td>No</td><td>Yes</td></tr><tr><td>To read data</td><td>Read data from props</td><td>Subscribe to Redux state</td></tr><tr><td>To change data</td><td>Invoke callbacks from props</td><td>Dispatch Redux actions</td></tr><tr><td>Are written</td><td>By hand</td><td>Usually generated by React Redux</td></tr></tbody></table><p>组件类型区分的模糊点在于怎么界定组件的内部功能规划。如果判定一个组件为展示型组件，那么它所需数据和处理方法都应该从父级传入，保持组件内部“纯净”。</p><p>在实际开发中，一个组件的逻辑跟业务紧密相关。如果需要将数据和方法从外部传入，那么父级组件所做的事情会很多，多重的子组件也会把父级逻辑弄乱，这就不是 redux 的初衷了。</p><p>中文文档翻译的意思是：容器组件应该为路由层面的组件，但这样既不符合实际开发需要，也违背了 redux 思想。真正界定两种组件的因素是：</p><ul><li><strong>展示型组件：</strong> 类似纯模板引擎，外加一层样式渲染，只负责渲染从 props 传进来的数据或者监听事件和父组件做小联动。它是“纯净”的，不需要使用到 Redux 的一套规则。</li><li><strong>容器型组件：</strong> 需要异步获取数据，更新组件状态等等。需要跟业务逻辑打交道的组件都可以认为是容器组件。这些逻辑的复杂性需要将数据整合到 Store 里统一管理。</li></ul><h3 id="2-Component-基础写法"><a href="#2-Component-基础写法" class="headerlink" title="2. Component 基础写法"></a>2. Component 基础写法</h3><ul><li><strong>组件渲染完成后调用 Action</strong></li></ul><p>当组件 connect 后，dispatch 方法已经注入到 props 中，所以触发 Action 可以从 props 获取 dispatch 方法。</p><pre><code class="js">import React, &#123; Component &#125; from &quot;react&quot;;// actionCreatorimport &#123; actionA, actionB &#125; from &quot;actions/actionA&quot;;class ComponentA extends Component &#123;  constructor(props) &#123;    super(props);  &#125;  componentDidMount() &#123;    let &#123; dispatch &#125; = this.props;    dispatch(actionA());  &#125;&#125;export default connect()(ComponentA);</code></pre><ul><li><strong>组件模板内调用 Action</strong></li></ul><p>组件内部所需的渲染数据都已经绑定在了 props 上，直接获取即可。</p><p><strong>需要注意的是</strong>，在事件监听中触发 Action，需要用一个匿名函数封装，否则 React 在渲染时就会执行事件绑定事件，而不是当事件发生再执行。</p><pre><code class="js">render() &#123;  let &#123; dispatch, propA, propB &#125; = this.props;    return (      &lt;section&gt;        // Attention !!!        &lt;input type=&quot;text&quot; onClick=&#123;(ev) =&gt; dispatch(actionB(ev))&#125; /&gt;        &lt;p className=&#123;propA&#125;&gt;&#123;propB&#125;&lt;/p&gt;      &lt;/section&gt;    )&#125;</code></pre><ul><li><strong>容器组件传递方法</strong></li></ul><p>容器型组件需要连接 Redux，使用 dispatch 触发 actionCreator。</p><p>展示型组件需要用到的方法调用在容器型组件内定义好，通过 props 传入到展示型组件中。</p><pre><code class="js">// get actionCreatorimport &#123; actionA &#125; from &quot;./actions/actionA&quot;;class Parent extends Component &#123;  handleCallback(data) &#123;    // use dispatch    let &#123; dispatch &#125; = this.props;    dispatch(actionA(data));  &#125;  render() &#123;    return &lt;Child onSomethingChange=&#123;this.handleCallback&#125; /&gt;;  &#125;&#125;// connet Reduxexport default connect()(Parent);</code></pre><ul><li><strong>展示组件接收 props</strong></li></ul><p>展示型组件不需要用到 Redux 的一切，它的 props 仅仅存在于父级传入的数据和方法。</p><pre><code class="js">// don&#39;t need action/dispatch/connectclass Child extends Component &#123;  handleSomething(data) &#123;    // handle anything with props    this.props.onSomethingChange(data);  &#125;  render() &#123;    return (      // just markup &amp; style      &lt;input onChange=&#123;handleSomething&#125; /&gt;    );  &#125;&#125;</code></pre><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>图示箭头代表各概念之间的相互关系，不代表数据流。（ 能理解下面这张图，这篇文章就没白看了 -。- ）</p><p><img data-src="//img.leense.site/post/2016/08/201608080930-1.png"></p><p><strong>参考文档</strong></p><ul><li><a href="http://redux.js.org/?spm=5176.100239.blogcont58700.11.nE2wTr">Redux 英文文档</a></li><li><a href="http://cn.redux.js.org/index.html?spm=5176.100239.blogcont58700.12.nE2wTr">Redux 中文文档</a></li></ul><p>END.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;React + Redux 基本入坑配置&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="React" scheme="https://laysan.site/tags/React/"/>
    
    <category term="Redux" scheme="https://laysan.site/tags/Redux/"/>
    
    <category term="Web" scheme="https://laysan.site/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>我与JetBrains</title>
    <link href="https://laysan.site/2016/06/jetbrains-with-me/"/>
    <id>https://laysan.site/2016/06/jetbrains-with-me/</id>
    <published>2016-06-16T01:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSDN上正在举行一个<a href="http://bss.csdn.net/m/product/jetbrains/index">JetBrains使用技能分享征集大赛</a>,正好也趁这个机会记录一下我与JetBrains的一路旅程,也算是记录一下这几年的成长历程.</p><span id="more"></span><p>能进入软件行业也完全是机缘巧合.在校学习的是电子信息专业,只接触过一点点的C语言,但也仅仅是C语言,对于其他的完全没有一点认知.虽然对C很感兴趣,却也没有深入的去学习.11年的时候刚从学校毕业,顺道说下老家是安徽的,学校在河南,毕业后跟着就业协议来到了厦门.一个普通的院校想找份工作确实不容易,最后也是逼急了有人要就直接签了.在厦门工作一路磕磕碰碰,没到一个月跟我一起过去的两个同学都想回去考研,而我也辗转到了成都.</p><p>又是一段艰辛的找工作之路,期间看中一家公司,连续去了三次每次都是被拒绝…后来阴错阳差进入了一家软件公司,搞起了Java,开始了这一段代码之路…</p><p>最开始码代码使用的是Eclipse,包括其他各种版本,EclipseEE,MyEclipse,STS.当时只知道还有个NetBeans的IDE,个人比较喜欢折腾,eclipse上安装了各种插件,加上之前的电脑配置比较差,写代码的时候一度想怒砸键盘.<br>12年的时候折腾病又犯了,突然想玩一下NetBeans.结果NetBeans没玩上却勾搭上了Idea.</p><p>Idea是个好东西,不过调教起来太费劲了,尤其是熟悉了Eclipse习惯的.于是各种改啊,好在idea很人性化的提供了eclipse的快捷键.每天都会在百度上找”Idea怎么像Eclipse一样XXXX”,苦于当时网上刻钟资料都比较少,有的还都很旧,在idea上只能跑跑hello world,web项目完全不知道怎么运行.想放弃又不舍得,idea的各种概念跟eclipse都不一样,只能一点一点的摸索.</p><p>还记得成功运行起了第一个maven项目时的激动..总算是稍微了解了一点Idea,能正常开发了.当即干掉了eclipse,完全投入了idea的怀抱,快捷键也改回默认的了,虽然还不能完全驾驭,但是起码短时调教的比较听话了.</p><p>Idea提供了很强大和方便的代码工具,智能提示,live templete,debuggger等等等等各种以至现在我帮别人调试代码都完全不好下手..收来接触到Sublime Text又是被那黑色主题迷倒了,Idea好像是到14的时候才提供了Dark主题,在EAP版本刚放出来就迫不及待换上了.</p><p>爱上了Idea就爱上了JetBrains全家桶,后来把PHPStorm,WebStorm,RubyMine,ReShaper,TeamCity都尝试了一遍,还有后来出的CLion和0xdbe(DataGrip).</p><p>Idea也提供了很多优质的插件,直到目前自己常用的有:</p><p><code>CheckStyle-IDEA</code>:代码检查工具</p><p><code>CodeGlance</code>:提供一个类似sublime的minimap代码地图(找了好久才找到)</p><p><code>EclipseFormatter</code>:统一代码风格,谁叫他们都是eclipser呢</p><p><code>intellij-javadocs</code>:javadoc工具</p><p><code>jr-ide-idea</code>:Jrebel工具</p><p><code>MavenRunHelper</code>:提供便捷的maven操作</p><p>还有很多好用的插件只是在工作中不常用就没有装上.</p><p>idea的社区发展的很快,网上的各种资料和教程都多了起来,很愧疚没有提供一些有价值的经验给后来者.<br>在GitHub上接触到了一个Idea的qq群 IntelliJ IDEA后端开发群.这是至今最喜欢的群,群里提供了各种学习资料,有问题在群内可以得到热心的解答.</p><p>最近转做前端了,Idea用的越来越少了,现在主用WebStorm.非常感谢Jetbrains提供的这一系列Ide,现在使用起来已经是得心应手了,不过idea确实还有很多不足之处需要改进的.<br>一个是编码和字体问题,非Utf-8格式的支持很差.javadoc的便利性还是稍显欠缺.内存占用也比较大.但是相对于他的优点来说这些就显得微不足道了..</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSDN上正在举行一个&lt;a href=&quot;http://bss.csdn.net/m/product/jetbrains/index&quot;&gt;JetBrains使用技能分享征集大赛&lt;/a&gt;,正好也趁这个机会记录一下我与JetBrains的一路旅程,也算是记录一下这几年的成长历程.&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="技巧" scheme="https://laysan.site/tags/%E6%8A%80%E5%B7%A7/"/>
    
    <category term="IDEA" scheme="https://laysan.site/tags/IDEA/"/>
    
    <category term="JetBrains" scheme="https://laysan.site/tags/JetBrains/"/>
    
  </entry>
  
  <entry>
    <title>12个非常实用的JavaScript小技巧</title>
    <link href="https://laysan.site/2016/05/javascript-12-tips/"/>
    <id>https://laysan.site/2016/05/javascript-12-tips/</id>
    <published>2016-05-18T01:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中将给大家分享12个有关于JavaScript的小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。</p><span id="more"></span><h2 id="使用-操作符转换布尔值"><a href="#使用-操作符转换布尔值" class="headerlink" title="使用!!操作符转换布尔值"></a>使用<code>!!</code>操作符转换布尔值</h2><p>有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回<code>true</code>值。为了做这样的验证，我们可以使用<code>!!</code>操作符来实现是非常的方便与简单。对于变量可以使用<code>!!variable</code>做检测，只要变量的值为:<code>0</code>、<code>null</code>、<code>&quot; &quot;</code>、<code>undefined</code>或者<code>NaN</code>都将返回的是<code>false</code>，反之返回的是<code>true</code>。比如下面的示例：</p><pre><code>function Account(cash) &#123;    this.cash = cash;    this.hasMoney = !!cash;&#125;var account = new Account(100.50);console.log(account.cash); // 100.50console.log(account.hasMoney); // truevar emptyAccount = new Account(0);console.log(emptyAccount.cash); // 0console.log(emptyAccount.hasMoney); // false</code></pre><p>在这个示例中，只要<code>account.cash</code>的值大于<code>0</code>，那么<code>account.hasMoney</code>返回的值就是<code>true</code>。</p><h2 id="使用-将字符串转换成数字"><a href="#使用-将字符串转换成数字" class="headerlink" title="使用+将字符串转换成数字"></a>使用<code>+</code>将字符串转换成数字</h2><p>这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回<code>NaN</code>，比如下面的示例：</p><pre><code>function toNumber(strNumber) &#123;    return +strNumber;&#125;console.log(toNumber(&quot;1234&quot;)); // 1234console.log(toNumber(&quot;ACB&quot;)); // NaN</code></pre><p>这个也适用于<code>Date</code>，在本例中，它将返回的是时间戳数字：</p><pre><code>console.log(+new Date()) // 1461288164385</code></pre><h2 id="并条件符"><a href="#并条件符" class="headerlink" title="并条件符"></a>并条件符</h2><p>如果你有一段这样的代码：</p><pre><code>if (conected) &#123;    login();&#125;</code></pre><p>你也可以将变量简写，并且使用<code>&amp;amp;&amp;amp;</code>和函数连接在一起，比如上面的示例，可以简写成这样：</p><pre><code>conected &amp;amp;&amp;amp; login();</code></pre><p>如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：</p><pre><code>user &amp;amp;&amp;amp; user.login();</code></pre><h2 id="使用-运算符"><a href="#使用-运算符" class="headerlink" title="使用||运算符"></a>使用<code>||</code>运算符</h2><p>在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用<code>||</code>操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为<code>false</code>，那么第二个值将会认为是一个默认值。如下面这个示例：</p><pre><code>function User(name, age) &#123;    this.name = name || &quot;Oliver Queen&quot;;    this.age = age || 27;&#125;var user1 = new User();console.log(user1.name); // Oliver Queenconsole.log(user1.age); // 27var user2 = new User(&quot;Barry Allen&quot;, 25);console.log(user2.name); // Barry Allenconsole.log(user2.age); // 25</code></pre><h2 id="在循环中缓存array-length"><a href="#在循环中缓存array-length" class="headerlink" title="在循环中缓存array.length"></a>在循环中缓存<code>array.length</code></h2><p>这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：</p><pre><code>for(var i = 0; i &amp;lt; array.length; i++) &#123;    console.log(array[i]);&#125;</code></pre><p>如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将<code>array.length</code>做一个缓存：</p><pre><code>var length = array.length;for(var i = 0; i &amp;lt; length; i++) &#123;    console.log(array[i]);&#125;</code></pre><p>你也可以写在这样：</p><pre><code>for(var i = 0, length = array.length; i &amp;lt; length; i++) &#123;    console.log(array[i]);&#125;</code></pre><h2 id="检测对象中属性"><a href="#检测对象中属性" class="headerlink" title="检测对象中属性"></a>检测对象中属性</h2><p>当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用<code>document.querySelector()</code>来选择一个<code>id</code>，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：</p><pre><code>if (&#39;querySelector&#39; in document) &#123;    document.querySelector(&quot;#id&quot;);&#125; else &#123;    document.getElementById(&quot;id&quot;);&#125;</code></pre><p>在这个示例中，如果<code>document</code>不存在<code>querySelector</code>函数，那么就会调用<code>docuemnt.getElementById(&quot;id&quot;)</code>。</p><h2 id="获取数组中最后一个元素"><a href="#获取数组中最后一个元素" class="headerlink" title="获取数组中最后一个元素"></a>获取数组中最后一个元素</h2><p><code>Array.prototype.slice(begin,end)</code>用来获取<code>begin</code>和<code>end</code>之间的数组元素。如果你不设置<code>end</code>参数，将会将数组的默认长度值当作<code>end</code>值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为<code>begin</code>的值，那么你可以获取数组的最后一个元素。如：</p><pre><code>var array = [1,2,3,4,5,6];console.log(array.slice(-1)); // [6]console.log(array.slice(-2)); // [5,6]console.log(array.slice(-3)); // [4,5,6]</code></pre><h2 id="数组截断"><a href="#数组截断" class="headerlink" title="数组截断"></a>数组截断</h2><p>这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有<code>10</code>个元素，但你只想只要前五个元素，那么你可以通过<code>array.length=5</code>来截断数组。如下面这个示例：</p><pre><code>var array = [1,2,3,4,5,6];console.log(array.length); // 6array.length = 3;console.log(array.length); // 3console.log(array); // [1,2,3]</code></pre><h2 id="替换所有"><a href="#替换所有" class="headerlink" title="替换所有"></a>替换所有</h2><p><code>String.replace()</code>函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的<code>/g</code>来模拟<code>replaceAll()</code>函数功能：</p><pre><code>var string = &quot;john john&quot;;console.log(string.replace(/hn/, &quot;ana&quot;)); // &quot;joana john&quot;console.log(string.replace(/hn/g, &quot;ana&quot;)); // &quot;joana joana&quot;</code></pre><h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><p>如果你要合并两个数组，一般情况之下你都会使用<code>Array.concat()</code>函数：</p><pre><code>var array1 = [1,2,3];var array2 = [4,5,6];console.log(array1.concat(array2)); // [1,2,3,4,5,6];</code></pre><p>然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用<code>Array.pus().apply(arr1,arr2)</code>来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：</p><pre><code>var array1 = [1,2,3];var array2 = [4,5,6];console.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];</code></pre><h2 id="将NodeList转换成数组"><a href="#将NodeList转换成数组" class="headerlink" title="将NodeList转换成数组"></a>将<code>NodeList</code>转换成数组</h2><p>如果你运行<code>document.querySelectorAll(“p”)</code>函数时，它可能返回DOM元素的数组，也就是<code>NodeList</code>对象。但这个对象不具有数组的函数功能，比如<code>sort()</code>、<code>reduce()</code>、<code>map()</code>、<code>filter()</code>等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用<code>[].slice.call(elements)</code>来实现：</p><pre><code>var elements = document.querySelectorAll(&quot;p&quot;); // NodeListvar arrayElements = [].slice.call(elements); // Now the NodeList is an arrayvar arrayElements = Array.from(elements); // This is another way of converting NodeList to Array</code></pre><h2 id="数组元素的洗牌"><a href="#数组元素的洗牌" class="headerlink" title="数组元素的洗牌"></a>数组元素的洗牌</h2><p>对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：</p><pre><code>var list = [1,2,3];console.log(list.sort(function() &#123; Math.random() - 0.5 &#125;)); // [2,1,3]</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在你学会了些有用的JavaScript小技巧。希望这些小技巧能在工作中帮助你解决一些麻烦，或者说这篇文章对你有所帮助。如果你有一些优秀的JavaScript小技巧，欢迎在评论中与我们一起分享。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在这篇文章中将给大家分享12个有关于JavaScript的小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="web" scheme="https://laysan.site/tags/web/"/>
    
    <category term="JavaScript" scheme="https://laysan.site/tags/JavaScript/"/>
    
    <category term="技巧" scheme="https://laysan.site/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 开发的45个经典技巧</title>
    <link href="https://laysan.site/2016/04/javascript-45-tips/"/>
    <id>https://laysan.site/2016/04/javascript-45-tips/</id>
    <published>2016-04-20T01:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是一个绝冠全球的编程语言，可用于Web开发、移动应用开发（PhoneGap、Appcelerator）、服务器端开发（Node.js和Wakanda）等等。JavaScript还是很多新手踏入编程世界的第一个语言。既可以用来显示浏览器中的简单提示框，也可以通过nodebot或nodruino来控制机器人。能够编写结构清晰、性能高效的JavaScript代码的开发人员，现如今已成了招聘市场最受追捧的人。</p><span id="more"></span><p>在这篇文章里，我将分享一些JavaScript的技巧、秘诀和最佳实践，除了少数几个外，不管是浏览器的JavaScript引擎，还是服务器端JavaScript解释器，均适用。</p><h2 id="1、首次为变量赋值时务必使用var关键字"><a href="#1、首次为变量赋值时务必使用var关键字" class="headerlink" title="1、首次为变量赋值时务必使用var关键字"></a>1、首次为变量赋值时务必使用<code>var</code>关键字</h2><p>变量没有声明而直接赋值得话，默认会作为一个新的全局变量，要尽量避免使用全局变量。</p><h2 id="2、使用-取代"><a href="#2、使用-取代" class="headerlink" title="2、使用===取代=="></a>2、使用<code>===</code>取代<code>==</code></h2><p><code>==</code>和<code>!=</code>操作符会在需要的情况下自动转换数据类型。但<code>===</code>和<code>!==</code>不会，它们会同时比较值和数据类型，这也使得它们要比<code>==</code>和<code>!=</code>快。</p><pre><code>[10] === 10    // is false[10]  == 10    // is true&#39;10&#39; == 10     // is true&#39;10&#39; === 10    // is false []   == 0     // is true [] ===  0     // is false &#39;&#39; == false   // is true but true == &quot;a&quot; is false &#39;&#39; === false  // is false</code></pre><h2 id="3、underfined、null、0、false、NaN、空字符串的逻辑结果均为false"><a href="#3、underfined、null、0、false、NaN、空字符串的逻辑结果均为false" class="headerlink" title="3、underfined、null、0、false、NaN、空字符串的逻辑结果均为false"></a>3、<code>underfined</code>、<code>null</code>、0、false、NaN、空字符串的逻辑结果均为false</h2><h2 id="4、行尾使用分号"><a href="#4、行尾使用分号" class="headerlink" title="4、行尾使用分号"></a>4、行尾使用分号</h2><p>实践中最好还是使用分号，忘了写也没事，大部分情况下JavaScript解释器都会自动添加。对于为何要使用分号，可参考文章<a href="http://davidwalsh.name/javascript-semicolons">JavaScript中关于分号的真相</a>。</p><h2 id="5、使用对象构造器"><a href="#5、使用对象构造器" class="headerlink" title="5、使用对象构造器"></a>5、使用对象构造器</h2><pre><code>function Person(firstName, lastName)&#123;    this.firstName =  firstName;    this.lastName = lastName;&#125;var Saad = new Person(&quot;Saad&quot;, &quot;Mousliki&quot;);</code></pre><h2 id="6、小心使用typeof、instanceof和contructor"><a href="#6、小心使用typeof、instanceof和contructor" class="headerlink" title="6、小心使用typeof、instanceof和contructor"></a>6、小心使用<code>typeof</code>、<code>instanceof</code>和<code>contructor</code></h2><ul><li>  <code>typeof</code>：JavaScript一元操作符，用于以字符串的形式返回变量的原始类型，注意，<code>typeof null</code>也会返回<code>object</code>，大多数的对象类型（数组Array、时间Date等）也会返回<code>object</code></li><li>  <code>contructor</code>：内部原型属性，可以通过代码重写</li><li>  <code>instanceof</code>：JavaScript操作符，会在原型链中的构造器中搜索，找到则返回<code>true</code>，否则返回<code>false</code><pre><code>var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];typeof arr;   // 返回 &quot;object&quot;arr instanceof Array // truearr.constructor();  //[]</code></pre></li></ul><h2 id="7、使用自调用函数"><a href="#7、使用自调用函数" class="headerlink" title="7、使用自调用函数"></a>7、使用自调用函数</h2><p>函数在创建之后直接自动执行，通常称之为自调用匿名函数（Self-Invoked Anonymous Function）或直接调用函数表达式（Immediately Invoked Function Expression ）。格式如下：</p><pre><code>(function()&#123;    // 置于此处的代码将自动执行&#125;)();  (function(a,b)&#123;    var result = a+b;    return result;&#125;)(10,20)</code></pre><h2 id="8、从数组中随机获取成员"><a href="#8、从数组中随机获取成员" class="headerlink" title="8、从数组中随机获取成员"></a>8、从数组中随机获取成员</h2><pre><code>var items = [12, 548 , &#39;a&#39; , 2 , 5478 , &#39;foo&#39; , 8852, , &#39;Doe&#39; , 2145 , 119];var  randomItem = items[Math.floor(Math.random() * items.length)];</code></pre><h2 id="9、获取指定范围内的随机数"><a href="#9、获取指定范围内的随机数" class="headerlink" title="9、获取指定范围内的随机数"></a>9、获取指定范围内的随机数</h2><p>这个功能在生成测试用的假数据时特别有数，比如介与指定范围内的工资数。</p><pre><code>var x = Math.floor(Math.random() * (max - min + 1)) + min;</code></pre><h2 id="10、生成从0到指定值的数字数组"><a href="#10、生成从0到指定值的数字数组" class="headerlink" title="10、生成从0到指定值的数字数组"></a>10、生成从0到指定值的数字数组</h2><pre><code>var numbersArray = [] , max = 100;for( var i=1; numbersArray.push(i++) &amp;lt; max;);  // numbers = [1,2,3 ... 100]</code></pre><h2 id="11、生成随机的字母数字字符串"><a href="#11、生成随机的字母数字字符串" class="headerlink" title="11、生成随机的字母数字字符串"></a>11、生成随机的字母数字字符串</h2><pre><code>function generateRandomAlphaNum(len) &#123;    var rdmString = &quot;&quot;;    for( ; rdmString.length &amp;lt; len; rdmString  += Math.random().toString(36).substr(2));    return  rdmString.substr(0, len);&#125;</code></pre><h2 id="12、打乱数字数组的顺序"><a href="#12、打乱数字数组的顺序" class="headerlink" title="12、打乱数字数组的顺序"></a>12、打乱数字数组的顺序</h2><pre><code>var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];numbers = numbers.sort(function()&#123; return Math.random() - 0.5&#125;);/* numbers 数组将类似于 [120, 5, 228, -215, 400, 458, -85411, 122205]  */</code></pre><p>这里使用了JavaScript内置的数组排序函数，更好的办法是用专门的代码来实现（如Fisher-Yates算法），可以参见StackOverFlow上的<a href="http://stackoverflow.com/questions/962802/is-it-correct-to-use-javascript-array-sort-method-for-shuffling/962890#962890">这个讨论</a>。</p><h2 id="13、字符串去空格"><a href="#13、字符串去空格" class="headerlink" title="13、字符串去空格"></a>13、字符串去空格</h2><p>Java、C#和PHP等语言都实现了专门的字符串去空格函数，但JavaScript中是没有的，可以通过下面的代码来为<code>String</code>对象函数一个<code>trim</code>函数：</p><pre><code>String.prototype.trim = function()&#123;return this.replace(/^\s+|\s+$/g, &quot;&quot;);&#125;;</code></pre><p>新的JavaScript引擎已经有了<code>trim()</code>的原生实现。</p><h2 id="14、数组之间追加"><a href="#14、数组之间追加" class="headerlink" title="14、数组之间追加"></a>14、数组之间追加</h2><pre><code>var array1 = [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458];var array2 = [&quot;Doe&quot; , 555 , 100];Array.prototype.push.apply(array1, array2);/* array1 值为  [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] */</code></pre><h2 id="15、对象转换为数组"><a href="#15、对象转换为数组" class="headerlink" title="15、对象转换为数组"></a>15、对象转换为数组</h2><pre><code>var argArray = Array.prototype.slice.call(arguments);</code></pre><h2 id="16、验证是否是数字"><a href="#16、验证是否是数字" class="headerlink" title="16、验证是否是数字"></a>16、验证是否是数字</h2><pre><code>function isNumber(n)&#123;    return !isNaN(parseFloat(n)) &amp;amp;&amp;amp; isFinite(n);&#125;</code></pre><h2 id="17、验证是否是数组"><a href="#17、验证是否是数组" class="headerlink" title="17、验证是否是数组"></a>17、验证是否是数组</h2><pre><code>function isArray(obj)&#123;    return Object.prototype.toString.call(obj) === &#39;[object Array]&#39; ;&#125;</code></pre><p>但如果<code>toString()</code>方法被重写过得话，就行不通了。也可以使用下面的方法：</p><pre><code>Array.isArray(obj); // its a new Array method</code></pre><p>如果在浏览器中没有使用frame，还可以用<code>instanceof</code>，但如果上下文太复杂，也有可能出错。</p><pre><code>var myFrame = document.createElement(&#39;iframe&#39;);document.body.appendChild(myFrame);var myArray = window.frames[window.frames.length-1].Array;var arr = new myArray(a,b,10); // [a,b,10]  // myArray 的构造器已经丢失，instanceof 的结果将不正常// 构造器是不能跨 frame 共享的arr instanceof Array; // false</code></pre><h2 id="18、获取数组中的最大值和最小值"><a href="#18、获取数组中的最大值和最小值" class="headerlink" title="18、获取数组中的最大值和最小值"></a>18、获取数组中的最大值和最小值</h2><pre><code>var  numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];var maxInNumbers = Math.max.apply(Math, numbers);var minInNumbers = Math.min.apply(Math, numbers);</code></pre><h2 id="19、清空数组"><a href="#19、清空数组" class="headerlink" title="19、清空数组"></a>19、清空数组</h2><pre><code>var myArray = [12 , 222 , 1000 ];  myArray.length = 0; // myArray will be equal to [].</code></pre><h2 id="20、不要直接从数组中delete或remove元素"><a href="#20、不要直接从数组中delete或remove元素" class="headerlink" title="20、不要直接从数组中delete或remove元素"></a>20、不要直接从数组中<code>delete</code>或<code>remove</code>元素</h2><p>如果对数组元素直接使用<code>delete</code>，其实并没有删除，只是将元素置为了<code>undefined</code>。数组元素删除应使用<code>splice</code>。</p><p>切忌：</p><pre><code>var items = [12, 548 ,&#39;a&#39; , 2 , 5478 , &#39;foo&#39; , 8852, , &#39;Doe&#39; ,2154 , 119 ];items.length; // return 11delete items[3]; // return trueitems.length; // return 11/* items 结果为 [12, 548, &quot;a&quot;, undefined × 1, 5478, &quot;foo&quot;, 8852, undefined × 1, &quot;Doe&quot;, 2154, 119] */</code></pre><p>而应：</p><pre><code>var items = [12, 548 ,&#39;a&#39; , 2 , 5478 , &#39;foo&#39; , 8852, , &#39;Doe&#39; ,2154 , 119 ];items.length; // return 11items.splice(3,1) ;items.length; // return 10/* items 结果为 [12, 548, &quot;a&quot;, 5478, &quot;foo&quot;, 8852, undefined × 1, &quot;Doe&quot;, 2154, 119]</code></pre><p>删除对象的属性时可以使用<code>delete</code>。</p><h2 id="21、使用length属性截断数组"><a href="#21、使用length属性截断数组" class="headerlink" title="21、使用length属性截断数组"></a>21、使用<code>length</code>属性截断数组</h2><p>前面的例子中用<code>length</code>属性清空数组，同样还可用它来截断数组：</p><pre><code>var myArray = [12 , 222 , 1000 , 124 , 98 , 10 ];  myArray.length = 4; // myArray will be equal to [12 , 222 , 1000 , 124].</code></pre><p>与此同时，如果把<code>length</code>属性变大，数组的长度值变会增加，会使用<code>undefined</code>来作为新的元素填充。<code>length</code>是一个可写的属性。</p><pre><code>myArray.length = 10; // the new array length is 10myArray[myArray.length - 1] ; // undefined</code></pre><h2 id="22、在条件中使用逻辑与或"><a href="#22、在条件中使用逻辑与或" class="headerlink" title="22、在条件中使用逻辑与或"></a>22、在条件中使用逻辑与或</h2><pre><code>var foo = 10;  foo == 10 &amp;amp;&amp;amp; doSomething(); // is the same thing as if (foo == 10) doSomething();foo == 5 || doSomething(); // is the same thing as if (foo != 5) doSomething();</code></pre><p>逻辑或还可用来设置默认值，比如函数参数的默认值。</p><pre><code>function doSomething(arg1)&#123;    arg1 = arg1 || 10; // arg1 will have 10 as a default value if it’s not already set&#125;</code></pre><h2 id="23、使得map-函数方法对数据循环"><a href="#23、使得map-函数方法对数据循环" class="headerlink" title="23、使得map()函数方法对数据循环"></a>23、使得<code>map()</code>函数方法对数据循环</h2><pre><code>var squares = [1,2,3,4].map(function (val) &#123;      return val * val;  &#125;);// squares will be equal to [1, 4, 9, 16]</code></pre><h2 id="24、保留指定小数位数"><a href="#24、保留指定小数位数" class="headerlink" title="24、保留指定小数位数"></a>24、保留指定小数位数</h2><pre><code>var num =2.443242342;num = num.toFixed(4);  // num will be equal to 2.4432</code></pre><p>注意，<code>toFixec()</code>返回的是字符串，不是数字。</p><h2 id="25、浮点计算的问题"><a href="#25、浮点计算的问题" class="headerlink" title="25、浮点计算的问题"></a>25、浮点计算的问题</h2><pre><code>0.1 + 0.2 === 0.3 // is false9007199254740992 + 1 // is equal to 90071992547409929007199254740992 + 2 // is equal to 9007199254740994</code></pre><p>为什么呢？因为0.1+0.2等于0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，在内部都是64位浮点小数表示，具体可以参见<a href="http://www.2ality.com/2012/04/number-encoding.html">JavaScript中的数字是如何编码的</a>.</p><p>可以通过使用<code>toFixed()</code>和<code>toPrecision()</code>来解决这个问题。</p><h2 id="26、通过for-in循环检查对象的属性"><a href="#26、通过for-in循环检查对象的属性" class="headerlink" title="26、通过for-in循环检查对象的属性"></a>26、通过for-in循环检查对象的属性</h2><p>下面这样的用法，可以防止迭代的时候进入到对象的原型属性中。</p><pre><code>for (var name in object) &#123;      if (object.hasOwnProperty(name)) &#123;        // do something with name    &#125;  &#125;</code></pre><h2 id="27、逗号操作符"><a href="#27、逗号操作符" class="headerlink" title="27、逗号操作符"></a>27、逗号操作符</h2><pre><code>var a = 0;var b = ( a++, 99 );console.log(a);  // a will be equal to 1console.log(b);  // b is equal to 99</code></pre><h2 id="28、临时存储用于计算和查询的变量"><a href="#28、临时存储用于计算和查询的变量" class="headerlink" title="28、临时存储用于计算和查询的变量"></a>28、临时存储用于计算和查询的变量</h2><p>在jQuery选择器中，可以临时存储整个DOM元素。</p><pre><code>var navright = document.querySelector(&#39;#right&#39;);var navleft = document.querySelector(&#39;#left&#39;);var navup = document.querySelector(&#39;#up&#39;);var navdown = document.querySelector(&#39;#down&#39;);</code></pre><h2 id="29、提前检查传入isFinite-的参数"><a href="#29、提前检查传入isFinite-的参数" class="headerlink" title="29、提前检查传入isFinite()的参数"></a>29、提前检查传入<code>isFinite()</code>的参数</h2><pre><code>isFinite(0/0) ; // falseisFinite(&quot;foo&quot;); // falseisFinite(&quot;10&quot;); // trueisFinite(10);   // trueisFinite(undefined);  // falseisFinite();   // falseisFinite(null);  // true，这点当特别注意</code></pre><h2 id="30、避免在数组中使用负数做索引"><a href="#30、避免在数组中使用负数做索引" class="headerlink" title="30、避免在数组中使用负数做索引"></a>30、避免在数组中使用负数做索引</h2><pre><code>var numbersArray = [1,2,3,4,5]; var from = numbersArray.indexOf(&quot;foo&quot;) ; // from is equal to -1 numbersArray.splice(from,2); // will return [5]</code></pre><p>注意传给<code>splice</code>的索引参数不要是负数，当是负数时，会从数组结尾处删除元素。</p><h2 id="31、用JSON来序列化与反序列化"><a href="#31、用JSON来序列化与反序列化" class="headerlink" title="31、用JSON来序列化与反序列化"></a>31、用JSON来序列化与反序列化</h2><pre><code>var person = &#123;name :&#39;Saad&#39;, age : 26, department : &#123;ID : 15, name : &quot;R&amp;amp;D&quot;&#125; &#125;;var stringFromPerson = JSON.stringify(person);/* stringFromPerson 结果为 &quot;&#123;&quot;name&quot;:&quot;Saad&quot;,&quot;age&quot;:26,&quot;department&quot;:&#123;&quot;ID&quot;:15,&quot;name&quot;:&quot;R&amp;amp;D&quot;&#125;&#125;&quot;   */var personFromString = JSON.parse(stringFromPerson);/* personFromString 的值与 person 对象相同  */</code></pre><h2 id="32、不要使用eval-或者函数构造器"><a href="#32、不要使用eval-或者函数构造器" class="headerlink" title="32、不要使用eval()或者函数构造器"></a>32、不要使用<code>eval()</code>或者函数构造器</h2><p><code>eval()</code>和函数构造器（<code>Function</code> consturctor）的开销较大，每次调用，JavaScript引擎都要将源代码转换为可执行的代码。</p><pre><code>var func1 = new Function(functionCode);var func2 = eval(functionCode);</code></pre><h2 id="32、不要使用eval-或者函数构造器-1"><a href="#32、不要使用eval-或者函数构造器-1" class="headerlink" title="32、不要使用eval()或者函数构造器"></a>32、不要使用<code>eval()</code>或者函数构造器</h2><p><code>eval()</code>和函数构造器（<code>Function</code> consturctor）的开销较大，每次调用，JavaScript引擎都要将源代码转换为可执行的代码。</p><pre><code>var func1 = new Function(functionCode);var func2 = eval(functionCode);</code></pre><h2 id="33、避免使用with"><a href="#33、避免使用with" class="headerlink" title="33、避免使用with()"></a>33、避免使用<code>with()</code></h2><p>使用<code>with()</code>可以把变量加入到全局作用域中，因此，如果有其它的同名变量，一来容易混淆，二来值也会被覆盖。</p><h2 id="34、不要对数组使用for-in"><a href="#34、不要对数组使用for-in" class="headerlink" title="34、不要对数组使用for-in"></a>34、不要对数组使用for-in</h2><p>避免：</p><pre><code>var sum = 0;  for (var i in arrayNumbers) &#123;      sum += arrayNumbers[i];  &#125;</code></pre><p>而是：</p><pre><code>var sum = 0;  for (var i = 0, len = arrayNumbers.length; i &amp;lt; len; i++) &#123;      sum += arrayNumbers[i];  &#125;</code></pre><p>另外一个好处是，<code>i</code>和<code>len</code>两个变量是在<code>for</code>循环的第一个声明中，二者只会初始化一次，这要比下面这种写法快：</p><pre><code>for (var i = 0; i &amp;lt; arrayNumbers.length; i++)</code></pre><h2 id="35、传给setInterval-和setTimeout-时使用函数而不是字符串"><a href="#35、传给setInterval-和setTimeout-时使用函数而不是字符串" class="headerlink" title="35、传给setInterval()和setTimeout()时使用函数而不是字符串"></a>35、传给<code>setInterval()</code>和<code>setTimeout()</code>时使用函数而不是字符串</h2><p>如果传给<code>setTimeout()</code>和<code>setInterval()</code>一个字符串，他们将会用类似于<code>eval</code>方式进行转换，这肯定会要慢些，因此不要使用：</p><pre><code>setInterval(&#39;doSomethingPeriodically()&#39;, 1000);  setTimeout(&#39;doSomethingAfterFiveSeconds()&#39;, 5000);</code></pre><p>而是用：</p><pre><code>setInterval(doSomethingPeriodically, 1000);  setTimeout(doSomethingAfterFiveSeconds, 5000);</code></pre><h2 id="36、使用switch-case代替一大叠的if-else"><a href="#36、使用switch-case代替一大叠的if-else" class="headerlink" title="36、使用switch/case代替一大叠的if/else"></a>36、使用<code>switch/case</code>代替一大叠的<code>if/else</code></h2><p>当判断有超过两个分支的时候使用<code>switch/case</code>要更快一些，而且也更优雅，更利于代码的组织，当然，如果有超过10个分支，就不要使用<code>switch/case</code>了。</p><h2 id="37、在switch-case中使用数字区间"><a href="#37、在switch-case中使用数字区间" class="headerlink" title="37、在switch/case中使用数字区间"></a>37、在<code>switch/case</code>中使用数字区间</h2><p>其实，<code>switch/case</code>中的<code>case</code>条件，还可以这样写：</p><pre><code>function getCategory(age) &#123;      var category = &quot;&quot;;      switch (true) &#123;          case isNaN(age):              category = &quot;not an age&quot;;              break;          case (age &amp;gt;= 50):              category = &quot;Old&quot;;              break;          case (age &amp;lt;= 20):              category = &quot;Baby&quot;;              break;          default:              category = &quot;Young&quot;;              break;      &#125;;      return category;  &#125;  getCategory(5);  // 将返回 &quot;Baby&quot;</code></pre><h2 id="38、使用对象作为对象的原型"><a href="#38、使用对象作为对象的原型" class="headerlink" title="38、使用对象作为对象的原型"></a>38、使用对象作为对象的原型</h2><p>下面这样，便可以给定对象作为参数，来创建以此为原型的新对象：</p><pre><code>function clone(object) &#123;      function OneShotConstructor()&#123;&#125;;    OneShotConstructor.prototype = object;      return new OneShotConstructor();&#125;clone(Array).prototype ;  // []</code></pre><h2 id="39、HTML字段转换函数"><a href="#39、HTML字段转换函数" class="headerlink" title="39、HTML字段转换函数"></a>39、HTML字段转换函数</h2><pre><code>function escapeHTML(text) &#123;      var replacements= &#123;&quot;&amp;lt;&quot;: &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;: &quot;&amp;gt;&quot;,&quot;&amp;amp;&quot;: &quot;&amp;amp;&quot;, &quot;\&quot;&quot;: &quot;&quot;&quot;&#125;;                          return text.replace(/[&amp;lt;&amp;gt;&amp;amp;&quot;]/g, function(character) &#123;          return replacements[character];      &#125;);&#125;</code></pre><h2 id="40、不要在循环内部使用try-catch-finally"><a href="#40、不要在循环内部使用try-catch-finally" class="headerlink" title="40、不要在循环内部使用try-catch-finally"></a>40、不要在循环内部使用try-catch-finally</h2><p>try-catch-finally中catch部分在执行时会将异常赋给一个变量，这个变量会被构建成一个运行时作用域内的新的变量。</p><p>切忌：</p><pre><code>var object = [&#39;foo&#39;, &#39;bar&#39;], i;  for (i = 0, len = object.length; i &amp;lt;len; i++) &#123;      try &#123;          // do something that throws an exception    &#125;      catch (e) &#123;           // handle exception      &#125;&#125;</code></pre><p>而应该：</p><pre><code>var object = [&#39;foo&#39;, &#39;bar&#39;], i;  try &#123;    for (i = 0, len = object.length; i &amp;lt;len; i++) &#123;          // do something that throws an exception    &#125;&#125;catch (e) &#123;       // handle exception  &#125;</code></pre><h2 id="41、使用XMLHttpRequests时注意设置超时"><a href="#41、使用XMLHttpRequests时注意设置超时" class="headerlink" title="41、使用XMLHttpRequests时注意设置超时"></a>41、使用XMLHttpRequests时注意设置超时</h2><p>XMLHttpRequests在执行时，当长时间没有响应（如出现网络问题等）时，应该中止掉连接，可以通过<code>setTimeout()</code>来完成这个工作：</p><pre><code>var xhr = new XMLHttpRequest ();xhr.onreadystatechange = function () &#123;      if (this.readyState == 4) &#123;          clearTimeout(timeout);          // do something with response data    &#125;  &#125;  var timeout = setTimeout( function () &#123;      xhr.abort(); // call error callback  &#125;, 60*1000 /* timeout after a minute */ );xhr.open(&#39;GET&#39;, url, true);  xhr.send();</code></pre><p>同时需要注意的是，不要同时发起多个XMLHttpRequests请求。</p><h2 id="42、处理WebSocket的超时"><a href="#42、处理WebSocket的超时" class="headerlink" title="42、处理WebSocket的超时"></a>42、处理WebSocket的超时</h2><p>通常情况下，WebSocket连接创建后，如果30秒内没有任何活动，服务器端会对连接进行超时处理，防火墙也可以对单位周期没有活动的连接进行超时处理。</p><p>为了防止这种情况的发生，可以每隔一定时间，往服务器发送一条空的消息。可以通过下面这两个函数来实现这个需求，一个用于使连接保持活动状态，另一个专门用于结束这个状态。</p><pre><code>var timerID = 0;function keepAlive() &#123;    var timeout = 15000;      if (webSocket.readyState == webSocket.OPEN) &#123;          webSocket.send(&#39;&#39;);      &#125;      timerId = setTimeout(keepAlive, timeout);  &#125;  function cancelKeepAlive() &#123;      if (timerId) &#123;          cancelTimeout(timerId);      &#125;  &#125;</code></pre><p><code>keepAlive()</code>函数可以放在WebSocket连接的<code>onOpen()</code>方法的最后面，<code>cancelKeepAlive()</code>放在<code>onClose()</code>方法的最末尾。</p><h2 id="43、时间注意原始操作符比函数调用快，使用VanillaJS"><a href="#43、时间注意原始操作符比函数调用快，使用VanillaJS" class="headerlink" title="43、时间注意原始操作符比函数调用快，使用VanillaJS"></a>43、时间注意原始操作符比函数调用快，使用VanillaJS</h2><p>比如，一般不要这样：</p><pre><code>var min = Math.min(a,b);A.push(v);</code></pre><p>可以这样来代替：</p><pre><code>var min = a &amp;lt; b ? a : b;A[A.length] = v;</code></pre><h2 id="44、开发时注意代码结构，上线前检查并压缩JavaScript代码"><a href="#44、开发时注意代码结构，上线前检查并压缩JavaScript代码" class="headerlink" title="44、开发时注意代码结构，上线前检查并压缩JavaScript代码"></a>44、开发时注意代码结构，上线前检查并压缩JavaScript代码</h2><p>别忘了在写代码时使用一个代码美化工具。使用JSLint(一个语法检查工具)并且在上线前压缩代码（比如使用JSMin）。注：现在代码压缩一般推荐 UglifyJS (<a href="https://github.com/mishoo/UglifyJS2">https://github.com/mishoo/UglifyJS2</a>)</p><h2 id="45、JavaScript博大精深，这里有些不错的学习资源"><a href="#45、JavaScript博大精深，这里有些不错的学习资源" class="headerlink" title="45、JavaScript博大精深，这里有些不错的学习资源"></a>45、JavaScript博大精深，这里有些不错的学习资源</h2><ul><li>  Code Academy资源：<a href="http://www.codecademy.com/tracks/javascript">http://www.codecademy.com/tracks/javascript</a></li><li>  Marjin Haverbekex编写的_Eloquent JavaScript_：<a href="http://eloquentjavascript.net/">http://eloquentjavascript.net/</a></li><li>  John Resig编写的_Advanced JavaScript_：<a href="http://ejohn.org/apps/learn/">http://ejohn.org/apps/learn/</a></li></ul><p>原文连接: <a href="http://www.codeceo.com/article/javascript-45-tips.html">http://www.codeceo.com/article/javascript-45-tips.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JavaScript是一个绝冠全球的编程语言，可用于Web开发、移动应用开发（PhoneGap、Appcelerator）、服务器端开发（Node.js和Wakanda）等等。JavaScript还是很多新手踏入编程世界的第一个语言。既可以用来显示浏览器中的简单提示框，也可以通过nodebot或nodruino来控制机器人。能够编写结构清晰、性能高效的JavaScript代码的开发人员，现如今已成了招聘市场最受追捧的人。&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="web" scheme="https://laysan.site/tags/web/"/>
    
    <category term="JQuery" scheme="https://laysan.site/tags/JQuery/"/>
    
    <category term="tips" scheme="https://laysan.site/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JQuery插件开发</title>
    <link href="https://laysan.site/2016/04/jquery-plugin/"/>
    <id>https://laysan.site/2016/04/jquery-plugin/</id>
    <published>2016-04-18T01:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你看到这篇文章，我确信你毫无疑问会认为jQuery是一个使用简便的库。jQuery可能使用起来很简单，但是它仍然有一些奇怪的地方，对它基本功能和概念不熟悉的人可能会难以掌握。但是不用担心，我下面已经把代码划分成小部分，做了一个简单的指导。那些语法看起来可能过于复杂，但是如果进入到它的思想和模式中，它是非常简单易懂的。</p><span id="more"></span><p>下面，我们有了一个插件的基本层次：</p><pre><code class="js">// Shawn Khameneh// ExtraordinaryThoughts.com(function($) &#123;    var privateFunction = function() &#123;// 代码在这里运行    &#125;    var methods = &#123;        init: function(options) &#123;            return this.each(function() &#123;                var $this = $(this);                var settings = $this.data(&#39;pluginName&#39;);                if(typeof(settings) == &#39;undefined&#39;) &#123;                    var defaults = &#123;                        propertyName: &#39;value&#39;,                        onSomeEvent: function() &#123;&#125;                    &#125;                    settings = $.extend(&#123;&#125;, defaults, options);                    $this.data(&#39;pluginName&#39;, settings);                &#125; else &#123;                    settings = $.extend(&#123;&#125;, settings, options);                &#125;// 代码在这里运行            &#125;);        &#125;,        destroy: function(options) &#123;            return $(this).each(function() &#123;                var $this = $(this);                $this.removeData(&#39;pluginName&#39;);            &#125;);        &#125;,        val: function(options) &#123;            var someValue = this.eq(0).html();            return someValue;        &#125;    &#125;;    $.fn.pluginName = function() &#123;        var method = arguments[0];        if(methods[method]) &#123;            method = methods[method];            arguments = Array.prototype.slice.call(arguments, 1);        &#125; else if( typeof(method) == &#39;object&#39; || !method ) &#123;            method = methods.init;        &#125; else &#123;            $.error( &#39;Method &#39; +  method + &#39; does not exist on jQuery.pluginName&#39; );            return this;        &#125;        return method.apply(this, arguments);    &#125;&#125;)(jQuery);</code></pre><p>你可能会注意到，我所提到代码的结构和其他插件代码有很大的不同。根据你的使用和需求的不同，插件的开发方式也可能会呈现多样化。我的目的是澄清代码中的一些概念，足够让你找到适合自己的方法去理解和开发一个jQuery插件。</p><p>现在，来解剖我们的代码吧！</p><h3 id="容器：一个即时执行函数"><a href="#容器：一个即时执行函数" class="headerlink" title="容器：一个即时执行函数"></a>容器：一个即时执行函数</h3><p>根本上来说，每个插件的代码是被包含在一个即时执行的函数当中，如下：</p><pre><code class="js">(function(arg1, arg2) &#123;// 代码&#125;)(arg1, arg2);</code></pre><p>即时执行函数，顾名思义，是一个函数。让它与众不同的是，它被包含在一对小括号里面，这让所有的代码都在匿名函数的局部作用域中运行。这并不是说DOM（全局变量）在函数内是被屏蔽的，而是外部无法访问到函数内部的公共变量和对象命名空间。这是一个很好的开始，这样你声明你的变量和对象的时候，就不用担心着变量名和已经存在的代码有冲突。</p><p>现在，因为函数内部所有的所有公共变量是无法访问的，这样要把jQuery本身作为一个内部的公共变量来使用就会成为问题。就像普通的函数一样，即时函数也根据引用传入对象参数。我们可以将jQuery对象传入函数，如下：</p><pre><code class="js">(function($) &#123;// 局部作用域中使用$来引用jQuery&#125;)(jQuery);</code></pre><p>我们传入了一个把公共变量“jQuery”传入了一个即时执行的函数里面，在函数局部（容器）中我们可以通过<code>“$”</code>来引用它。也就是说，我们把容器当做一个函数来调用，而这个函数的参数就是jQuery。因为我们引用的“jQuery”作为公共变量传入，而不是它的简写“$”，这样我们就可以兼容Prototype库。如果你不用Prototype或者其它用<code>“$”</code>做简写的库的话，你不这样做也不会造成什么影响，但是知道这种用法仍是一件好事。</p><h3 id="插件：一个函数"><a href="#插件：一个函数" class="headerlink" title="插件：一个函数"></a>插件：一个函数</h3><p>一个jQuery插件本质上是我们塞进jQuery命名空间中一个庞大的函数，当然，我们可以很轻易地用“jQuery.pluginName=function”，来达到我们的目的，但是如果我们这样做的话我们的插件的代码是处于没有被保护的暴露状态的。“jQuery.fn”是“jQuery.prototype”的简写，意味当我们通过jQuery命名空间去获取我们的插件的时候，它仅可写（不可修改）。它事实上可以为你干点什么事呢？它让你恰当地组织自己的代码，和理解如何保护你的代码不受运行时候不需要的修改。最好的说法就是，这是一个很好的实践！</p><p>通过一个插件，我们获得一个基本的jQuery函数：</p><pre><code class="js">(function($) &#123;    $.fn.pluginName = function(options) &#123;// 代码在此处运行        return this;    &#125;&#125;)(jQuery);</code></pre><p>上面的代码中的函数可以像其他的jQuery函数那样通过<br><code>$(&#39;#element’).pluginName()</code>来调用。注意，我是如何把“return this”语句加进去的；这小片的代码通过返回一个原来元素的集合（包含在this当中）的引用来产生链式调用的效果，而这些元素是被一个jQuery对象所包裹的。你也应该注意，“this”在这个特定的作用域中是一个jQuery对象，相当于<code>$(‘#element’)</code>。</p><p>根据返回的对象，我们可以总结出，在上面的代码中，使用<code>$(‘#element’).pluginName()</code>的效果和使用<code>$(‘#element’)</code>的效果是一样的。在你的即时执行函数作用域中，没必要用<code>$(this)</code>的方式来把this包裹到一个jQuery对象中，因为this本身已经是被包装好的jQuery对象。</p><h3 id="多个元素：理解Sizzle"><a href="#多个元素：理解Sizzle" class="headerlink" title="多个元素：理解Sizzle"></a>多个元素：理解Sizzle</h3><p>jQuery使用的选择器引擎叫Sizzle，Sizzle可以为你的函数提供多元素操作（例如对所有类名相同的元素）。这是jQuery几个优秀的特性之一，但这也是你在开发插件过程中需要考虑的事情。即使你不准备为你的插件提供多元素支持，但为这做准备仍然是一个很好的实践。</p><p>这里我添加了一小段代码，它让你的插件代码为多元素集合中每个元素单独地起作用：</p><pre><code class="js">function($) &#123;// 向jQuery中被保护的“fn”命名空间中添加你的插件代码，用“pluginName”作为插件的函数名称    $.fn.pluginName = function(options) &#123;// 返回“this”（函数each（）的返回值也是this），以便进行链式调用。        return this.each(function() &#123;// 此处运行代码，可以通过“this”来获得每个单独的元素// 例如： $(this).show()；            var $this = $(this);        &#125;);    &#125;&#125;)(jQuery);</code></pre><p>在以上示例代码中，我并不是用 each（）在我的选择器中每个元素上运行代码。在那个被 each（）调用的函数的局部作用域中，你可以通过this来引用每个被单独处理的元素，也就是说你可以通过$(this)来引用它的jQuery对象。在局部作用域中，我用$this变量存储起jQuery对象，而不是每次调用函数的时候都使用$(this)，这会是个很好的实践。当然，这样做并不总是必要的；但我已经额外把它包含在我的代码中。还有要注意的是，我们将会对每个单独方法都使用 each（），这样到时我们就可以返回我们需要的值，而不是一个jQuery对象。</p><p>下面是一个例子，假如我们的插件支持一个 val 的方法，它可以返回我们需要的值：</p><pre><code class="js">$(&#39;#element&#39;).pluginName(&#39;val&#39;);// 会返回我们需要的值，而不是一个jQuery对象</code></pre><h3 id="功能：公有方法和私有方法"><a href="#功能：公有方法和私有方法" class="headerlink" title="功能：公有方法和私有方法"></a>功能：公有方法和私有方法</h3><p>一个基本的函数可能在某些情况下可以良好地工作，但是一个稍微复杂一点的插件就需要提供各种各样的方法和私有函数。你可能会使用不同的命名空间去为你的插件提供各种方法，但是最好不要让你的源代码因为多余的命名空间而变得混乱。</p><p>下面的代码定义了一个存储公有方法的JSON对象，以及展示了如何使用插件中的主函数中去判断哪些方法被调用，和如何在让方法作用到选择器每个元素上。</p><pre><code class="js">(function($) &#123;// 在我们插件容器内，创造一个公共变量来构建一个私有方法    var privateFunction = function() &#123;// code here    &#125;// 通过字面量创造一个对象，存储我们需要的共有方法    var methods = &#123;// 在字面量对象中定义每个单独的方法        init: function() &#123;// 为了更好的灵活性，对来自主函数，并进入每个方法中的选择器其中的每个单独的元素都执行代码            return this.each(function() &#123;// 为每个独立的元素创建一个jQuery对象                var $this = $(this);// 执行代码// 例如： privateFunction();            &#125;);        &#125;,        destroy: function() &#123;// 对选择器每个元素都执行方法            return this.each(function() &#123;// 执行代码            &#125;);        &#125;    &#125;;    $.fn.pluginName = function() &#123;// 获取我们的方法，遗憾的是，如果我们用function(method)&#123;&#125;来实现，这样会毁掉一切的        var method = arguments[0];// 检验方法是否存在        if(methods[method]) &#123;// 如果方法存在，存储起来以便使用// 注意：我这样做是为了等下更方便地使用each（）            method = methods[method];// 如果方法不存在，检验对象是否为一个对象（JSON对象）或者method方法没有被传入        &#125; else if( typeof(method) == &#39;object&#39; || !method ) &#123;// 如果我们传入的是一个对象参数，或者根本没有参数，init方法会被调用            method = methods.init;        &#125; else &#123;// 如果方法不存在或者参数没传入，则报出错误。需要调用的方法没有被正确调用            $.error( &#39;Method &#39; +  method + &#39; does not exist on jQuery.pluginName&#39; );            return this;        &#125;// 调用我们选中的方法// 再一次注意我们是如何将each（）从这里转移到每个单独的方法上的        return method.call(this);    &#125;&#125;)(jQuery);</code></pre><p>注意我把 privateFunction 当做了一个函数内部的全局变量。考虑到所有的代码的运行都是在插件容器内进行的，所以这种做法是可以被接受的，因为它只在插件的作用域中可用。在插件中的主函数中，我检验了传入参数所指向的方法是否存在。如果方法不存在或者传入的是参数为对象， init 方法会被运行。最后，如果传入的参数不是一个对象而是一个不存在的方法，我们会报出一个错误信息。</p><p>同样要注意的是，我是如何在每个方法中都使用<code> this.each()</code> 的。当我们在主函数中调用 <code>method.call(this)</code> 的时候，这里的 this 事实上就是一个jQuery对象，作为 this 传入每个方法中。所以在我们方法的即时作用域中，它已经是一个jQuery对象。只有在被 <code>each（）</code>所调用的函数中，我们才有必要将this包装在一个jQuery对象中。</p><p>下面是一些用法的例子：</p><pre><code class="js">/*注意这些例子可以在目前的插件代码中正确运行，并不是所有的插件都使用同样的代码结构*/// 为每个类名为 &quot;.className&quot; 的元素执行init方法$(&#39;.className&#39;).pluginName();$(&#39;.className&#39;).pluginName(&#39;init&#39;);$(&#39;.className&#39;).pluginName(&#39;init&#39;, &#123;&#125;);// 向init方法传入“&#123;&#125;”对象作为函数参数$(&#39;.className&#39;).pluginName(&#123;&#125;);// 向init方法传入“&#123;&#125;”对象作为函数参数// 为每个类名为 “.className” 的元素执行destroy方法$(&#39;.className&#39;).pluginName(&#39;destroy&#39;);$(&#39;.className&#39;).pluginName(&#39;destroy&#39;, &#123;&#125;);// 向destroy方法传入“&#123;&#125;”对象作为函数参数// 所有代码都可以正常运行$(&#39;.className&#39;).pluginName(&#39;init&#39;, &#39;argument1&#39;, &#39;argument2&#39;);// 把 &quot;argument 1&quot; 和 &quot;argument 2&quot; 传入 &quot;init&quot;// 不正确的使用$(&#39;.className&#39;).pluginName(&#39;nonexistantMethod&#39;);$(&#39;.className&#39;).pluginName(&#39;nonexistantMethod&#39;, &#123;&#125;);$(&#39;.className&#39;).pluginName(&#39;argument 1&#39;);// 会尝试调用 &quot;argument 1&quot; 方法$(&#39;.className&#39;).pluginName(&#39;argument 1&#39;, &#39;argument 2&#39;);// 会尝试调用 &quot;argument 1&quot; ，“argument 2”方法$(&#39;.className&#39;).pluginName(&#39;privateFunction&#39;);// &#39;privateFunction&#39; 不是一个方法</code></pre><p>在上面的例子中多次出现了 {} ，表示的是传入方法中的参数。在这小节中，上面代码可以可以正常运行，但是参数不会被传入方法中。继续阅读下一小节，你会知道如何向方法传入参数。</p><h3 id="设置插件：传入参数"><a href="#设置插件：传入参数" class="headerlink" title="设置插件：传入参数"></a>设置插件：传入参数</h3><p>许多插件都支持参数传入，如配置参数和回调函数。你可以通过传入JS键值对对象或者函数参数，为方法提供信息。如果你的方法支持多于一个或两个参数，那么没有比传入对象参数更恰当的方式。</p><pre><code class="js">(function($) &#123;    var methods = &#123;        init: function(options) &#123;// 在每个元素上执行方法            return this.each(function() &#123;                var $this = $(this);// 创建一个默认设置对象                var defaults = &#123;                    propertyName: &#39;value&#39;,                    onSomeEvent: function() &#123;&#125;                &#125;// 使用extend方法从options和defaults对象中构造出一个settings对象                var settings = $.extend(&#123;&#125;, defaults, options);// 执行代码            &#125;);        &#125;    &#125;;    $.fn.pluginName = function() &#123;        var method = arguments[0];        if(methods[method]) &#123;            method = methods[method];// 我们的方法是作为参数传入的，把它从参数列表中删除，因为调用方法时并不需要它            arguments = Array.prototype.slice.call(arguments, 1);        &#125; else if( typeof(method) == &#39;object&#39; || !method ) &#123;            method = methods.init;        &#125; else &#123;            $.error( &#39;Method &#39; +  method + &#39; does not exist on jQuery.pluginName&#39; );            return this;        &#125;// 用apply方法来调用我们的方法并传入参数        return method.apply(this, arguments);    &#125;&#125;)(jQuery);</code></pre><p>正如上面所示，一个“options”参数被添加到方法当中，和“arguments”也被添加到了主函数中。如果一个方法已经被声明，在参数传入方法之前，调用那个方法的参数会从参数列表中删除掉。我用了“apply（）”来代替了“call（）”，“apply（）”本质上是和“call（）”做着同样的工作的，但不同的是它允许参数的传入。这种结构也允许多个参数的传入，如果你愿意这样做，你也可以为你的方法修改参数列表，例如：“init:function(arg1, arg2){}”。</p><p>如果你是使用JS对象作为参数传入，你可能需要定义一个默认对象。一旦默认对象被声明，你可以使用<code>“$.extend”</code>来合并参数对象和默认对象中的值，以形成一个新的参数对象来使用（在我们的例子中就是“settings”）；</p><p>这里有一些例子，用来演示以上的逻辑：</p><pre><code class="js">var options = &#123;    customParameter: &#39;Test 1&#39;,    propertyName: &#39;Test 2&#39;&#125;var defaults = &#123;    propertyName: &#39;Test 3&#39;,    onSomeEvent: &#39;Test 4&#39;&#125;var settings = $.extend(&#123;&#125;, defaults, options);/*settings == &#123;propertyName: &#39;Test 2&#39;,onSomeEvent: &#39;Test 4&#39;,customParameter: &#39;Test 1&#39;&#125;*/</code></pre><h3 id="保存设置：添加持久性数据"><a href="#保存设置：添加持久性数据" class="headerlink" title="保存设置：添加持久性数据"></a>保存设置：添加持久性数据</h3><p>有时你会想在你的插件中保存设置和信息，这时jQuery中的“data（）”函数就可以派上用场了。它在使用上是非常简单的，它会尝试获取和元素相关的数据，如果数据不存在，它就会创造相应的数据并添加到元素上。一旦你使用了“data（）”来为元素添加信息，请确认你已经记住，当不再需要数据的时候，用“removeData（）”来删除相应的数据。</p><pre><code class="js">// Shawn Khameneh// ExtraordinaryThoughts.com(function($) &#123;    var privateFunction = function() &#123;// 执行代码    &#125;    var methods = &#123;        init: function(options) &#123;// 在每个元素上执行方法            return this.each(function() &#123;                var $this = $(this);// 尝试去获取settings，如果不存在，则返回“undefined”                var settings = $this.data(&#39;pluginName&#39;);// 如果获取settings失败，则根据options和default创建它                if(typeof(settings) == &#39;undefined&#39;) &#123;                    var defaults = &#123;                        propertyName: &#39;value&#39;,                        onSomeEvent: function() &#123;&#125;                    &#125;                    settings = $.extend(&#123;&#125;, defaults, options);// 保存我们新创建的settings                    $this.data(&#39;pluginName&#39;, settings);                &#125; else &#123;                    / 如果我们获取了settings，则将它和options进行合并（这不是必须的，你可以选择不这样做）                    settings = $.extend(&#123;&#125;, settings, options);// 如果你想每次都保存options，可以添加下面代码：// $this.data(&#39;pluginName&#39;, settings);                &#125;// 执行代码            &#125;);        &#125;,        destroy: function(options) &#123;// 在每个元素中执行代码            return $(this).each(function() &#123;                var $this = $(this);// 执行代码// 删除元素对应的数据                $this.removeData(&#39;pluginName&#39;);            &#125;);        &#125;,        val: function(options) &#123;// 这里的代码通过.eq(0)来获取选择器中的第一个元素的，我们或获取它的HTML内容作为我们的返回值            var someValue = this.eq(0).html();// 返回值            return someValue;        &#125;    &#125;;    $.fn.pluginName = function() &#123;        var method = arguments[0];        if(methods[method]) &#123;            method = methods[method];            arguments = Array.prototype.slice.call(arguments, 1);        &#125; else if( typeof(method) == &#39;object&#39; || !method ) &#123;            method = methods.init;        &#125; else &#123;            $.error( &#39;Method &#39; +  method + &#39; does not exist on jQuery.pluginName&#39; );            return this;        &#125;        return method.apply(this, arguments);    &#125;&#125;)(jQuery);</code></pre><p>在上面的代码中，我检验了元素的数据是否存在。如果数据不存在，“options”和“default”会被合并，构建成一个新的settings，然后用“data（）”保存在元素中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你看到这篇文章，我确信你毫无疑问会认为jQuery是一个使用简便的库。jQuery可能使用起来很简单，但是它仍然有一些奇怪的地方，对它基本功能和概念不熟悉的人可能会难以掌握。但是不用担心，我下面已经把代码划分成小部分，做了一个简单的指导。那些语法看起来可能过于复杂，但是如果进入到它的思想和模式中，它是非常简单易懂的。&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="插件" scheme="https://laysan.site/tags/%E6%8F%92%E4%BB%B6/"/>
    
    <category term="web" scheme="https://laysan.site/tags/web/"/>
    
    <category term="JQuery" scheme="https://laysan.site/tags/JQuery/"/>
    
  </entry>
  
  <entry>
    <title>细说 CSS margin</title>
    <link href="https://laysan.site/2016/03/css-margin/"/>
    <id>https://laysan.site/2016/03/css-margin/</id>
    <published>2016-03-10T00:30:00.000Z</published>
    <updated>2021-04-21T08:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文着重描述关于 margin，我们日常不太容易发现的“坑”。</p><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>接触过 CSS 的人应该都知道 CSS 的盒模型：</p><p><img data-src="//img.leense.site/post/2016/03/201603100930-1.png"></p><p>由内容边缘（Content edge）包围形成的是内容盒（Content Box），类推还有内边距盒（Padding Box）、边框盒（Border Box）、外边距盒（Margin Box）。</p><p>其中内容盒、内边距盒、边框盒的背景由 background 属性决定，而外边距盒的背景是透明的。</p><span id="more"></span><h2 id="CSS-margin-属性"><a href="#CSS-margin-属性" class="headerlink" title="CSS margin 属性"></a>CSS margin 属性</h2><p>关于 margin 属性，有几点可能跟我们的直觉不相符：</p><ul><li>如果 margin 的值是百分比，则是相对于父元素的内容盒宽度来计算的，即使 margin-top 和 margin-bottom 也是如此。因此即使父元素的高宽不相等，子元素的 margin 元素指定了相同的百分比值，则子元素各个方向的 margin 计算值都是相等的。</li><li>margin-top 和 margin-bottom 值对行内非替换元素（non-replaced inline element）是无效的。因此我们可以指定 img 元素的 margin-top 和 margin-bottom，而非替换行内元素（如 i，span 等）设置 margin-top 和 margin-bottom 却不会产生效果。</li></ul><h2 id="相邻的-margin（Adjoining-margin）"><a href="#相邻的-margin（Adjoining-margin）" class="headerlink" title="相邻的 margin（Adjoining margin）"></a>相邻的 margin（Adjoining margin）</h2><p>如果两个垂直方向上的 margin，它们中间没有其他垂直 margin，但它们之间不一定相接触，我们就说这两个 margin 是垂直毗连（vertical-adjacent）的，包括以下四种情况，满足其中之一即可：</p><ul><li>父元素的 top margin 和第一个子元素的 top margin</li><li>父元素的 bottom margin 和最后一个子元素的 bottom margin</li><li>元素的 bottom margin 和与这个元素相邻的兄弟元素的 top margin</li><li>如果一个元素，它没有生成 BFC、没有包含正常流的子元素、min-height 是 0、height 是 0 或者 auto，则它的 top margin 和 bottom margin 也是垂直毗连的</li></ul><p>如果两个 margin 满足以下三个条件，我们就说这两个 margin 是相邻（adjoining）的：</p><ul><li>这两个 margin 是垂直毗连的，即满足上面四种情况之一</li><li>margin 的两个元素都是正常流的块级元素，并且在同一个 BFC 中</li><li>两个 margin 之间没有行盒（line box）、清除浮动后的空隙（clearance）、padding 和 border</li></ul><h2 id="margin-折叠（Collapsing-margins）"><a href="#margin-折叠（Collapsing-margins）" class="headerlink" title="margin 折叠（Collapsing margins）"></a>margin 折叠（Collapsing margins）</h2><p>margin 折叠，即相邻的 margin 有可能会被折叠成一个。</p><p>比如元素 #a 指定了 margin-bottom 为 10px，而它下方的元素 #b 指定了 margin-top 为 20px，如这样：</p><p><img data-src="//img.leense.site/post/2016/03/201603100930-2.png"></p><p>元素 #a 的 margin-bottom 和元素 #b 的 margin-top 在位置上重叠了，它们之间的距离是 20px，即元素 #b 的 bottom margin 长度，这就是 margin 折叠现象。关于这个现象，可以这么理解：</p><p>margin 定义的是它与其他盒子之间的最小间距。其中元素 #a 指定了 margin-bottom 为 10px，就表明它下方的元素 #b 与它至少要有 10px 的距离，它指定的是一个最小值，因此实际的距离可以比这个大。</p><p>元素 #a 下方的元素 #b 也设置了 margin-top 为 20px，如果不折叠，则他们之间就有 30px 的距离。如果折叠成了一个 20px 的距离，则对元素 #a 来说，它的 margin-bottom 要求至少要有 10px 的距离，是满足的，而对于元素 #b 来说，它的 margin-top 要求至少要有 20px 的距离，也是满足的。</p><p>而 margin 折叠的存在，其实是为了可以在视觉上显得更美观，也更贴近设计师的预期。</p><h2 id="margin-折叠规则"><a href="#margin-折叠规则" class="headerlink" title="margin 折叠规则"></a>margin 折叠规则</h2><p>并不是所有的 margin 都可以折叠，需要满足以下条件：</p><ul><li>垂直相邻的 margin 才有可能折叠，水平 margin 永远不折叠</li><li>根元素（即 html 元素）的 margin 永远不折叠</li><li>如果一个元素，它的 top margin 和 bottom margin 是相邻的，并且有清除浮动后的空隙（clearance），这个元素的 margin 可以跟兄弟元素的 margin 折叠，但是折叠后的 margin 不能跟父元素的 bottom margin 折叠。<br>需要注意的是，margin 并不是只能折叠一次，多个满足要求的 margin 都可以进行折叠形成一个折叠后的 margin（collapsed margin）。<br>并且假如这个折叠后的 margin 是由 margin A 等折叠而来的，如果有 margin X 跟 margin A 是相邻的，则我们也认为 margin X 跟这个折叠后的 margin 相邻。</li></ul><h2 id="折叠后的-margin-大小"><a href="#折叠后的-margin-大小" class="headerlink" title="折叠后的 margin 大小"></a>折叠后的 margin 大小</h2><p>当两个或者两个以上的 margin 折叠后，margin 的值计算如下：</p><ul><li>如果 margin 都是正数，则取他们当中的最大值</li><li>如果 margin 中有正有负，则取最大的正数加上最小的负数（如最大的 margin 是 20px，最小的 margin 是 -20px，则他们计算后的值是 0）</li><li>如果 margin 中都是负数，则取他们当中的最小值</li></ul><h2 id="几道思考题"><a href="#几道思考题" class="headerlink" title="几道思考题"></a>几道思考题</h2><blockquote><p>浮动、定位元素的 margin 不会和其他任何元素的 margin 发生重叠，包括它的子元素。</p></blockquote><p>这是因为浮动元素脱离了正常流，所以它和其他相邻元素就不处与同一个流中，自然不相邻；又因为浮动元素的内容盒会形成一个新的 BFC，所以浮动元素跟子元素不处与同一个 BFC 中，因此它们的 margin 也不能折叠。定位元素同理可得。</p><blockquote><p>inline-block 的元素不会和其他元素的 margin 发生折叠，包括它的子元素。</p></blockquote><p>因为 margin 折叠只会发生在块级元素上，因此 inline-block 元素的 margin 不会和兄弟元素折叠，又因为 inline-block 的内容盒会形成一个新的 BFC，所以 inline-block 元素本身也不会和子元素的 margin 发生折叠</p><h2 id="margin-折叠的几个栗子"><a href="#margin-折叠的几个栗子" class="headerlink" title="margin 折叠的几个栗子"></a>margin 折叠的几个栗子</h2><h3 id="栗子-1"><a href="#栗子-1" class="headerlink" title="栗子 1"></a>栗子 1</h3><blockquote><p>如果两个 margin 满足以下三个条件，我们就说这两个 margin 是相邻（adjoining）的：<br>两个 margin 之间没有行盒（line box）、清除浮动后的空隙（clearance）、padding 和边框</p></blockquote><p>针对这个条件，我们通过增加 padding 的方式来阻止 margin 的折叠：</p><p><img data-src="//img.leense.site/post/2016/03/201603100930-3.png"></p><p>如果 #container 没有下边框，则 #container 的 bottom margin 和 #inner 的 bottom margin 是相邻的，因此它们折叠了，并且 #inner 撑开了 #container 元素，所以可以看到 #container 元素的高度变成了 10px，且显示的是 #inner 的红色背景</p><p><img data-src="//img.leense.site/post/2016/03/201603100930-4.png"></p><p>当给 #container 添加一个下边框，两个 margin 之间就边框的阻隔，他们就不相邻了，因此不能折叠。所以可以看到 #container 被撑开成了 20px，其中 10px 是 #inner 的高度，还有 10px 是 #inner 的 bottom margin，并且由于 margin 是透明的，因此 #container 露出了部分蓝色的背景。</p><h3 id="栗子-2："><a href="#栗子-2：" class="headerlink" title="栗子 2："></a>栗子 2：</h3><blockquote><p>如果两个 margin 满足以下三个条件，我们就说这两个 margin 是相邻（adjoining）的：<br>margin 的两个元素都是正常流的块级元素，并且在同一个 BFC 中</p></blockquote><p>我们通过创建新的 BFC 来阻止 margin 的折叠：</p><p><img data-src="//img.leense.site/post/2016/03/201603100930-5.png"><br><img data-src="//img.leense.site/post/2016/03/201603100930-6.png"></p><p>如上图 #container 元素和 #inner 元素同属于一个 BFC 中，#container 的 top margin 和 #inner 的 top margin 折叠，bottom margin 同理。<br>但如果让 #container 跟 #innter 处在不同的 BFC 中，则 top margin 和 bottom margin 都不会折叠，如：</p><p><img data-src="//img.leense.site/post/2016/03/201603100930-7.png"></p><p>给 #container 元素增加一个 overflow: hidden 属性，让它的内容盒生成一个独立的 BFC，而 #inner 处于这个独立的 BFC 中，因此 #container 和 #inner 就处于两个不同的 BFC 中了，所以他们的 margin 不能折叠。</p><h3 id="栗子-3："><a href="#栗子-3：" class="headerlink" title="栗子 3："></a>栗子 3：</h3><blockquote><p>如果一个元素，它本身的 top margin 和 bottom margin 是相邻的，并且有清除浮动后的空隙（clearance），这个元素的 margin 可以跟兄弟元素的 margin 折叠，但是折叠后的 margin 不能跟父元素的 bottom margin 折叠。</p></blockquote><p><img data-src="//img.leense.site/post/2016/03/201603100930-8.png"></p><p>给父元素 #container 设置了一个灰色背景，并且没有设置高度，因此高度会随着内容而扩展，margin 设置为 50px。<br>其中有一个红色的浮动元素 #floated，高宽都设置为 40px。<br>给 #cleared 设置了 15px 的 margin，并且元素的高度、padding、margin 都为 0，因此 #cleared 元素的 top margin 和 bottom margin 是相邻的。这个元素的位置如下图所示：</p><p><img data-src="//img.leense.site/post/2016/03/201603100930-9.png"></p><p>因为 #cleared 元素清除了左浮动，所以 #cleared 元素下移。<br>而 #cleared 元素和 #slibling 元素的 margin 折叠了，因此可以看到他们的位置是重叠的。</p><p><img data-src="//img.leense.site/post/2016/03/201603100930-10.png"></p><p>由于这条规则的存在，导致他们折叠后的 margin 不能跟 #container 的 bottom margin 进行折叠，因此 #container 的高度被撑开。</p><p>如果没有这条规则，他们还应该跟 #container 的 bottom margin 进行折叠，如：</p><p><img data-src="//img.leense.site/post/2016/03/201603100930-11.png"></p><p>以上这张图，在去掉了 #cleared 元素的 clear 属性之后，就不满足这条规则了，所以可以看到 #container 的高度就只有 40px，即红色的浮动元素的高度，而 #cleared 元素、#sibling 元素、#container 元素的 margin 都折叠成了一个。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章的绝大多数内容都是从官方规范翻译而来，同时也参考也网上一些写的比较好的文章而写的一个介绍性文章，其中有部分内容并没有展开，如 BFC、clearance 等，因为这部分内容不是三言两语就可以解释清楚，我本人也需要进行更深入的学习理解，所以请读者自行查阅相关文章</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.w3.org/TR/CSS2/box.html">https://www.w3.org/TR/CSS2/box.html</a></p><p><a href="https://www.w3.org/TR/CSS2/visuren.html">https://www.w3.org/TR/CSS2/visuren.html</a></p><p><a href="http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html">http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html</a></p><p><a href="https://segmentfault.com/a/1190000003099116">https://segmentfault.com/a/1190000003099116</a></p><p><a href="https://segmentfault.com/a/1190000003096320">https://segmentfault.com/a/1190000003096320</a></p><p><a href="http://melonh.com/css/2015/04/28/understand-margin-collapse.html">http://melonh.com/css/2015/04/28/understand-margin-collapse.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文着重描述关于 margin，我们日常不太容易发现的“坑”。&lt;/p&gt;
&lt;h2 id=&quot;盒模型&quot;&gt;&lt;a href=&quot;#盒模型&quot; class=&quot;headerlink&quot; title=&quot;盒模型&quot;&gt;&lt;/a&gt;盒模型&lt;/h2&gt;&lt;p&gt;接触过 CSS 的人应该都知道 CSS 的盒模型：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;//img.leense.site/post/2016/03/201603100930-1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;由内容边缘（Content edge）包围形成的是内容盒（Content Box），类推还有内边距盒（Padding Box）、边框盒（Border Box）、外边距盒（Margin Box）。&lt;/p&gt;
&lt;p&gt;其中内容盒、内边距盒、边框盒的背景由 background 属性决定，而外边距盒的背景是透明的。&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://laysan.site/categories/Web/"/>
    
    
    <category term="css" scheme="https://laysan.site/tags/css/"/>
    
    <category term="web" scheme="https://laysan.site/tags/web/"/>
    
    <category term="margin" scheme="https://laysan.site/tags/margin/"/>
    
  </entry>
  
</feed>
