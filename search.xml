<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ExtJs4之Grid组件</title>
    <url>/2013/10/extjs4-grid/</url>
    <content><![CDATA[<p>grid表格是extjs的核心组件之一，它提供了展示大量数据的最佳途径。Grid组件的重要特性包括：智能渲染、标准布局、数据视图、特性支持、虚拟滚动和编辑改进，这些特性共同缔造了功能强大的4.0grid组件。</p>
<span id="more"></span>

<p><strong>智能渲染</strong>：在extjs4.0之前的版本中采用了”最小公分母”的策略来支持各种丰富的特性，这种方式会对每一个表格产生大量的标签，而这些标签对于简单表格来说是不必要的，而在4.0中默认的表格只会产生很少的标签，对于复杂的功能采用附加特性的方式实现，这对于提高数据的展示速度和表格的性能起到了巨大的作用。</p>
<p><strong>标准布局</strong>：在ExtJs4.0中改变了原来直接处理内部标签和样式的布局方式，而是将表格划分为不同的组成部分，并使他们有机结合起来，这样就统一了表格和框架的渲染流程。</p>
<p><strong>数据视图</strong>：在ExtJs4.0中新的gridView扩展自标准的DataView数据视图，这不但减少了代码冗余并且可以更简单的进行自定义。</p>
<p><strong>特性支持</strong>：在ExtJs4.0之前的版本可以通过插件或者继承的方式对表格组件的功能进行扩展，但是这种扩展方式很难实现功能的灵活组合。4.0中使用了性的Grid基类Ext.grid.Feature，它提供了灵活定义表格特性的基础，任何Feature类都可以修改表格模版，来装饰或改变grid视图生成的标签。在新的grid类中RowWrap、RowBody和Grouping都是通过Feature方式实现的。</p>
<p><strong>虚拟滚动</strong>：在ExtJs4.0中原生支持了渲染时数据的缓存，提供了一个虚拟的按需加载的数据视图，grid现在可以非常容易地支持几百条甚至几千条数据展示而不需要分页，这大大改进了grid的数据处理能力。</p>
<p><strong>编辑改进</strong>：在ExtJs4.0之前的版本中开发者不得不使用editGrid类来支持表格的编辑功能，这很大程度上限制了程序的灵活性，在ExtJs4.0中提供了全新的编辑插件，它可以应用于任何grid实例。</p>
<h2 id="1、表格面板grid"><a href="#1、表格面板grid" class="headerlink" title="1、表格面板grid"></a>1、表格面板grid</h2><p>grid表格组件实在客户端展示大量数据的优秀途径，可以看作一个增强版的table，它使得获取、排序、过滤、分组、数据变得异常简单。</p>
<p>grid中主要集成了两大部分，分别是用于处理数据的Store和用于渲染的Columns。</p>
<p>下面一个简单的示例最简单的表格配置</p>
<pre><code class="js">Ext.onReady(function()&#123;
        //创建表格数据
        var datas = [
            [100,&#39;张三&#39;,24],
            [200,&#39;李四&#39;,30],
            [300,&#39;王五&#39;,29]
        ];
        //创建Grid表格组件
        Ext.create(&#39;Ext.grid.Panel&#39;,&#123;
            title : &#39;简单Grid表格示例&#39;,
            renderTo: Ext.getBody(),
            width:200,
            height:130,
            frame:true,
            viewConfig: &#123;
                forceFit : true,
                stripeRows: true//在表格中显示斑马线
            &#125;,
            store: &#123;//配置数据源
                fields: [&#39;id&#39;,&#39;name&#39;,&#39;age&#39;],//定义字段
                proxy: &#123;
                    type: &#39;memory&#39;,//Ext.data.proxy.Memory内存代理
                    data : datas,//读取内嵌数据
                    reader : &#39;array&#39;//Ext.data.reader.Array解析器
                &#125;,
                autoLoad: true//自动加载
            &#125;,
            columns: [//配置表格列
                &#123;header: &quot;id&quot;, width: 30, dataIndex: &#39;id&#39;, sortable: true&#125;,
                &#123;header: &quot;姓名&quot;, width: 80, dataIndex: &#39;name&#39;, sortable: true&#125;,
                &#123;header: &quot;年龄&quot;, width: 80, dataIndex: &#39;age&#39;, sortable: true&#125;
            ]
        &#125;);
    &#125;);
</code></pre>
<p>表格组件的主要配置项和方法如下表所示</p>
<p>表1-1 Ext.grid.Panel主要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">columns</td>
<td>Array</td>
<td>一个表格列配置对象的数组，每一个列配置对象都包括了header（列头）和数据来源的定义</td>
</tr>
<tr>
<td align="left">columnLines</td>
<td>Boolean</td>
<td>设置为true则显示纵向表格线，默认为false</td>
</tr>
<tr>
<td align="left">forceFit</td>
<td>Boolean</td>
<td>设置为true则强制列填充满可以利用的空间</td>
</tr>
<tr>
<td align="left">hideHeaders</td>
<td>Boolean</td>
<td>设置为true则隐藏列标题</td>
</tr>
<tr>
<td align="left">scroll</td>
<td>String/Boolean</td>
<td>设置表格滚动条，有效值包括both(垂直和水平滚动),horizontal(水平滚动)和vertical(垂直滚动).true等效于both,false等效none,默认值为true.</td>
</tr>
<tr>
<td align="left">scrollDelta</td>
<td>Number</td>
<td>设置鼠标滚轮滚动事的像素量，默认为40像素</td>
</tr>
<tr>
<td align="left">sorttableColumns</td>
<td>Boolean</td>
<td>设置为false则禁止通过表格中标题中的菜单项排序</td>
</tr>
</tbody></table>
<p>表1-1 Ext.grid.Panel主要方法</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getSelectionModel:Ext.selection.Model</td>
<td>获取选择模式</td>
</tr>
<tr>
<td align="left">getStore:Ext.data.Store</td>
<td>获取表格的数据集</td>
</tr>
<tr>
<td align="left">getView:Ext.view.Table</td>
<td>获取表格的视图对象</td>
</tr>
<tr>
<td align="left">hideHorzontalScroller:void</td>
<td>隐藏水平滚动条</td>
</tr>
<tr>
<td align="left">hideVerticalScroller:void</td>
<td>隐藏垂直滚动条</td>
</tr>
<tr>
<td align="left">scrollByDeltaX(Number deltaX):void</td>
<td>水平滚动表格,正数向右滚动,负数向左滚动,deltaX为滚动像素</td>
</tr>
<tr>
<td align="left">scrollByDeltaY(Number deltaY):void</td>
<td>垂直向下滚动,deltaY为滚动像素</td>
</tr>
<tr>
<td align="left">setScrollTop(Number deltaY):void</td>
<td>垂直向上滚动,deltaY为滚动像素</td>
</tr>
<tr>
<td align="left">showHorzontalScroller:void</td>
<td>显示水平滚动条</td>
</tr>
<tr>
<td align="left">showVerticalScroller:void</td>
<td>显示垂直滚动条</td>
</tr>
</tbody></table>
<h2 id="2、表格列Column"><a href="#2、表格列Column" class="headerlink" title="2、表格列Column"></a>2、表格列Column</h2><p>Ext.grid.column.Column类定义了表格内部与列相关的配置，其中包括列标题和数据展示的相关内容，下表中列出了该类的主要配置项</p>
<p>表2-1Ext.grid.column.Column主要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">align</td>
<td>String</td>
<td>设置列标题和数据的对齐方式，默认为left</td>
</tr>
<tr>
<td align="left">columns</td>
<td>Array</td>
<td>设置组列，数组中的列将作为一组处理，组列不能排序但是可以隐藏和移动，组内的列可以移出组外，当所有的子列都被移出后组列将被自动销毁</td>
</tr>
<tr>
<td align="left">dataIndex</td>
<td>String</td>
<td>设置列与数据集中的数据对应关系，值为数据模型中的字段名称</td>
</tr>
<tr>
<td align="left">draggable</td>
<td>Boolean</td>
<td>设置列头是否可以移动，默认为true</td>
</tr>
<tr>
<td align="left">flex</td>
<td>Number</td>
<td>设置列宽占所有flex和的比例</td>
</tr>
<tr>
<td align="left">groupable</td>
<td>Boolean</td>
<td>设置在使用Ext.grid.feature.Grouping分组特性的情况下是否禁用该列在标题菜单中的分组功能</td>
</tr>
<tr>
<td align="left">header</td>
<td>String</td>
<td>设置列标题</td>
</tr>
<tr>
<td align="left">hideable</td>
<td>Boolean</td>
<td>设置为false则阻止用户隐藏该列，默认为true</td>
</tr>
<tr>
<td align="left">menuDisabled</td>
<td>Boolean</td>
<td>设置为true则禁用标题菜单，默认为fakse</td>
</tr>
<tr>
<td align="left">renderer</td>
<td>Function</td>
<td>设置列的自定义渲染函数</td>
</tr>
<tr>
<td align="left">sortable</td>
<td>Boolean</td>
<td>设置是否允许进行排序，默认为true，它将根据Ext.data.Store.remoteSort判断进行本地排序还是远程排序</td>
</tr>
<tr>
<td align="left">text</td>
<td>String</td>
<td>设置列标题，header配置优先</td>
</tr>
<tr>
<td align="left">width</td>
<td>Number</td>
<td>设置列宽</td>
</tr>
</tbody></table>
<p>Column类有7个便利子类，为常用的数据类型提供了便利的展示方式，他们分别是：</p>
<p>Ext.grid.column.Boolean 布尔列</p>
<p>Ext.grid.column.Number 数字列</p>
<p>Ext.grid.column.Action 动作列</p>
<p>Ext.grid.column.Template 模版列</p>
<p>Ext.grid.RowNumber 行号列</p>
<p>Ext.tree.Column 树结构列（后面介绍）</p>
<h3 id="2-1-布尔列Ext-grid-column-Boolean"><a href="#2-1-布尔列Ext-grid-column-Boolean" class="headerlink" title="2.1 布尔列Ext.grid.column.Boolean"></a>2.1 布尔列Ext.grid.column.Boolean</h3><p>Ext.grid.column.Boolean 定义了在表格列中显示布尔值的方式</p>
<p>表2-2 Ext.grid.column.Boolean只要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">falseText</td>
<td>String</td>
<td>设置渲染false值对应的文本，默认为false</td>
</tr>
<tr>
<td align="left">trueText</td>
<td>String</td>
<td>设置渲染true值对应的文本，默认为true</td>
</tr>
<tr>
<td align="left">undefinedText</td>
<td>String</td>
<td>设置渲染undefined值对应的文本，默认为空字符串</td>
</tr>
</tbody></table>
<h3 id="2-2-数字列Ext-grid-column-Number"><a href="#2-2-数字列Ext-grid-column-Number" class="headerlink" title="2.2 数字列Ext.grid.column.Number"></a>2.2 数字列Ext.grid.column.Number</h3><p>Ext.grid.column.Number 定义了在表格中展示数字值的方式。</p>
<p>配置项format，参数类型String，设置Ext.util.Format.number函数格式化字符串，默认为0，000.00</p>
<h3 id="2-3-日期列Ext-grid-column-Date"><a href="#2-3-日期列Ext-grid-column-Date" class="headerlink" title="2.3 日期列Ext.grid.column.Date"></a>2.3 日期列Ext.grid.column.Date</h3><p>format String 设置Date.format函数的格式化字符串，默认为Ext.data.defaultFormat</p>
<p>示例代码：</p>
<pre><code class="js">   Ext.onReady(function()&#123;
    //创建表格数据
    var datas = [
        [&#39;张三&#39;,true,new Date(1979,09,13),2500],
        [&#39;李四&#39;,false,new Date(1978,10,01),1500],
        [&#39;王五&#39;,false,new Date(1981,01,01),1000]
    ];
    //创建Grid表格组件
    Ext.create(&#39;Ext.grid.Panel&#39;,&#123;
        title : &#39;Ext.grid.column.Column示例&#39;,
        renderTo: Ext.getBody(),
        width:300,
        height:150,
        frame:true,
        store: &#123;
            fields: [&#39;name&#39;,&#39;leader&#39;,&#39;birthday&#39;,&#39;salary&#39;],
            proxy: &#123;
                type: &#39;memory&#39;,
                data : datas,
                reader : &#39;array&#39;//Ext.data.reader.Array解析器
            &#125;,
            autoLoad: true
        &#125;,
        columns: [//配置表格列
            &#123;header: &quot;姓名&quot;, width: 50, dataIndex: &#39;name&#39;&#125;,
            &#123;header: &quot;组长&quot;, width: 50, dataIndex: &#39;leader&#39;,
                xtype: &#39;booleancolumn&#39;,//Ext.grid.column.Boolean布尔列
                trueText: &#39;是&#39;,
                falseText: &#39;否&#39;
            &#125;,
            &#123;header: &quot;生日&quot;, width: 100, dataIndex: &#39;birthday&#39;,
                xtype : &#39;datecolumn&#39;,//Ext.grid.column.Date日期列
                format : &#39;Y年m月d日&#39;//日期格式化字符串
            &#125;,
            &#123;header: &quot;薪资&quot;, width: 50, dataIndex: &#39;salary&#39;,
                xtype: &#39;numbercolumn&#39;,//Ext.grid.column.Number数字列
                format:&#39;0,000&#39;//数字格式化字符串
            &#125;
        ]
    &#125;);
&#125;);
</code></pre>
<h3 id="2-4-动作列-Ext-grid-column-Action"><a href="#2-4-动作列-Ext-grid-column-Action" class="headerlink" title="2.4 动作列 Ext.grid.column.Action"></a>2.4 动作列 Ext.grid.column.Action</h3><p>Ext.grid.column.Action 将渲染一个图标或一系列图标到表格的单元格中，并为每一个图标创建响应函数。</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">altText</td>
<td>String</td>
<td>设置应用于image元素上的alt属性，默认为空字符串</td>
</tr>
<tr>
<td align="left">getClass</td>
<td>Function</td>
<td>设置返回图标样式的函数</td>
</tr>
<tr>
<td align="left">handler</td>
<td>Function</td>
<td>设置图标点击事件的响应函数，该函数将被传入以下参数：view：TableView 表格视图 ,rowIndex：Number 行索引 ,colIndex:Number 列索引 ,item：Object 条目 ,e：Event点击事件对象</td>
</tr>
<tr>
<td align="left">icon</td>
<td>String</td>
<td>获取图标资源的url地址，默认为Ext.BLANK_IMAGE_URL</td>
</tr>
<tr>
<td align="left">iconCls</td>
<td>String</td>
<td>设置应用于图标的样式</td>
</tr>
<tr>
<td align="left">items</td>
<td>Array</td>
<td>包含多个图标定义的数组</td>
</tr>
<tr>
<td align="left">scope</td>
<td>Object</td>
<td>设置handler和getClass函数的作用域，默认为Column</td>
</tr>
<tr>
<td align="left">stopSelection</td>
<td>Boolean</td>
<td>默认为true阻止当动作发生时，当前行被选中</td>
</tr>
<tr>
<td align="left">tooltip</td>
<td>String</td>
<td>设置工具提示信息，需要初始化Ext.tip.QuickTipManager</td>
</tr>
</tbody></table>
<p>示例代码</p>
<pre><code class="js">    &#123;header: &quot;操作&quot;, width: 70,
    xtype: &#39;actioncolumn&#39;,//Ext.grid.column.Action动作列
    items: [&#123;
        icon: &#39;images/edit.gif&#39;,//指定编辑图标资源的URL
        handler: function(grid, rowIndex, colIndex) &#123;
            //获取被操作的数据记录
            var rec = grid.getStore().getAt(rowIndex);
            alert(&quot;编辑 &quot; + rec.get(&#39;name&#39;));
        &#125;
    &#125;,&#123;
        icon: &#39;images/del.gif&#39;,//指定编辑图标资源的URL
        handler: function(grid, rowIndex, colIndex) &#123;
            var rec = grid.getStore().getAt(rowIndex);
            alert(&quot;删除 &quot; + rec.get(&#39;name&#39;));
        &#125;                
    &#125;,&#123;
        icon: &#39;images/save.gif&#39;,//指定编辑图标资源的URL
        handler: function(grid, rowIndex, colIndex) &#123;
            var rec = grid.getStore().getAt(rowIndex);
            alert(&quot;保存 &quot; + rec.get(&#39;name&#39;));
        &#125;                
    &#125;]

&#125;
</code></pre>
<h3 id="2-5-模板列-Ext-grid-column-Template"><a href="#2-5-模板列-Ext-grid-column-Template" class="headerlink" title="2.5 模板列 Ext.grid.column.Template"></a>2.5 模板列 Ext.grid.column.Template</h3><p>Ext.grid.column.Template提供了通过模版渲染单元格内容的方式</p>
<p>tpl String/XTemplate 设置一个XTemplate模版对象或模版定义，模版数据将被传入其中</p>
<pre><code class="js">&#123;
    header: &quot;描述&quot;, width: 100,
    xtype: &#39;templatecolumn&#39;,//Ext.grid.column.Template数字列
    tpl : &#39;&#123;name&#125;&lt;tpl if=&quot;leader == false&quot;&gt;不&lt;/tpl&gt;是组长&#39;
&#125;
</code></pre>
<h3 id="2-6-行号列-Ext-grid-RowNumber"><a href="#2-6-行号列-Ext-grid-RowNumber" class="headerlink" title="2.6 行号列 Ext.grid.RowNumber"></a>2.6 行号列 Ext.grid.RowNumber</h3><p>text String 设置显示在标题中的文本或html代码段，默认值为&amp;#160</p>
<p>width Number 设置行号列的宽度，默认为23像素</p>
<h3 id="2-7-自定义渲染函数"><a href="#2-7-自定义渲染函数" class="headerlink" title="2.7 自定义渲染函数"></a>2.7 自定义渲染函数</h3><p>单元格渲染函数renderer是表格列的一项重要内容，可用来处理表格中的原始值，并将格式化后的结果返回，返回值决定了数据在单元格中的表现形式。灵活使用该函数可以实现个性化的数据展示效果。传入自定义渲染函数的参数有：</p>
<p>value：Mixed 当前单元格的值</p>
<p>metadata：Object 包含当前单元格信息的数据对象，由于设置单元格的样式和属性，该对象包含的属性有：</p>
<blockquote>
<p>tdCls：String 应用到单元格TD元素上的样式名称</p>
<p>tdAttr： String 一个html属性定义字符串</p>
<p>style：String 应用到单元格TD元素上的样式字符串</p>
</blockquote>
<p>record：Ext.data.Model 当前数据记录对象，其中包含了与该单元格处于同一行的其他列的数据。</p>
<p>rowIndex： Number 当前单元格的行索引</p>
<p>colInde： Number 列索引</p>
<p>store ：Ext.data.Store 包含表格所有数据的数据集对象</p>
<p>view：Ext.view.View 当前的表格视图。</p>
<h2 id="3、选择模式Selection"><a href="#3、选择模式Selection" class="headerlink" title="3、选择模式Selection"></a>3、选择模式Selection</h2><p>选择模式用来处理数据视图中记录的选择状态，Ext.selection.Model是选择模式的基类，它的子类包括Ext.selection.CellModel（单元格选择模式），Ext.selection.CheckboxModel（复选框选择模式）和Ext.selection.RowModel（行选择模式）。</p>
<h3 id="3-1-选择模式Ext-selection-Model"><a href="#3-1-选择模式Ext-selection-Model" class="headerlink" title="3.1 选择模式Ext.selection.Model"></a>3.1 选择模式Ext.selection.Model</h3><p>Ext.selection.Model是选择模式的基类，它定义了子类需要实现的接口，这个类不能直接被创建。</p>
<p>表3-1 Ext.selection.Model主要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">allowDeselect</td>
<td>Boolean</td>
<td>设置是否允许用户在数据视图中执行撤选操作，该配置只在single单选模式下生效，默认为false</td>
</tr>
<tr>
<td align="left">mode</td>
<td>String</td>
<td>设置选择模式，有效值包括 SINGLE 单选，SIMPLE简单选择和MULTI多选，默认为SINGLE单选</td>
</tr>
</tbody></table>
<p>表3-2 Ext.selection.Model 主要方法</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">delslect(Ext.data.Model/Index records,Boolean supressEvent):void</td>
<td>执行撤选操作，records 数据记录或索引的数组，suppressEvent 是否抑制select事件</td>
</tr>
<tr>
<td align="left">getLastSelected : Object</td>
<td>获取最近选择的记录数组</td>
</tr>
<tr>
<td align="left">getSelection: Array</td>
<td>获取当前选中的记录数组</td>
</tr>
<tr>
<td align="left">getSleectionMode: String</td>
<td>获取当前的选择模式</td>
</tr>
<tr>
<td align="left">hasSelect: Boolean</td>
<td>获取是否有记录在被选择的状态</td>
</tr>
<tr>
<td align="left">isFocused(Object rec):void</td>
<td>检查指定记录是否为最近选中的记录</td>
</tr>
<tr>
<td align="left">isLocked(): Boolean</td>
<td>取得当前选择区域是否被锁定</td>
</tr>
<tr>
<td align="left">isSelected(Record/Number record): Boolean</td>
<td>检查指定记录是否被选中</td>
</tr>
<tr>
<td align="left">select(Model/Index records ,Boolean keepExiting ,Boolean suppressEvent) : void</td>
<td>选中记录 records 数据记录或索引的数组，keepExisting 保持，suppressEvent 是否抑制select事件</td>
</tr>
<tr>
<td align="left">selectRange(Model/Number startRow,Model/Number endRow , [Boolean keepExisting],Object dir): void</td>
<td>选择范围内的所有行，startRow 开始索引，endRow 结束索引，keepExisting： true表示保持已有的选择，false则取消已有的选择</td>
</tr>
<tr>
<td align="left">setLocked(Boolean locaked) : void</td>
<td>设置是否锁定当前的选择状态，locked：true表示锁定，false解锁</td>
</tr>
</tbody></table>
<h3 id="3-2-单元格选择模式-Ext-selection-CellModel"><a href="#3-2-单元格选择模式-Ext-selection-CellModel" class="headerlink" title="3.2 单元格选择模式 Ext.selection.CellModel"></a>3.2 单元格选择模式 Ext.selection.CellModel</h3><p>Ext.selection.CellModel是一个简单的选择模式，用于选择表格中的单一单元格。</p>
<p>getCurrentPosition(): Object 得到当前选择的单元格，如果没有选择单元格则返回null</p>
<p>selectByPosition(pos) :void 选中指定位置的单元格，pos为位置信息，格式为{row:2,column:2}</p>
<h3 id="3-3-行选择模式-Ext-selection-RowModel"><a href="#3-3-行选择模式-Ext-selection-RowModel" class="headerlink" title="3.3 行选择模式 Ext.selection.RowModel"></a>3.3 行选择模式 Ext.selection.RowModel</h3><p>表3-3 Ext.selection.RowModel主要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">enableKeyNav</td>
<td>Boolean</td>
<td>设置是否启用键盘导航，默认为true</td>
</tr>
<tr>
<td align="left">simpleSelect</td>
<td>Boolean</td>
<td>设置在行选择模式下是否启用简单选择模式，如果启用则不需要按下crtl键只需通过鼠标点击就可以实现多选</td>
</tr>
<tr>
<td align="left">multiSelect</td>
<td>Boolean</td>
<td>设置在行选择模式下是否支持多选</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<pre><code class="js">simpleSelect : true,//启用简单选择功能
multiSelect : true,//支持多选
selType: &#39;rowmodel&#39;,//设置为单元格选择模式Ext.selection.RowModel
tbar : [&#123;
    text : &#39;取得所选行&#39;,
    handler : function()&#123;
        var msg = &#39;&#39;;
        var rows = grid.getSelectionModel().getSelection();
        for(var i = 0; i &lt; rows.length; i++)&#123;
            msg = msg + rows[i].get(&#39;name&#39;) + &#39;\n&#39;;
        &#125;
        alert(msg);
    &#125;
&#125;]
</code></pre>
<h3 id="3-4-复选框选择模式-Ext-selection-CheckboxModel"><a href="#3-4-复选框选择模式-Ext-selection-CheckboxModel" class="headerlink" title="3.4 复选框选择模式 Ext.selection.CheckboxModel"></a>3.4 复选框选择模式 Ext.selection.CheckboxModel</h3><p>Ext.selection.CheckboxModel扩展自Ext.selection.RowModel 其配置项如下;</p>
<p>checkOnly Boolean 设置为true则只能通过点击checkbox列进行选择，默认为false</p>
<p>injectCheckbox Mixed 设置注入复选框的位置，有效值可以是一个数字，false，会字符串first，last，默认为0</p>
<p>需要注意的是，Ext.selection.CheckboxModel没有注册selection命名空间下的别名，导致不能直接使用，因此需要编写别名注册代码，示例如下：</p>
<pre><code class="js">//注册复选框选择模式别名为selection.checkboxmodel
Ext.ClassManager.setAlias(&#39;Ext.selection.CheckboxModel&#39;,&#39;selection.checkboxmodel&#39;);
multiSelect : true,//支持多选
selModel: &#123;
    elType : &#39;checkboxmodel&#39;//复选框选择模式Ext.selection.CheckboxModel
&#125;
</code></pre>
<h2 id="4、表格特性-Feature"><a href="#4、表格特性-Feature" class="headerlink" title="4、表格特性 Feature"></a>4、表格特性 Feature</h2><p>Ext.grid.feature.Feature是一类针对Ext.grid.Panel的特殊插件，它提供了一些扩展点。其子类包括：</p>
<p>Ext.grid.feature.RowBody 表格行体</p>
<p>Ext.grid.feature.Summary 表格汇总</p>
<p>Ext.grid.feature.Grouping 表格分组</p>
<p>Ext.grid.feature.GroupingSummary 分组汇总</p>
<h3 id="4-1-表格行体-Ext-grid-feature-RowBody"><a href="#4-1-表格行体-Ext-grid-feature-RowBody" class="headerlink" title="4.1 表格行体 Ext.grid.feature.RowBody"></a>4.1 表格行体 Ext.grid.feature.RowBody</h3><p>行体特性为表格追加了tr标签，它跨越了原始表格的所有列。该特性在表格中展示一些描述性的特殊信息时非常有用，行体在默认状态下是隐藏的，如果需要展示行体必须覆盖geyAdditionalData方法。</p>
<p>使用行体会自动在表格视图中暴露已rowbody为前缀的事件，示例如下：</p>
<pre><code class="js">features: [Ext.create(&#39;Ext.grid.feature.RowBody&#39;,&#123;
    getAdditionalData: function(data, idx, record, orig) &#123;
        var headerCt = this.view.headerCt,
            colspan  = headerCt.getColumnCount();//获取表格的列数

        return &#123;
            rowBody: record.get(&#39;introduce&#39;),//指定行体内容
            rowBodyCls: &#39;rowbodyColor&#39;,//指定行体样式
            rowBodyColspan: colspan//指定行体跨列的列数
        &#125;;
    &#125;
&#125;)]
</code></pre>
<h3 id="4-2-表格汇总-Ext-grid-feature-Summary"><a href="#4-2-表格汇总-Ext-grid-feature-Summary" class="headerlink" title="4.2 表格汇总 Ext.grid.feature.Summary"></a>4.2 表格汇总 Ext.grid.feature.Summary</h3><p>表格汇总特性将在表格的底部显示一个汇总行，关于汇总行有2点需要注意：</p>
<p>1、汇总值的计算，汇总值需要根据表格的每一列进行计算，计算方式通过column中的summaryType配置项进行指定，内置的汇总计算类型包括：count 计数；sum 求和；min 最小值；max 最大值；average 平均值。</p>
<p>2、汇总值的渲染，与column的渲染方式相同，汇总值的渲染支持summaryRenderer函数，该函数是可选的，传入函数的参数有：</p>
<p>value{Object}:合计值</p>
<p>data{Objject}:包含所有合计值的行数据</p>
<p>field{String}:进行求和计算的字段名</p>
<p>示例代码：</p>
<pre><code class="js">Ext.onReady(function()&#123;
        //创建表格数据
        var datas = [
            [&#39;张三&#39;,2500],
            [&#39;李四&#39;,1500]
        ];
        //创建Grid表格组件
        Ext.create(&#39;Ext.grid.Panel&#39;,&#123;
            title : &#39;Ext.grid.feature.Summary示例&#39;,
            renderTo: Ext.getBody(),
            width:300,
            height:150,
            frame:true,
            store: &#123;
                fields: [&#39;name&#39;,&#39;salary&#39;,&#39;introduce&#39;],
                proxy: &#123;
                    type: &#39;memory&#39;,
                    data : datas,
                    reader : &#39;array&#39;//Ext.data.reader.Array解析器
                &#125;,
                autoLoad: true
            &#125;,
            features: [&#123;
                ftype: &#39;summary&#39;//Ext.grid.feature.Summary表格汇总特性
            &#125;],
            columns: [//配置表格列
                &#123;header: &quot;姓名&quot;, flex: 1, dataIndex: &#39;name&#39;,
                    summaryType: &#39;count&#39;,//求数量
                    summaryRenderer: function(value)&#123;
                        return &#39;员工总数：&#39;+value
                    &#125;
                &#125;,
                &#123;header: &quot;薪资&quot;, flex: 1, dataIndex: &#39;salary&#39;,
                    summaryType: &#39;average&#39;,//求平均值
                    summaryRenderer: function(value)&#123;
                        return &#39;平均薪资：&#39;+value
                    &#125;
                &#125;
            ]
        &#125;);
    &#125;);
</code></pre>
<h3 id="4-3-表格分组-Ext-grid-feature-Grouping"><a href="#4-3-表格分组-Ext-grid-feature-Grouping" class="headerlink" title="4.3 表格分组 Ext.grid.feature.Grouping"></a>4.3 表格分组 Ext.grid.feature.Grouping</h3><p>表格分组特性将表格按照分组的方式进行聚合展示，在每一个分组标题之下展示与之匹配的数据记录，分组之后的数据可以展开或收缩，该特性有以下3点需要注意的地方：</p>
<p><strong>新增事件</strong>：包括 groupclick、groupdblclick、groupcontextmenu、groupexpand、groupcollapse。</p>
<p><strong>标题栏扩展</strong>：标题菜单中会增加分组相关功能，通过enableGroupingMenu配置项来控制该功能是否启用。</p>
<p><strong>定义分组标题</strong>：功过groupHeaderTpl可以定义分组标题显示模版。</p>
<p>表4-1Ext.grid.feature.Grouping 主要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">depthToIndent</td>
<td align="left">Number</td>
<td>设置分组数据的缩进，默认为17像素</td>
</tr>
<tr>
<td align="left">enableGroupingMenu</td>
<td align="left">Boolean</td>
<td>设置是否启用标题菜单中的分组功能，默认为true</td>
</tr>
<tr>
<td align="left">enableNoGroups</td>
<td align="left">Boolean</td>
<td>设置是否允许用户关闭分组，默认为true</td>
</tr>
<tr>
<td align="left">groupByText</td>
<td align="left">String</td>
<td>设置显示在分组菜单中的分组功能名称，默认为group By This Field</td>
</tr>
<tr>
<td align="left">groupHeaderTpl</td>
<td align="left">String</td>
<td>设置分组标题模板，默认为Group:{name}</td>
</tr>
<tr>
<td align="left">hideGroupedHeader</td>
<td align="left">Boolean</td>
<td>设置是否隐藏分组标题，默认为false</td>
</tr>
<tr>
<td align="left">showGroupsText</td>
<td align="left">String</td>
<td>设置标题菜单中是否分组显示文字说明，默认为 show in groups</td>
</tr>
<tr>
<td align="left">startCollapsed</td>
<td align="left">Boolean</td>
<td>设置分组是否默认收缩，默认为false</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<pre><code class="js">Ext.onReady(function()&#123;
        //创建表格数据
        var datas = [
            [&#39;张三&#39;,&#39;男&#39;,29],[&#39;李四&#39;,&#39;女&#39;,30],
            [&#39;王五&#39;,&#39;男&#39;,27],[&#39;赵六&#39;,&#39;女&#39;,31]
        ];
        //创建Grid表格组件
        Ext.create(&#39;Ext.grid.Panel&#39;,&#123;
            title : &#39;Ext.grid.feature.Grouping示例&#39;,
            renderTo: Ext.getBody(),
            width:300,
            height:150,
            frame:true,
            store: &#123;
                fields: [&#39;name&#39;,&#39;sex&#39;,&#39;age&#39;],
                groupField: &#39;sex&#39;,//设置分组字段
                proxy: &#123;
                    type: &#39;memory&#39;,
                    data : datas,
                    reader : &#39;array&#39;//Ext.data.reader.Array解析器
                &#125;,
                autoLoad: true
            &#125;,
            features: [Ext.create(&#39;Ext.grid.feature.Grouping&#39;, &#123;
                groupByText : &#39;用本字段分组&#39;,
                showGroupsText : &#39;显示分组&#39;,
                groupHeaderTpl: &#39;性别: &#123;name&#125; (&#123;rows.length&#125;)&#39;, //分组标题模版
                startCollapsed: true //设置初始分组是否收起
            &#125;)],
            columns: [//配置表格列
                &#123;header: &quot;姓名&quot;, flex: 1, dataIndex: &#39;name&#39;&#125;,
                &#123;header: &quot;性别&quot;, flex: 1, dataIndex: &#39;sex&#39;&#125;,
                &#123;header: &quot;年龄&quot;, flex: 1, dataIndex: &#39;age&#39;&#125;
            ]
        &#125;);
    &#125;);
</code></pre>
<h3 id="4-4-分组汇总-Ext-grid-feature-GroupingSummary"><a href="#4-4-分组汇总-Ext-grid-feature-GroupingSummary" class="headerlink" title="4.4 分组汇总 Ext.grid.feature.GroupingSummary"></a>4.4 分组汇总 Ext.grid.feature.GroupingSummary</h3><p>分组汇总特性结合了Grouping分组和summary汇总两个特性的特点，它在每一个分组下增加一行显示汇总数据，其相关配置可以参考Grouping和summary的配置项。</p>
<h2 id="5、表格插件plugin"><a href="#5、表格插件plugin" class="headerlink" title="5、表格插件plugin"></a>5、表格插件plugin</h2><p>为了扩展表格组件已有功能，除了前面介绍的特性之外，extjs还提供了表格的扩展插件，通过插件实现表格的编辑，拖拽等功能。</p>
<p>单元格编辑插件：Ext.grid.plugin.CellEditing</p>
<p>行编辑插件：Ext.grid.plugin.RowEditing</p>
<p>拖拽插件： Ext.grid.plugin.DragDrop</p>
<h3 id="5-1-单元格编辑插件-Ext-grid-plugin-CellEditing"><a href="#5-1-单元格编辑插件-Ext-grid-plugin-CellEditing" class="headerlink" title="5.1 单元格编辑插件 Ext.grid.plugin.CellEditing"></a>5.1 单元格编辑插件 Ext.grid.plugin.CellEditing</h3><p>Ext.grid.plugin.CellEditing插件为grid组件注入了单元格级别的编辑功能，同一时间只能有一个单元格处于编辑状态，表单字段作为编辑器，如果表格中的某列没有指定编辑器则该列不能被编辑。其主要配置项如下：</p>
<p>clicksToEdit Number 设置点击单元格进入编辑模式的点击次数，默认为2</p>
<p>示例代码如下：</p>
<pre><code class="js">Ext.onReady(function()&#123;
        //初始化提示信息
        Ext.QuickTips.init();
        //创建表格数据
        var datas = [
            [&#39;张三&#39;,new Date(1979,09,13),2500],
            [&#39;李四&#39;,new Date(1978,10,01),1500],
            [&#39;王五&#39;,new Date(1981,01,01),1000]
        ];
        //创建Grid表格组件
        Ext.create(&#39;Ext.grid.Panel&#39;,&#123;
            title : &#39;Ext.grid.plugin.CellEditing示例&#39;,
            renderTo: Ext.getBody(),
            width:300,
            height:150,
            frame:true,
            store: &#123;
                fields: [&#39;name&#39;,&#39;birthday&#39;,&#39;salary&#39;],
                proxy: &#123;
                    type: &#39;memory&#39;,
                    data : datas,
                    reader : &#39;array&#39;//Ext.data.reader.Array解析器
                &#125;,
                autoLoad: true
            &#125;,
            plugins: [
                Ext.create(&#39;Ext.grid.plugin.CellEditing&#39;, &#123;
                    clicksToEdit: 1//设置鼠标单击1次进入编辑状态
                &#125;)
            ],
            selType: &#39;cellmodel&#39;,//设置为单元格选择模式
            columns: [//配置表格列
              Ext.create(&#39;Ext.grid.RowNumberer&#39;,&#123;text : &#39;行号&#39;, width : 35&#125;),
              &#123;header: &quot;姓名&quot;, width: 50, dataIndex: &#39;name&#39;,
                    editor: &#123;//文本字段
                        xtype:&#39;textfield&#39;,
                        allowBlank:false
                    &#125;
                &#125;,
                &#123;header: &quot;生日&quot;, width: 100, dataIndex: &#39;birthday&#39;,
                    xtype : &#39;datecolumn&#39;,//Ext.grid.column.Date日期列
                    format : &#39;Y年m月d日&#39;,//日期格式化字符串
                    editor: &#123;//日期字段
                        xtype:&#39;datefield&#39;,
                        allowBlank:false
                    &#125;
                &#125;,
                &#123;header: &quot;薪资&quot;, width: 50, dataIndex: &#39;salary&#39;,
                    xtype: &#39;numbercolumn&#39;,//Ext.grid.column.Number数字列
                    format:&#39;0,000&#39;,//数字格式化字符串
                    editor: &#123;//数字字段
                        xtype:&#39;numberfield&#39;,
                        allowBlank:false
                    &#125;
                &#125;
            ]
        &#125;);
    &#125;);
</code></pre>
<p>保存编辑后的数据有2中基本方式</p>
<p>1.监听表格的edit事件，在每一次编辑后该事件都会触发，在事件处理函数中奖修改后的数据保存到服务器中，例如：</p>
<pre><code class="js">grid.on(&#39;edit&#39;,onEdit,this);
function onEdit(e)&#123;
    //执行ajax请求将数据提交至服务器
    e.record.commit();
&#125;;
</code></pre>
<p>2、建立单独的数据保存处理函数，该函数有用户决定何时触发，在函数中获取所有修改过的表格数据，一次性将多条修改后的数据同步到服务器。</p>
<h3 id="5-2-行编辑插件：Ext-grid-plugin-RowEditing"><a href="#5-2-行编辑插件：Ext-grid-plugin-RowEditing" class="headerlink" title="5.2 行编辑插件：Ext.grid.plugin.RowEditing"></a>5.2 行编辑插件：Ext.grid.plugin.RowEditing</h3><p>Ext.grid.plugin.RowEditing为grid组件注入了行级别的编辑功能，编辑开始时会显示一个小的浮动面板，每一个配置了编辑器的表格列都将以字段的形式显示在面板上，没有配置编辑器的列将以文本的形式显示在面板中。其配置项有</p>
<p>autoCancel Boolean 设置在切换所编辑的行时是否自动取消任何未确定的数据修改，默认为true。</p>
<p>clicksToMoveEditor Number 设置编辑器移动到新行鼠标需要点击的次数，默认同clicksToEdit的值一致</p>
<p>errorSummary Boolean 设置是否显示一个展开所有字段验证信息的工具提示，默认为true</p>
<p>修改上节的代码，将编辑器模式切换为行编辑模式。</p>
<pre><code class="js">plugins: [
//行编辑模式
Ext.create(&#39;Ext.grid.plugin.RowEditing&#39;, &#123;
clicksToEdit: 1
&#125;)
]
</code></pre>
<h3 id="5-3-拖拽插件：-Ext-grid-plugin-DragDrop"><a href="#5-3-拖拽插件：-Ext-grid-plugin-DragDrop" class="headerlink" title="5.3 拖拽插件： Ext.grid.plugin.DragDrop"></a>5.3 拖拽插件： Ext.grid.plugin.DragDrop</h3><p>Ext.grid.plugin.DragDrop 插件为表格视图提供了拖放功能，它自动创建了特殊的DragZone和Ext.dd.DropZone实例来协作完成拖放功能。</p>
<p>ddGroup String 设置拖放组名称，拖放操作只能在相同的组内进行，默认为TreeDD</p>
<p>dragGroop String 设置拖拽组名称</p>
<p>dropGroup String 设置释放组名称</p>
<p>enableDrag Boolean 设置是否启用拖动功能，默认为true</p>
<p>enableDrop Boolean 设置是否启用释放功能，默认为true</p>
<p>示例代码：</p>
<p>grid1：</p>
<pre><code class="js">viewConfig: &#123;
plugins: [
    //行编辑模式
    Ext.create(&#39;Ext.grid.plugin.DragDrop&#39;,&#123;
        dragGroup: &#39;grid1&#39;,//拖拽组名称
        dropGroup: &#39;grid2&#39;//拖放组名称
    &#125;)
]
&#125;
</code></pre>
<p>grid2：</p>
<pre><code class="js">viewConfig: &#123;
plugins: [
    //行编辑模式
    Ext.create(&#39;Ext.grid.plugin.DragDrop&#39;,&#123;
        dragGroup: &#39;grid2&#39;,//拖拽组名称
        dropGroup: &#39;grid1&#39;//拖放组名称
    &#125;)
]
&#125;
</code></pre>
<h2 id="6、表格分页"><a href="#6、表格分页" class="headerlink" title="6、表格分页"></a>6、表格分页</h2><p>当表格数据量比较大时，对数据进行分页显示是常见的处理方法，在extjs中分页只需要引入分业工具栏Ext.toolbar.Paging就可以实现基本的分页功能。示例如下：</p>
<pre><code class="js">Ext.onReady(function()&#123;
        var itemsPerPage = 2;//指定分页大小

        var store = Ext.create(&#39;Ext.data.Store&#39;, &#123;
            autoLoad: &#123;start: 0, limit: itemsPerPage&#125;,
            fields:[&#39;id&#39;, &#39;name&#39;, &#39;age&#39;],
            pageSize: itemsPerPage, //设置分页大小
            proxy: &#123;
                type: &#39;ajax&#39;,
                url: &#39;jsonServer.jsp&#39;,  //请求的服务器地址
                reader: &#123;
                    type: &#39;json&#39;,
                    root: &#39;rows&#39;,
                    totalProperty: &#39;results&#39;
                &#125;
            &#125;
        &#125;);
        //创建Grid表格组件
        Ext.create(&#39;Ext.grid.Panel&#39;,&#123;
            title : &#39;Ext.toolbar.Paging示例&#39;,
            renderTo: Ext.getBody(),
            width:400,
            height:150,
            frame:true,
            store: store,
            columns: [//配置表格列
                &#123;header: &quot;id&quot;, width: 30, dataIndex: &#39;id&#39;, sortable: true&#125;,
                &#123;header: &quot;姓名&quot;, width: 80, dataIndex: &#39;name&#39;, sortable: true&#125;,
                &#123;header: &quot;年龄&quot;, width: 80, dataIndex: &#39;age&#39;, sortable: true&#125;
            ],
            bbar: [&#123;
                xtype: &#39;pagingtoolbar&#39;,
                store: store,   //这里需要指定与表格相同的store
                displayInfo: true，
                displayMsg: &#39;显示第 &#123;0&#125; 条到 &#123;1&#125; 条记录，一共 &#123;2&#125; 条&#39;,
         emptyMsg: &quot;当前查询条件无数据,请重新查询&quot;

            &#125;]
        &#125;);
    &#125;);
</code></pre>
<p>服务器端返回的数据格式为:</p>
<p><code>&#123;results:6,rows:[&#123;id:0,name:&#39;tom&#39;,age:24&#125;,&#123;id:1,name:&#39;jack&#39;,age:18&#125;]&#125;</code></p>
<p>最后附上本篇的源代码：[点击这里下载](/attach/Extjs-grid.zip)</p>
]]></content>
      <categories>
        <category>ExtJs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
        <tag>grid</tag>
        <tag>表格</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub Pages 搭建</title>
    <url>/2013/10/github-pages/</url>
    <content><![CDATA[<p>我写这篇文章的目的是记录本博客的搭建过程，自己从零开始逐步搭建起来了GitHub Pages，其中借鉴了很多的博客和模版，稍后会在后面列出，也为没有用过gihub和jekyll的童鞋提供一点帮助。</p>
<p>学习使用github网页的最好办法就是clone别人的代码，看懂他们的代码，并修改成自己喜欢的样子。这篇文章介绍了windows下从最初安装软件到使用的过程。</p>
<span id="more"></span>
<p>下面开始一步步讲解Github Pages的使用流程：</p>
<h2 id="一、安装git工具"><a href="#一、安装git工具" class="headerlink" title="一、安装git工具"></a>一、安装git工具</h2><p>下载安装 <a href="http://code.google.com/p/msysgit/downloads/list">Git for Windows</a>（选择下载类似于 Git-1.7.*-preview.exe 的文件）<br>打开安装好的 Git Bash，依次输入：<br><code>git config --global user.name &quot;your username&quot; git config --global user.email &quot;username@email.com&quot;</code><br>请确保 name 和 email 信息与在 GitHub 注册时的信息相符。<br>紧接着创建一个 SSH Public Keys，输入：<br><code>ssh-keygen -t rsa -C &quot;username@email.com&quot;</code><br>回车后，你会看到类似画面：</p>
<pre><code>Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/Tekkub/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /c/Users/Tekkub/.ssh/id_rsa.
Your public key has been saved in /c/Users/Tekkub/.ssh/id_rsa.pub.
The key fingerprint is:
e8:ae:60:8f:38:c2:98:1d:6d:84:60:8c:9e:dd:47:81 tekkub@gmail.com
</code></pre>
<p>此时，你需要的 SSH Public Keys 就保存在 <code>id_rsa.pub</code> 文件中，找到并打开它，将里面的代码复制到<a href="https://github.com/account#ssh_bucket">Account Settings</a> 的相应区域。<br>后面就轻松多了，因为，除非重装系统或换新机器，你都不必再重复操作以上步骤。</p>
<h2 id="二、在windows下安装ruby环境"><a href="#二、在windows下安装ruby环境" class="headerlink" title="二、在windows下安装ruby环境"></a>二、在windows下安装ruby环境</h2><h5 id="1-下载并安装-RubyInstaller-for-Windows。"><a href="#1-下载并安装-RubyInstaller-for-Windows。" class="headerlink" title="1). 下载并安装 RubyInstaller for Windows。"></a>1). 下载并安装 <a href="http://rubyinstaller.org/downloads/">RubyInstaller for Windows</a>。</h5><p>版本可以选择2.0或者1.9.3都可以。</p>
<p>双击安装，安装时选中“Add Ruby executables to your PATH”前的框将ruby添加到环境变量中。</p>
<p>安装完成后，在 Windows 命令行窗口中执行以下命令，检查ruby是否已经加到PATH中： <code>ruby --version</code></p>
<h5 id="2-安装-DevKit-。"><a href="#2-安装-DevKit-。" class="headerlink" title="2). 安装 DevKit 。"></a>2). 安装 <a href="http://rubyinstaller.org/downloads/">DevKit </a>。</h5><p>请根据主页上的描述下载对应的DevKit版本，下载后直接解压到没有空格的路径（例如 E:\DevKit)，然后在Windows的命令行窗口中执行以下命令：</p>
<pre><code>E:
cd E:\DevKit
ruby dk.rb init
ruby dk.rb install
</code></pre>
<h5 id="3-安装Jekyll和相关的包。"><a href="#3-安装Jekyll和相关的包。" class="headerlink" title="3). 安装Jekyll和相关的包。"></a>3). 安装Jekyll和相关的包。</h5><p>安装完成Ruby和DevKit 后继续安装jekyll，执行如下命令安装：</p>
<p><code>gem install jekyll</code></p>
<p>等待安装完成即可。</p>
<h2 id="三、创建git版本库"><a href="#三、创建git版本库" class="headerlink" title="三、创建git版本库"></a>三、创建git版本库</h2><p>登录到自己的Github账户，选择New repository，Project Name命名为：”你的用户名”.github.com，例如我的就叫“lslvxy.github.com”。</p>
<p>完成后在本地克隆jekyll-bootstrap模版，运行命令：</p>
<p><code>git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com</code></p>
<p>将jekyll-bootstrap模版克隆到本地USERNAME.github.com文件夹下。</p>
<p>然后cd到文件夹内运行命令：<br><code>jekyll serve</code></p>
<p>成功后打开浏览器输入地址：</p>
<p><a href="http://localhost:4000/">http://localhost:4000</a> 即可浏览本地生成的页面。</p>
<h2 id="四、关于jekyll-bootstrap模版"><a href="#四、关于jekyll-bootstrap模版" class="headerlink" title="四、关于jekyll-bootstrap模版"></a>四、关于jekyll-bootstrap模版</h2><p>jekyll-bootstrap是一个搭建好的模版框架，里面提供了常用的插件等内容，包括google analytics 、disqus等。使用jekyll-bootstrap可以加快个人博客的搭建。</p>
<p>类似的模版还有Octopress ，不过Octopress 安装使用较jekyll-bootstrap要麻烦许多，所以我就使用了jekyll-bootstrap。</p>
<p>jekyll-bootstrap的目录结构分析：</p>
<p>其中includes文件夹下内容为包含文件，其他页面可以直接引用。包含了常用的页面和主题等，jekyll-bootstrap是支持更更换主题的。</p>
<p>layouts文件夹内为布局文件，在每个页面的头部都需要指定使用的布局：</p>
<pre><code>---
layout: page
header : Post Archive
group: navigation
---
</code></pre>
<p>—之前不能包含空格等。</p>
<p>posts文件夹为自己写的文章，文件格式必须按照“年-月-日-文章名”进行命名。</p>
<p>_config.yml 文件为必须配置项。</p>
<p>首页为index.md文件。</p>
<p>可以根据自己的实际情况进行修改，可以自定义主题和页面布局等。</p>
<h2 id="五、关于jekyll使用过程中的问题"><a href="#五、关于jekyll使用过程中的问题" class="headerlink" title="五、关于jekyll使用过程中的问题"></a>五、关于jekyll使用过程中的问题</h2><p>jekyll是不支持中文编码的，若需要添加中文的话需要修改部分代码：</p>
<p>找到ruby的安装目录，比如我本机的地址：D:\Ruby200\lib\ruby\gems\2.0.0\gems\jekyll-1.2.1\lib\jekyll</p>
<p>下的convertible.rb文件，用记事本打开修改第31行代码为:</p>
<p>self.content = File.read(File.join(base, name), :encoding =&gt; “utf-8”)</p>
<p>打开D:\Ruby200\lib\ruby\gems\2.0.0\gems\jekyll-1.2.1\lib\jekyll\tags目录下的include.rb文件，</p>
<p>修改第58行代码为：</p>
<p>source = File.read(File.join(includes_dir, @file), :encoding =&gt; “utf-8”)</p>
<p>这样在include模版中也支持中文格式了。</p>
<h2 id="六、附加插件"><a href="#六、附加插件" class="headerlink" title="六、附加插件"></a>六、附加插件</h2><p>由于gitHub只支持静态页面，所以评论内容需要借助外部插件，可以使用jekyll-bootstrap提供的disqus，disqus是国外最流行的一个评论系统。国内的可以使用多说、友言等。</p>
<p>代码高亮插件可以使用</p>
<p>用js插件：<a href="http://mihai.bazon.net/projects/javascript-syntax-highlighting-engine">DlHightLight</a>或<a href="http://code.google.com/p/google-code-prettify/">Google Code Prettify</a></p>
<p>用<a href="https://gist.github.com/">gist</a>：强烈推荐菜鸟使用，省心省事，支持语言多</p>
<p>用<a href="http://pygments.org/">pygment</a>：要安装python以及python的包管理软件，又是个大坑，不建议菜鸟使用，尤其是使用windows的</p>
<p>分享插件：国内的<a href="http://jiathis.com/">jiathis</a>和国外的<a href="http://addthis.com/">addthis</a></p>
<p>图片：国内的<a href="http://www.yupoo.com/">yupoo</a> 、<a href="http://www.poco.cn/">poco</a>，国外的<a href="http://www.flickr.com/">Flickr</a>、<a href="http://imgur.com/">imgur</a></p>
<p>访问量统计可以使用<a href="http://www.cnzz.com/" title="http://www.cnzz.com/">CNZZ</a></p>
<h2 id="七、其他内容"><a href="#七、其他内容" class="headerlink" title="七、其他内容"></a>七、其他内容</h2><p>博客想要做的漂亮并且访问量足够的话是需要下很多功夫的，计划着博客中添加Google+，文章搜索等内容现在还没有添加进去，页面效果这些都需要比较扎实的html和css基础。这些就需要靠自己提高了。</p>
<p>暂时先写这么多吧，以后在慢慢添加，如果有什么问题的话可以Q我活着给我Email都可以的哦！</p>
<p>最后附上我搭建博客时参照的网站：</p>
<p><a href="http://www.360doc.com/content/12/0421/09/1016783_205350218.shtml" title="http://www.360doc.com/content/12/0421/09/1016783_205350218.shtml">Github Pages极简教程</a></p>
<p><a href="http://beiyuu.com/github-pages/#github">使用Github Pages建独立博客</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html">搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门</a></p>
<p><a href="http://jekyllbootstrap.com/usage/jekyll-quick-start.html">Jekyll QuickStart</a></p>
<p>–本篇完–</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
  <entry>
    <title>ExtJs4 中的 MVC 应用架构</title>
    <url>/2013/10/extjs4-mvc/</url>
    <content><![CDATA[<h3 id="一、ExtJs-4-x-MVC-模式的原理与作用"><a href="#一、ExtJs-4-x-MVC-模式的原理与作用" class="headerlink" title="一、ExtJs 4.x MVC 模式的原理与作用"></a>一、ExtJs 4.x MVC 模式的原理与作用</h3><p>大规模客户端应用通常不好实现不好组织也不好维护，因为功能和人力的不断增加，这些应用的规模很快就会超出掌控能力，ExtJS4 带来了一个新的应用架构，不但可以组织代码，还可以减少实现的内容。</p>
<span id="more"></span>

<p>新的应用架构遵照一个类 MVC 的模式，模型（Models）和控制器（Controllers）首次被引入。业界有很多种 MVC 架构，基本大同小异，ExtJS4 的定义如下：</p>
<p>a.<strong>Model 模型</strong>：模型是字段和它们的数据的集合，例如 User 模型带有 username 和 password 字段，模型知道如何持久化自己的数据，并且可以和其他模型关联，模型跟 ExtJS 3 中的 Record 类有点像（区别是，Record 只是单纯的扁平结构，而 Model 可以 nest），通常都用在 Store 中去展示 grid 和其他组件的数据。</p>
<p>b.<strong>View 视图</strong>：视图是组件的一种，专注于界面展示 – grid, tree, panel 都是 view。</p>
<p>c.<strong>Controllers 控制器</strong>：一个安放所有使你的 app 正确工作的代码的位置，具体一点应该是所有动作，例如如何渲染 view，如何初始化 model，和 app 的其他逻辑。</p>
<p>请注意：MVC 是一个框架，不是设计模式，更多的内容请参考：<br><a href="http://baike.baidu.com/view/5432454.htm?fromId=31">百度百科</a></p>
<p>框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。</p>
<p>简而言之：设计模式是大智慧，用来对软件设计进行分工；框架模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。</p>
<h3 id="二、ExtJs-4-MVC-框架搭建"><a href="#二、ExtJs-4-MVC-框架搭建" class="headerlink" title="二、ExtJs 4 MVC 框架搭建"></a>二、ExtJs 4 MVC 框架搭建</h3><h4 id="2-1、文件结构"><a href="#2-1、文件结构" class="headerlink" title="2.1、文件结构"></a>2.1、文件结构</h4><p>ExtJS 4 应用都遵循一个统一的目录结构，每个应有都相同<br>MVC 中，所有类都放在<code>app</code>目录里面，这个目录可以有子目录，代表的是命名空间（一个子目录对应一个命名空间），使用不同的目录存放<code>views</code>,<code>models</code>,<code>controllers</code>,<code>stores</code>。当我们完成例子的时候，目录结构应该和下图一样：</p>
<p><img data-src="//img.leense.site/post/2013/10/201310290930-1.png" alt="结构"></p>
<p>ExtJS SDK 必须的文件在目录 ext4 中，因此，<code>index.html</code>应该如下引入必须的 js 和 css 文件以及<code>app.js</code></p>
<h4 id="2-2、在-app-js-中创建应用"><a href="#2-2、在-app-js-中创建应用" class="headerlink" title="2.2、在 app.js 中创建应用"></a>2.2、在 app.js 中创建应用</h4><p>&lt;每个 ExtJS 4 的应用都从一个<code>Application</code>类的实例开始，这个实例包含应用的全局配置（例如应用的名字），这个实例也负责维护对全部模型、视图、控制器的引用的维护，还有一个<code>launch</code>函数，会在所有加载项加载完成之后调用。</p>
<p>首先需要选择一个全局命名空间，所有 ExtJS4 应用都需要有一个全局命名空间，以让所有应用中的类安放到其中：</p>
<pre><code class="js">Ext.application(&#123;
  requires: [&quot;Ext.container.Viewport&quot;],
  name: &quot;FWY&quot;, //定义的命名空间
  appFolder: &quot;app&quot;, //指明应用的根目录
  launch: function() &#123;
    Ext.create(&quot;Ext.container.Viewport&quot;, &#123;
      layout: &quot;fit&quot;,
      items: [
        &#123;
          xtype: &quot;panel&quot;,
          title: &quot;标题&quot;,
          html: &quot;内容&quot;
        &#125;
      ]
    &#125;);
  &#125;
&#125;);
</code></pre>
<h4 id="2-3、定义一个控制器"><a href="#2-3、定义一个控制器" class="headerlink" title="2.3、定义一个控制器"></a>2.3、定义一个控制器</h4><p>控制器是应用的粘合剂，它们所作的事情就是监听事件并执行动作，继续我们的应用，创建一个控制器。创建<code>app/controller/Students.js</code>这个文件，并添加如下代码：</p>
<pre><code class="js">Ext.define(&quot;FWY.controller.Students&quot;, &#123;
  extend: &quot;Ext.app.Controller&quot;,
  init: function() &#123;
    console.debug(&quot;trigger controller init event&quot;);
  &#125;
&#125;);
</code></pre>
<p>接下来在<code>app.js</code>中添加对 Students 控制器的引用：</p>
<pre><code class="js">Ext.application(&#123;
...
controllers: [
    &#39;Students&#39;  //对应于controller文件夹下面的Students.js
],
...
&#125;);
</code></pre>
<p>当我们通过 index.html 查看应用，Students 控制器会被自动加载（因为在 app.js 的 Application 中增加了引用），并且 Students 的 init 方法会在 launch 之前调用。</p>
<p><code>init</code>方法是个极好的地方，可以用来设置如何和 view 交互，通常都使用 Controller 的一个方法 control，control 方法使得监听 view 的事件变的容易，更新一下控制器，让它告知我们 panel 何时渲染：</p>
<pre><code class="js">Ext.define(&quot;FWY.controller.Students&quot;, &#123;
  extend: &quot;Ext.app.Controller&quot;,
  init: function() &#123;
    this.control(&#123;
      &quot;viewport &gt; panel&quot;: &#123;
        render: this.onPanelRendered
      &#125;
    &#125;);
  &#125;,
  onPanelRendered: function() &#123;
    console.debug(&quot;该panel被渲染了&quot;);
  &#125;
&#125;);
</code></pre>
<p>我们已经更新了 init 方法，使用 this.controll 给视图设置监听器。这个 controll 方法，使用最新的组件查询引擎（ComponentQuery）可以快速方便的找到页面上的组件。如果你对 ComponentQuery 不熟悉，可以查看 ComponentQuery 文档进行详细了解。简要一点，ComponentQuery 可以允许我们使用一个类似 css 选择器的方式找到组件。</p>
<p>在例子的 init 方法中我们应用了’viewport &gt; panel’，可以解释为“查找 Viewport 直接后代中的所有 Panel 组件”，然后我们提供了一个对象匹配事件名称（这个例子中只用了 render）来提供响应函数。全部的影响就是无论哪个组件符合我们的选择器，当它的 render 事件触发时，我们的 onPanelRendered 函数都会被调用。</p>
<h3 id="三、创建-ExtJs4-MVC-应用"><a href="#三、创建-ExtJs4-MVC-应用" class="headerlink" title="三、创建 ExtJs4 MVC 应用"></a>三、创建 ExtJs4 MVC 应用</h3><h4 id="1、定义一个视图"><a href="#1、定义一个视图" class="headerlink" title="1、定义一个视图"></a>1、定义一个视图</h4><p>直到现在，我们的应用只有很少代码，只有两个文<br>件 app.js 和 app/controller/Students.js，现在我们想增加一个 grid 显示所有系统中的学生列表，修改 3 处：</p>
<h5 id="1-、添加-view-List-js-视图"><a href="#1-、添加-view-List-js-视图" class="headerlink" title="(1)、添加 view/List.js 视图"></a>(1)、添加 view/List.js 视图</h5><p>是时候更好的组织一下逻辑并开始使用视图了。</p>
<p>视图也是组件，通常都是 ExtJS 现有组件的子类，现在准备创建学生表，先创建 <code>app/view/student/List.js</code><br>，添加代码：</p>
<pre><code class="js">Ext.define(&quot;FWY.view.student.List&quot;, &#123;
  extend: &quot;Ext.grid.Panel&quot;,
  alias: &quot;widget.studentlist&quot;,
  title: &quot;学生信息列表&quot;,
  initComponent: function() &#123;
    this.store = &#123;
      fields: [&quot;id&quot;, &quot;name&quot;, &quot;age&quot;, &quot;sex&quot;],
      data: [
        &#123; id: 1, name: &quot;zhangsan&quot;, age: 18, sex: &quot;boy&quot; &#125;,
        &#123; id: 2, name: &quot;lishi&quot;, age: 20, sex: &quot;girl&quot; &#125;
      ]
    &#125;;
    this.columns = [
      &#123; header: &quot;编号&quot;, dataIndex: &quot;id&quot;, flex: 1 &#125;,
      &#123; header: &quot;姓名&quot;, dataIndex: &quot;name&quot;, flex: 1 &#125;,
      &#123; header: &quot;年龄&quot;, dataIndex: &quot;age&quot;, flex: 1 &#125;,
      &#123; header: &quot;性别&quot;, dataIndex: &quot;sex&quot;, flex: 1 &#125;
    ];
    this.callParent(arguments);
  &#125;
&#125;);
</code></pre>
<h5 id="2-、修改-controller-Students-js"><a href="#2-、修改-controller-Students-js" class="headerlink" title="(2)、修改 controller/Students.js"></a>(2)、修改 controller/Students.js</h5><p>我们的视图类就是一个普通的类，这个例子中我们扩展了 Grid 组件，并设置了别名，这样我们可以用 xtype 的方式调用这个组件，另外我们也添加了 store 和 columns 的配置。<br>接下来我们需要添加这个视图到 Students 控制器。因为我们用 ‘widget.studentlist’ 设置了别名，所以我们可以使用 studentlist 作为 xtype，就像我们使用之前使用的 ‘panel’</p>
<pre><code class="js">Ext.define(&#39;FWY.controller.Students&#39;, &#123;
    extend: &#39;Ext.app.Controller&#39;,
    views: [
        &#39;student.List&#39;//添加view视图
    ],
    init: ...
    onPanelRendered: ...
&#125;);
</code></pre>
<h5 id="3-、修改-app-js，加载视图"><a href="#3-、修改-app-js，加载视图" class="headerlink" title="(3)、修改 app.js，加载视图"></a>(3)、修改 app.js，加载视图</h5><p>接下来修改 app.js 让视图在 viewport 中渲染，需要修改 launch 方法</p>
<pre><code class="js">Ext.application(&#123;
    ...
    launch: function() &#123;
        Ext.create(&#39;Ext.container.Viewport&#39;, &#123;
            layout: &#39;fit&#39;,
            items: &#123;
                xtype: &#39;studentlist&#39;
            &#125;
        &#125;);
    &#125;
&#125;);
</code></pre>
<p>唯一需要注意的是我们在 views 数组中指定了 ‘student.List’ ，这告诉应用去自动加载对应的文件，ExtJS4 的动态加载系统会根据规则从服务器自动拉取文件，例如 student.List 就是规则，把.替换成/就是文件存放路径。刷新一下页面即可看到效果</p>
<h4 id="2、添加对列表的控制"><a href="#2、添加对列表的控制" class="headerlink" title="2、添加对列表的控制"></a>2、添加对列表的控制</h4><p>分三步完成对对编辑窗体的控制</p>
<h5 id="1-、为-grid-绑定双击事件"><a href="#1-、为-grid-绑定双击事件" class="headerlink" title="(1)、为 grid 绑定双击事件"></a>(1)、为 grid 绑定双击事件</h5><p>注意 onPanelRendered 方法依然被调用，因为我们的 grid 依然满足 ‘viewport &gt; panel’ 选择器，因为我们的视图继承自 Grid ，从而继承自 Panel。现在我们需要收紧一下选择器，我们使用 xtype 作为选择器替换之前的 ‘viewport &gt; panel’ ，监听双击事件，以便继续做编辑用户信息：</p>
<pre><code class="js">Ext.define(&quot;FWY.controller.Students&quot;, &#123;
  extend: &quot;Ext.app.Controller&quot;,
  views: [&quot;student.List&quot;],
  init: function() &#123;
    this.control(&#123;
      studentlist: &#123;
        itemdblclick: this.editStudent //添加行双击事件
      &#125;
    &#125;);
  &#125;,
  editStudent: function(grid, record) &#123;
    console.log(&quot;Double clicked on &quot; + record.get(&quot;name&quot;));
  &#125;
&#125;);
</code></pre>
<p>注意我们更换了组件查询选择器为 ‘studentlist’ ，监听的事件更改为 ‘itemdblclick’ ，响应函数设置为 editStudent，现在只是简单的日志出双击行的 name 属性。</p>
<h5 id="2-、创建-view-student-Edit-js-视图"><a href="#2-、创建-view-student-Edit-js-视图" class="headerlink" title="(2)、创建 view/student/Edit.js 视图"></a>(2)、创建 view/student/Edit.js 视图</h5><p>可以看到日志是正确的，但我们实际想做的是编辑用户信息，让我们现在做，创建一个新的视图 <code>app/view/student/Edit.js</code></p>
<pre><code class="js">Ext.define(&quot;FWY.view.student.Edit&quot;, &#123;
  extend: &quot;Ext.window.Window&quot;,
  alias: &quot;widget.studentedit&quot;,
  title: &quot;修改学生信息&quot;,
  layout: &quot;fit&quot;,
  autoShow: true,
  initComponent: function() &#123;
    this.items = [
      &#123;
        xtype: &quot;form&quot;,
        items: [
          &#123;
            xtype: &quot;textfield&quot;,
            name: &quot;name&quot;,
            fieldLabel: &quot;姓名&quot;
          &#125;,
          &#123;
            xtype: &quot;textfield&quot;,
            name: &quot;age&quot;,
            fieldLabel: &quot;年龄&quot;
          &#125;,
          &#123;
            xtype: &quot;textfield&quot;,
            name: &quot;sex&quot;,
            fieldLabel: &quot;性别&quot;
          &#125;
        ]
      &#125;
    ];
    this.buttons = [
      &#123;
        text: &quot;保存&quot;,
        action: &quot;save&quot;
      &#125;,
      &#123;
        text: &quot;取消&quot;,
        scope: this,
        handler: this.close
      &#125;
    ];

    this.callParent(arguments);
  &#125;
&#125;);
</code></pre>
<h5 id="3-、修改控制器加载视图"><a href="#3-、修改控制器加载视图" class="headerlink" title="(3)、修改控制器加载视图"></a>(3)、修改控制器加载视图</h5><p>接下来我们要做的就是在控制器加载这个视图，渲染并且加载用户信息：</p>
<pre><code class="js">Ext.define(&#39;FWY.controller.Students&#39;, &#123;
    extend: &#39;Ext.app.Controller&#39;,
    views: [
        &#39;student.List&#39;,
        &#39;student.Edit&#39;//添加edit视图
    ],
    init: ...
    editStudent: function(grid, record) &#123;
        var view = Ext.widget(&#39;studentedit&#39;);//注册组件，显示窗口
        view.down(&#39;form&#39;).loadRecord(record);//加载数据到表单中
    &#125;
&#125;);
</code></pre>
<p>首先我们用 Ext.widget 方法创建了视图，这个方法等同于 <code>Ext.create(&#39;widget.studentedit&#39;)</code>，然后我们又一次借助组件查询找到了窗口中的表单，每个 ExtJS4 中的组件都有一个 <code>down</code>方法，可以借助组件查询支持的选择器来迅速找到任意下层的组件,双击表格中的一行可以看到弹窗效果。</p>
<h4 id="3、创建-Store-和-Model-进行重构"><a href="#3、创建-Store-和-Model-进行重构" class="headerlink" title="3、创建 Store 和 Model 进行重构"></a>3、创建 Store 和 Model 进行重构</h4><p>现在我们有了表单，可以开始编辑和保存用户信息了，但是这之前需要做一点点重构。<br>FWY.view.student.List 创建了一个内联的 Store ，这样可以工作但是我们需要把 Store 分离出来以便我们在应用的其他位置可以引用并更新其中的信息，我们把它放在它应该在的文件中 <code>app/store/Students.js</code> ：</p>
<pre><code class="js">Ext.define(&quot;FWY.store.Students&quot;, &#123;
  extend: &quot;Ext.data.Store&quot;,
  fields: [&quot;id&quot;, &quot;name&quot;, &quot;age&quot;, &quot;sex&quot;],
  data: [
    &#123; id: 1, name: &quot;张三&quot;, age: 30, sex: &quot;男&quot; &#125;,
    &#123; id: 2, name: &quot;李四&quot;, age: 20, sex: &quot;女&quot; &#125;
  ]
&#125;);
</code></pre>
<p>现在我们需要做两处变更，首先我们需要让 Students 初始化的时候加载这个 Store ：</p>
<pre><code class="js">Ext.define(&#39;FWY.controller.Students&#39;, &#123;
    extend: &#39;Ext.app.Controller&#39;,
    stores: [&#39;Students&#39;],//加载store
    ...
&#125;);
</code></pre>
<p>然后我们要把之前直接在视图中内联的 store 更改掉，</p>
<pre><code class="js">Ext.define(&#39;FWY.view.student.List&#39; ,&#123;
    extend: &#39;Ext.grid.Panel&#39;,
    alias : &#39;widget.studentlist&#39;,
    store: &#39;Students&#39;,//引用Store
    ...
&#125;);
</code></pre>
<p>控制器的代码中中引入了 store，store 会被自动加载到页面并赋予一个 storeId，这让视图中使用 store 变的容易（这个例子中，只要配置 store: ‘Students’ 就可以了）<br>现在我们只是在 store 中内联的定义了四个字段 (id,name,age,sex)，这样可以工作了。</p>
<p><strong>进一步重构：</strong></p>
<p>ExtJS4 中有一个强大的 Ext.data.Model 类，在编辑用户的时候我们可以借助它，使用 Model 重构下 Store，在 <code>app/model/Student.js</code>中创建一个 Model：</p>
<pre><code class="js">Ext.define(&quot;FWY.model.Student&quot;, &#123;
  extend: &quot;Ext.data.Model&quot;,
  fields: [&quot;id&quot;, &quot;name&quot;, &quot;age&quot;, &quot;sex&quot;]
&#125;);
</code></pre>
<p>这就是定义我们的 Model 需要做的，现在需要让 Store 引用 Model 替换掉使用内联字段的方式，并且让控制器也引用 Model：</p>
<pre><code class="js">//修改控制器，引用Model
Ext.define(&#39;FWY.controller.Students&#39;, &#123;
    extend: &#39;Ext.app.Controller&#39;,
    stores: [&#39;Students&#39;],
    models: [&#39;Student&#39;],
    ...
&#125;);
//修改store，引用Model
Ext.define(&#39;FWY.store.Students&#39;, &#123;
    extend: &#39;Ext.data.Store&#39;,
    model: &#39;FWY.model.Student&#39;,
    data: [
        &#123;id:1,name: &#39;张三1&#39;,    age: 30,sex:&#39;男&#39;&#125;,
        &#123;id:2,name: &#39;李四1&#39;,    age: 21,sex:&#39;女&#39;&#125;
    ]
&#125;);
</code></pre>
<h4 id="4、利用模型保存数据"><a href="#4、利用模型保存数据" class="headerlink" title="4、利用模型保存数据"></a>4、利用模型保存数据</h4><p>现在我们有了一个用户数据表，双击每⼀一行都能打开一个编辑窗口，现在要做的是保存编辑变更，编辑窗口有一个编辑表单，还有保存按钮，现在我们更新一下控制器让保存按钮有响应：</p>
<pre><code class="js">Ext.define(&quot;FWY.controller.Students&quot;, &#123;
  init: function() &#123;
    this.control(&#123;
      &quot;viewport &gt; studentlist&quot;: &#123;
        itemdblclick: this.editStudent
      &#125;,
      &quot;studentedit button[action=save]&quot;: &#123;
        //获取studentedit视图中的button配置action=‘save’的按钮事件
        click: this.updateStudent
      &#125;
    &#125;);
  &#125;,
  updateStudent: function(button) &#123;
    console.log(&quot;clicked the Save button&quot;);
  &#125;
&#125;);
</code></pre>
<p>接下来填充 updateStudent 真正的逻辑。我们需要把数据从表单中取出，再<br>设置回 store 中：</p>
<pre><code class="js">updateStudent: function(button) &#123;
    var win    = button.up(&#39;window&#39;),
    form   = win.down(&#39;form&#39;),
    record = form.getRecord(),
    values = form.getValues();
    record.set(values);
    win.close();
&#125;
</code></pre>
<h4 id="5、保存到服务器"><a href="#5、保存到服务器" class="headerlink" title="5、保存到服务器"></a>5、保存到服务器</h4><p>让我们增加和服务器端的交互完成这个例子。现在我们还是应编码了两行表格的数<br>据，现在让我们通过 ajax 加载：</p>
<pre><code class="js">Ext.define(&quot;FWY.store.Students&quot;, &#123;
  extend: &quot;Ext.data.Store&quot;,
  model: &quot;FWY.model.Student&quot;,
  autoLoad: true,
  proxy: &#123;
    type: &quot;ajax&quot;,
    url: &quot;data/students.json&quot;,
    reader: &#123;
      type: &quot;json&quot;,
      root: &quot;students&quot;,
      successProperty: &quot;success&quot;
    &#125;
  &#125;
&#125;);
</code></pre>
<p>这里我们去除了 ‘data’ 属性，替换成 proxy ，代理是让 Store 或者 Model 加载和保存数据的一个方式，有 AJAX，JSONP，HTML5 的 localStorage 本地存储等。这里我们使用了一个简单的 AJAX 代理，让它通过 URL ‘data/students.json’ 加载数据。</p>
<p>我们同时给代理附加了一个 reader，reader 是用来把服务器返回的数据解码成 Store 能理解的格式，这次我们使用了 JSON reader，并且指定了 root 和 successProperty 配置（JSON reader 的详细配置看文档），最后我们创建一下数据文件 <code>data/students.json</code> ，输入内容：</p>
<pre><code class="js">&#123;
    success: true,
    users: [
        &#123;id: 1, name: &#39;zhang&#39;,    email: &#39;zhang@126.com&#39;&#125;,
        &#123;id: 2, name: &#39;lishi&#39;, email: &#39;lishi@126.com&#39;&#125;
　　]
&#125;
</code></pre>
<p>其他的变更就是我们给 Store 设置了 autoLoad 属性并设置为 true ，这意味着 Store 生成之后会自动让 Proxy 加载数据，刷新⼀一下页面应该是看到和之前同样的结果，不同的是现在不是在程序中存在硬编码数据了，最后的事情是将变更传回服务器端，这个例子中我们使用静态的 JSON 文件，没有使用数据库，但足够说明我们例子的了，首先做一点点变化告知 proxy 用于更新的 url：</p>
<pre><code class="js">proxy: &#123;
    type: &#39;ajax&#39;,
    api: &#123;
        read: &#39;data/students.json&#39;,
        up---
date: &#39;data/updateStudents.json&#39;,
    &#125;,
    reader: &#123;
        type: &#39;json&#39;,
        root: &#39;students&#39;,
        successProperty: &#39;success&#39;
    &#125;
&#125;
</code></pre>
<p>依然从 students.json 读取数据，但是变更会发送到 updateStudents.json ，这里我们做⼀个模拟的应答回包以让我们知道程序可以正确工作， updateStudents.json 只需要包含<code>&#123;&quot;success&quot;:true&#125;</code>，其他要做的就是让 Store 在编辑之后进行同步，需要在 updateStudent 函数中增加一行代码：</p>
<pre><code class="js">    updateStudent: function(button) &#123;
    var win    = button.up(&#39;window&#39;),
    form   = win.down(&#39;form&#39;),
    record = form.getRecord(),
    values = form.getValues();
    record.set(values);
    win.close();
    this.getStudentsStore().sync();//将数据同步到store中
&#125;
</code></pre>
<p>最后附上本篇的代码：[点击下载](/attach/ExtJs-MVC.zip)</p>
<p>–本篇完–</p>
]]></content>
      <categories>
        <category>ExtJs</category>
      </categories>
      <tags>
        <tag>extJs4</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>豆沙绿？护眼并非如此简单</title>
    <url>/2013/10/zw-dsl/</url>
    <content><![CDATA[<p>你相信”将电脑屏幕设置成豆沙绿能保护视力”的说法吗？这个所谓的保护视力的方法并没有什么效果。相信豆沙绿能够保护视力，还不如在使用电脑的过程中多看看远处来得靠谱。</p>
<span id="more"></span>
<p><strong>流言：</strong> 为了您的视力，请对电脑作如下设置：桌面-&gt;右键-&gt;属性-&gt;外观-&gt;高级－&gt;项目选择（窗口）、颜色1（L）选择（其它）将色调改为：85。饱和度：123。亮度：205－&gt;添加到自定义颜色－&gt;在自定义颜色选定点确定－&gt;确定。这个色调是眼科专家配置的，长时间使用会很有效的缓解眼睛疲劳保护眼睛。</p>
<p><strong>真相：</strong> 从小，我们就受到这样的教育：写字看书一段时间后，要看看远处的绿色植物来保护视力。这种做法确实有些效果。之后有商人依照这个“常识”推出绿色书写纸制作的作业本，号称可以预防近视。“豆沙绿保护视力”的流言可以看作是绿色作业本的现代版。</p>
<p>那么这些做法到底有没有用呢？</p>
<p>在讨论这些问题前，我们先给”绿色”下一个定义。绿色是自然中常见的颜色，是三原色之一，绿色的光波长在520–570nm之间。在RGB颜色模型中，纯绿色的RGB值是（0，255，0），任何RGB值中第二个值最大的色彩都属于绿色系。如本文开头流言中那样设置出来的豆沙绿，RGB值为（199，237，204），近似于青瓷绿（Celadon green）。</p>
<p>让我们查查网上有关绿色书写纸的文章，几乎都只是语焉不详的说明：绿色纸张能有效缓解视疲劳。确实，绿色光处于可见光谱的中心位置，处于人眼最敏感的色彩频率范围内。另外色彩心理学认为，绿色能够让人感到舒适与平静。但是这些都不足以用来说明绿色能保护视力，也没有相关的研究支持这一点。</p>
<p>从反差识别的角度来考虑，绿色纸张对视力也没有特别的积极影响。有文献显示，在颜色饱和度低的情况下，绿色纸张与白色纸张对近视力（指近距离人眼分辨力）的影响并没有本质的区别。但是，如果纸张颜色饱和度过高反而会导致文字与背景反差降低，影响对文字的对比度，使文字的辨识度降低，反而会让双眼更容易疲劳。检索发现，没有可靠的文献或者是实验支持长时间使用绿色纸张制作的书本能够保护视力。</p>
<p>看看远处的绿色植物放松紧张的双眼是有效的预防近视的手段，不过与其说是植物的绿色让双眼放松，倒不如归功于植物与人眼的距离是要远远大于书本与人眼的距离，向远处对焦这一动作使睫状肌处于松弛的状态，紧张的它得到了休息。相信绿色作业本能够很好的保护视力，还不如多看看窗外来得靠谱。</p>
<p>如前所述，绿色光保护视力的能力并不可靠。将电脑设置成豆沙绿唯一可能做到的只是让屏幕亮度变得不那么刺眼。对于由眨眼次数少使泪液蒸发过快造成的干眼，坐姿、与屏幕距离等问题造成的视疲劳、上身疼痛，“豆沙绿”是没有任何效果的。</p>
<p>长时间使用电脑确实可能造成视觉问题。美国视光学协会（AOA）将其定义为计算机视觉征候群（Computer Vision Syndrome, CVS），也称为VDT综合征。其主要症状是视疲劳、视力模糊、干眼、头部、颈部与肩周疼痛。造成这些问题的主要原因有：屏幕过亮或过暗，双眼与屏幕距离不合适，坐姿不恰当，使用电脑时眨眼次数减少，以及电脑使用者本身所有的视力问题。</p>
<p>长期使用电脑的你，如何保护双眼呢？这里给出一些小贴士：</p>
<p>设置好你的屏幕，使它不刺眼也不太暗。</p>
<p>调整你的坐姿，保证上身挺直，颈部得到很好的支撑。</p>
<p>调整电脑屏幕、桌椅，如下图所示。</p>
<p>使用电脑一段时间后，起身看看远处，放松双眼。</p>
<p>长时间使用电脑时，要注意休息和眨眼，并适当为工作环境加湿，以便缓解眼干。</p>
<p><strong>结论：</strong> “绿色护眼”没有研究支持，并且在国外网站鲜有讨论，这应该是一个本土流言，可能是”看远处的绿色植物来保护视力”这一正确做法的讹传。而将电脑的背景色设置成豆沙绿虽然没有什么坏处，但是靠这个操作保护视力不靠谱。</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>豆沙绿</tag>
        <tag>护眼</tag>
      </tags>
  </entry>
  <entry>
    <title>择一城终老，遇一人白首</title>
    <url>/2013/12/city-persion/</url>
    <content><![CDATA[<p><img data-src="//img.leense.site/post/2013/12/201312010930-1.jpg" alt="love"></p>
<p>时光静好，与君语；细水长流，与君同；繁华落尽，与君老。想来这一生，总会有那么一个人，牵着你的手，将爱融入生命，倾一世温柔，与你一起待霜染白发，陪你看细水长流。</p>
<p>——题记</p>
<span id="more"></span>

<p>岁月荏苒，浅夏将一种极致的婉约，律动在岁月的眸里，我轻倚季节的转角处，安然于这份静好。轻轻浅浅的日子，散发着恬淡的香，那是时光沉淀的馨香。一直认为，最长久的幸福，是来自平淡的日子；来自宁静的心境；来自平凡日子里点点滴滴滴的感悟。繁华落尽终究是平淡，生活的美，不在于绚丽，而在于平和；爱情的美，不在于轰轰烈烈，而在于平凡的相守，温暖的陪伴。</p>
<p>年少的时候，曾对爱情有过很多幻想，那么渴望能成为爱情童话中的主人公，期待白马王子有一天能穿越千山万水来到身边，牵着我的手走向幸福。然，年华如水时光辗转，王子终究没来，我也没有穿上灰姑娘的那双水晶鞋，在似水流年里将一颗心安放在岁月中，拥有了一份平淡的爱情。</p>
<p>“择一城终老，遇一人白首”，不知在哪里看到这句话，不由得心生感动，想来这一生，总会有那么一个人，牵着你的手，将爱融入生命，倾一世温柔，与你一起待霜染白发，陪你看细水长流。多少人间烟火，在细细碎碎的时光里静静氤氲；多少沧桑坎坷，在身手相牵的岁月中远去，任容颜在日复一日的平淡中慢慢变老，花虽落，风住尘香；水长流，云淡过往，惟不变的是彼此旧时的欢颜。</p>
<p>也许生命的美在于遇见，我不知道这一生会遇到多少人，也不知道会有多少倾心的相遇，或许这世上有很多人都可以惊艳你的时光，但能够愿意留在你身边直到慢慢温柔了你的岁月，陪你哭，陪你笑，陪你等待，陪你花开，一生也许只有那么一个。惊鸿一瞥是生命的美妙，细水长流才是最真的幸福。佛说前生五百年的回眸，才换得今生的一次擦肩，那么于千万人之中遇见了你，牵手一生一世，又是怎样的一种修行呢！</p>
<p>或许你不是最优秀的，但一定是最懂得心疼我的。累的时候，你的肩膀可以让我依靠；寒冷的日子，你的怀抱就是我的温暖；伤心的时候可以得到你的安慰；寂寞的时候有你的微笑陪伴；快乐的时候可以与你一起分享；风风雨雨我们一起走过；红尘纷扰我们一起面对，任岁月平淡了流年，任时光抹去了激情，你的爱，一直都在。</p>
<p>或许你不是那么完美，但一定是最懂我的那个人。懂得是心与心的相通；是灵魂与灵魂的相依；懂得是相爱的两个人心中开出的最美的花朵，有的时候，懂比爱更重要。因为懂得，所以理解；因为相惜，所以包容。爱不是不争不吵，是发生争执后还能在一起；爱不是不打不闹，是吵过闹过后依然不离不弃。一份懂得，几多欢喜；一份陪伴，几多温暖，爱无言，千回百转；情无声，寂然欢喜，有你的地方就是我此生最美的风景。</p>
<p>张爱玲说：我一直在寻找那种感觉，那种在寒冷日子里，牵起一双温暖的手，踏实向前走的感觉。一生一世的牵手，多么温暖，从青春年少到步履蹒跚；从红颜到白发，在彼此默默注视中慢慢变老，还有什么比镌刻着岁月冷暖的这份情更珍贵呢？</p>
<p>一直认为最好的爱情，须与时日一起生长。我不羡慕花前月下的卿卿我我；也不羡慕朝朝暮暮的山盟海誓，我羡慕的是百发苍苍夕阳下相依相扶的身影。从人生初识的相看两不厌，到时光将爱情打磨成亲情，牵了手的手，没有岁月可回头，当激情退却，当浪漫殆尽，只有心灵深处的取暖才能绵延。爱是衣带渐宽终不悔的执着，爱是为伊消得人憔悴的不悔；爱是微笑向晚，携手共阑珊，最好的爱情，是给你一生。</p>
<p>尘世的屋檐下，有多少人就有多少爱恋，有多少风花雪月的缠绵，就有多少幸福和温暖。当你穿行在万家灯火，我会为你点燃照亮你回家路的那盏灯；当你风尘仆仆的奔波回来，我会用温柔的手为你洗去倦容；当皱纹爬上你的额头，我会握紧你的手，陪你一起变老，在琐琐碎碎的的日子里，诠释执子之手，与子偕老的永恒。</p>
<p>有人说：爱上一座城，是因为城里住着某个人，能够与所爱的人在一起，连光阴都是美的。即便粗茶淡饭，修篱种田，只要有你陪伴就好。那么，找一个青山绿水的地方，寻一处幽静的茅舍，或是云水禅心的庭院，那里有晴朗的阳光和静谧的悠然，还有你明媚的笑脸。掬一捧花香在平淡的日子，握着一路相随的暖意，让爱的馨香在柴米油盐中升腾；在一杯茶的温情里，体味生活的诗意；在一碗粥的清淡中，感受生活的浪漫，每天清晨你和阳光都在，便是我的幸福。</p>
<p>春暖花开的日子里，我想牵着你的手漫步在通往田野的小径上，蓝天之下，有清风掠过，身后是一排排苍翠的竹林青叶，远处是皑皑的青山。我与你掬一泓泉水的清澈，携一缕清风的洒脱，看蝶飞花舞，聆听花开的声音，尽情享受每一缕阳光的温暖，感受每一滴雨露的滋润，让相惜的暖意在风和日丽中增长，这一刻，我愿放下所有的执念，只想做你手心里的宝，用一朵花开的时间，守望幸福。</p>
<p>飘雨的日子，我们依偎在一起，临窗而坐，听雨打芭蕉的声音。任光阴在窗外流淌，我沏壶清香四溢的花茶，静静感受那清风与细雨的缠绵，斟一盏岁月沉淀的芳香，细听时光的呓语，回味过往一段段美好的画面，品茗生活给予的点点滴滴，在安静的时光中，淡看流年烟火，细品岁月静好。</p>
<p>年华向晚，不过岁月沉香。待到老去的那一天，两鬓斑白，步履蹒跚的我们已经不能再走千山踏万水，我和你围在火炉边，在我们的皱纹与白发里，细数光阴的痕迹。感谢生命中的缘分，让我遇见了你，有一种情，永远不老，只为与你相识时的美好；有一种爱，深藏心中，只为与你相爱时的淡然，这一生，最幸福的事，便是牵着你的手一起走过。当尘世烟火慢慢沉寂；当指尖浮华逐渐消散，你依旧如此牵着我的手，岁月老了，情还在，原来我生命中最美的时光，是从遇到你的那一刻开始。</p>
<p>择一城终老，遇一人白首。</p>
<p>原文地址：<a href="http://www.sanwen.net/subject/3443861/">http://www.sanwen.net/subject/3443861/</a></p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>时光</tag>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>ExtJs改变树节点的勾选状态</title>
    <url>/2013/12/extjs-tree-check/</url>
    <content><![CDATA[<p>今天系统中有处地方需要一个功能点击一个按钮后将树节点前的复选框去掉，变成没有选择的状态。网上搜索了半天，然后自己查查API，终于找到解决办法了，下面把方法贴出来。</p>
<span id="more"></span>
<p>在Extjs3.x和4.x版本中的处理方法是不一样的， 3.x版本中可以这样操作：</p>
<pre><code class="js">node.attributes.checked=false;
node.getUI().toggleCheck(false);
</code></pre>
<p>这样就可以取消节点的check状态并且将页面上的勾去掉。</p>
<p>在ExtJs4中的方法如下：</p>
<pre><code class="js">node.raw.checked=false;
node.set(&quot;checked&quot;,false);
</code></pre>
<p>这样同样可以达到效果！</p>
]]></content>
      <categories>
        <category>ExtJs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
        <tag>tree</tag>
        <tag>树</tag>
        <tag>勾选</tag>
      </tags>
  </entry>
  <entry>
    <title>ExtJs 中 gridpanel 分组后组名排序</title>
    <url>/2013/12/extjs-group-grid/</url>
    <content><![CDATA[<p>ExtJs 中对 gridpanel 分组后的组名进行排序，GroupingGrid 分组后是不能对组名再进行排序的，本文介绍了相关方法。</p>
<span id="more"></span>

<p><img data-src="//img.leense.site/post/2013/12/201312021200-1.jpg" alt="group"></p>
<pre><code class="js">/**
  * 定义降序的groupingStore
  */
var DescGroupingStore = Ext.extend(Ext.data.GroupingStore, &#123;
groupDir : &#39;ASC&#39;,
groupBy : function(field, forceRegroup, direction) &#123;
    direction = direction ? (String(direction)
              .toUpperCase() == &#39;DESC&#39; ? &#39;DESC&#39; : &#39;ASC&#39;)
              : this.groupDir;
    if (this.groupField == field
           this.groupDir == direction &amp;amp;&amp;amp; !forceRegroup) &#123;
          return;
   &#125;
   this.groupField = field;
   this.groupDir = direction;
   if (this.remoteGroup) &#123;
       if (!this.baseParams) &#123;
          this.baseParams = &#123;&#125;;
       &#125;
       this.baseParams[&#39;groupBy&#39;] = field;
          this.baseParams[&#39;groupDir&#39;] = direction;
       &#125;
       if (this.groupOnSort) &#123;
            this.sort(field, direction);
            return;
       &#125;
       if (this.remoteGroup) &#123;
            this.reload();
       &#125; else &#123;
            var si = this.sortInfo || &#123;&#125;;
            if (si.field != field || si.direction != direction) &#123;
                this.applySort();
            &#125; else &#123;
                this.sortData(field, direction);
            &#125;
            this.fireEvent(&#39;datachanged&#39;, this);
        &#125;
    &#125;,
    applySort : function() &#123;
        Ext.data.GroupingStore.superclass.applySort.call(this);
        if (!this.groupOnSort &amp;&amp; !this.remoteGroup) &#123;
            if (this.groupField != this.sortInfo.field
                    || this.groupDir != this.sortInfo.direction) &#123;
                this.sortData(this.groupField, this.groupDir);
            &#125;
        &#125;
    &#125;,
    applyGrouping : function(alwaysFireChange) &#123;
        if (this.groupField !== false) &#123;
            this.groupBy(this.groupField, true, this.groupDir);
            return true;
        &#125; else &#123;
            if (alwaysFireChange === true) &#123;
                this.fireEvent(&#39;datachanged&#39;, this);
            &#125;
            return false;
        &#125;
    &#125;
&#125;);
</code></pre>
<pre><code class="js">/*************************调用***************************/
// 消息列表数据源
var messageStore = new DescGroupingStore(&#123;
  proxy: new Ext.data.HttpProxy(&#123;
    url: &quot;listMessGrid.action&quot;
  &#125;),
  reader: myReader,
  groupDir: &quot;DESC&quot;,
  groupField: &quot;status&quot;,
  sortInfo: &#123;
    field: &quot;id&quot;,
    direction: &quot;DESC&quot;
  &#125;
&#125;);
messageStore.load();
</code></pre>
<pre><code class="js">/*****************在gridpanel中添加如下属性*************************************/
view: new Ext.grid.GroupingView(&#123;
  showGroupName: false,
  groupTextTpl: &quot;&#123;gvalue&#125;:&#123;text&#125;&quot;,
  showGroupsText: &quot;ddd&quot;
&#125;);
</code></pre>
]]></content>
      <categories>
        <category>ExtJs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
        <tag>grid</tag>
        <tag>分组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础：JAVA代码编写的30条建议</title>
    <url>/2013/12/java-jc30/</url>
    <content><![CDATA[<p>JAVA基础：JAVA代码编写的30条建议，一些规范和默认的代码规则。</p>
<span id="more"></span>
<p>(1) 类名首字母应该大写。字段、方法以及对象（句柄）的首字母应小写。对于所有标识符，其中包含的所有单词都应紧靠在一起，而且大写中间单词的首字母。例如：<br><code>ThisIsAClassName</code><br><code>thisIsMethodOrFieldName </code><br>若在定义中出现了常数初始化字符，则大写<code>static</code> final基本类型标识符中的所有字母。这样便可标志出它们属于编译期的常数。<br>Java包（Package）属于一种特殊情况：它们全都是小写字母，即便中间的单词亦是如此。对于域名扩展名称，如com，org，net或者edu等，全部都应小写（这也是Java 1.1和Java 1.2的区别之一）。</p>
<p>(2) 为了常规用途而创建一个类时，请采取”经典形式”，并包含对下述元素的定义：<br>equals()<br>hashCode()<br>toString()<br>clone()（implement Cloneable）<br>implement Serializable   </p>
<p>(3) 对于自己创建的每一个类，都考虑置入一个main()，其中包含了用于测试那个类的代码。为使用一个项目中的类，我们没必要删除测试代码。若进行了任何形式的改动，可方便地返回测试。这些代码也可作为如何使用类的一个示例使用。</p>
<p>(4) 应将方法设计成简要的、功能性单元，用它描述和实现一个不连续的类接口部分。理想情况下，方法应简明扼要。若长度很大，可考虑通过某种方式将其分割成较短的几个方法。这样做也便于类内代码的重复使用（有些时候，方法必须非常大，但它们仍应只做同样的一件事情）。</p>
<p>(5) 设计一个类时，请设身处地为客户程序员考虑一下（类的使用方法应该是非常明确的）。然后，再设身处地为管理代码的人考虑一下（预计有可能进行哪些形式的修改，想想用什么方法可把它们变得更简单）。     </p>
<p>(6) 使类尽可能短小精悍，而且只解决一个特定的问题。下面是对类设计的一些建议：     </p>
<ul>
<li>一个复杂的开关语句：考虑采用”多形”机制     </li>
<li>数量众多的方法涉及到类型差别极大的操作：考虑用几个类来分别实现     </li>
<li>许多成员变量在特征上有很大的差别：考虑使用几个类     </li>
</ul>
<p>(7) 让一切东西都尽可能地”私有”–private。可使库的某一部分”公共化”（一个方法、类或者一个字段等等），就永远不能把它拿出。若强行拿出，就可能破坏其他人现有的代码，使他们不得不重新编写和设计。若只公布自己必须公布的，就可放心大胆地改变其他任何东西。在多线程环境中，隐私是特别重要的一个因素–只有private字段才能在非同步使用的情况下受到保护。     </p>
<p>(8) 谨惕”巨大对象综合症”。对一些习惯于顺序编程思维、且初涉OOP领域的新手，往往喜欢先写一个顺序执行的程序，再把它嵌入一个或两个巨大的对象里。根据编程原理，对象表达的应该是应用程序的概念，而非应用程序本身。     </p>
<p>(9) 若不得已进行一些不太雅观的编程，至少应该把那些代码置于一个类的内部。     </p>
<p>(10) 任何时候只要发现类与类之间结合得非常紧密，就需要考虑是否采用内部类，从而改善编码及维护工作（参见第14章14.1.2小节的”用内部类改进代码”）。     </p>
<p>(11) 尽可能细致地加上注释，并用javadoc注释文档语法生成自己的程序文档。     </p>
<p>(12) 避免使用”魔术数字”，这些数字很难与代码很好地配合。如以后需要修改它，无疑会成为一场噩梦，因为根本不知道”100”到底是指”数组大小”还是”其他全然不同的东西”。所以，我们应创建一个常数，并为其使用具有说服力的描述性名称，并在整个程序中都采用常数标识符。这样可使程序更易理解以及更易维护。     </p>
<p>(13) 涉及构建器和异常的时候，通常希望重新丢弃在构建器中捕获的任何异常–如果它造成了那个对象的创建失败。这样一来，调用者就不会以为那个对象已正确地创建，从而盲目地继续。<br>(14) 当客户程序员用完对象以后，若你的类要求进行任何清除工作，可考虑将清除代码置于一个良好定义的方法里，采用类似于cleanup()这样的名字，明确表明自己的用途。除此以外，可在类内放置一个boolean（布尔）标记，指出对象是否已被清除。在类的finalize()方法里，请确定对象已被清除，并已丢弃了从RuntimeException继承的一个类（如果还没有的话），从而指出一个编程错误。在采取象这样的方案之前，请确定finalize()能够在自己的系统中工作（可能需要调用System.runFinalizersOnExit(true)，从而确保这一行为）。     </p>
<p>(15) 在一个特定的作用域内，若一个对象必须清除（非由垃圾收集机制处理），请采用下述方法：初始化对象；若成功，则立即进入一个含有finally从句的try块，开始清除工作。     </p>
<p>(16) 若在初始化过程中需要覆盖（取消）finalize()，请记住调用super.finalize()（若Object属于我们的直接超类，则无此必要）。在对finalize()进行覆盖的过程中，对super.finalize()的调用应属于最后一个行动，而不应是第一个行动，这样可确保在需要基础类组件的时候它们依然有效。     </p>
<p>(17) 创建大小固定的对象集合时，请将它们传输至一个数组（若准备从一个方法里返回这个集合，更应如此操作）。这样一来，我们就可享受到数组在编译期进行类型检查的好处。此外，为使用它们，数组的接收者也许并不需要将对象”造型”到数组里。     </p>
<p>(18) 尽量使用interfaces，不要使用abstract类。若已知某样东西准备成为一个基础类，那么第一个选择应是将其变成一个interface（接口）。只有在不得不使用方法定义或者成员变量的时候，才需要将其变成一个abstract（抽象）类。接口主要描述了客户希望做什么事情，而一个类则致力于（或允许）具体的实施细节。     </p>
<p>(19) 在构建器内部，只进行那些将对象设为正确状态所需的工作。尽可能地避免调用其他方法，因为那些方法可能被其他人覆盖或取消，从而在构建过程中产生不可预知的结果（参见第7章的详细说明）。     </p>
<p>(20) 对象不应只是简单地容纳一些数据；它们的行为也应得到良好的定义。     </p>
<p>(21) 在现成类的基础上创建新类时，请首先选择”新建”或”创作”。只有自己的设计要求必须继承时，才应考虑这方面的问题。若在本来允许新建的场合使用了继承，则整个设计会变得没有必要地复杂。     </p>
<p>(22) 用继承及方法覆盖来表示行为间的差异，而用字段表示状态间的区别。一个非常极端的例子是通过对不同类的继承来表示颜色，这是绝对应该避免的：应直接使用一个”颜色”字段。     </p>
<p>(23) 为避免编程时遇到麻烦，请保证在自己类路径指到的任何地方，每个名字都仅对应一个类。否则，编译器可能先找到同名的另一个类，并报告出错消息。若怀疑自己碰到了类路径问题，请试试在类路径的每一个起点，搜索一下同名的.class文件。     </p>
<p>(24) 在Java 1.1 AWT中使用事件”适配器”时，特别容易碰到一个陷阱。若覆盖了某个适配器方法，同时拼写方法没有特别讲究，最后的结果就是新添加一个方法，而不是覆盖现成方法。然而，由于这样做是完全合法的，所以不会从编译器或运行期系统获得任何出错提示–只不过代码的工作就变得不正常了。     </p>
<p>(25) 用合理的设计方案消除”伪功能”。也就是说，假若只需要创建类的一个对象，就不要提前限制自己使用应用程序，并加上一条”只生成其中一个”注释。请考虑将其封装成一个”独生子”的形式。若在主程序里有大量散乱的代码，用于创建自己的对象，请考虑采纳一种创造性的方案，将些代码封装起来。     </p>
<p>(26) 警惕”分析瘫痪”。请记住，无论如何都要提前了解整个项目的状况，再去考察其中的细节。由于把握了全局，可快速认识自己未知的一些因素，防止在考察细节的时候陷入”死逻辑”中。     </p>
<p>(27) 警惕”过早优化”。首先让它运行起来，再考虑变得更快–但只有在自己必须这样做、而且经证实在某部分代码中的确存在一个性能瓶颈的时候，才应进行优化。除非用专门的工具分析瓶颈，否则很有可能是在浪费自己的时间。性能提升的隐含代价是自己的代码变得难于理解，而且难于维护。     </p>
<p>(28) 请记住，阅读代码的时间比写代码的时间多得多。思路清晰的设计可获得易于理解的程序，但注释、细致的解释以及一些示例往往具有不可估量的价值。无论对你自己，还是对后来的人，它们都是相当重要的。如对此仍有怀疑，那么请试想自己试图从联机Java文档里找出有用信息时碰到的挫折，这样或许能将你说服。     </p>
<p>(29) 如认为自己已进行了良好的分析、设计或者实施，那么请稍微更换一下思维角度。试试邀请一些外来人士–并不一定是专家，但可以是来自本公司其他部门的人。请他们用完全新鲜的眼光考察你的工作，看看是否能找出你一度熟视无睹的问题。采取这种方式，往往能在最适合修改的阶段找出一些关键性的问题，避免产品发行后再解决问题而造成的金钱及精力方面的损失。     </p>
<p>(30) 良好的设计能带来最大的回报。简言之，对于一个特定的问题，通常会花较长的时间才能找到一种最恰当的解决方案。但一旦找到了正确的方法，以后的工作就轻松多了，再也不用经历数小时、数天或者数月的痛苦挣扎。我们的努力工作会带来最大的回报（甚至无可估量）。而且由于自己倾注了大量心血，最终获得一个出色的设计方案，成功的快感也是令人心动的。坚持抵制草草完工的诱惑–那样做往往得不偿失。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>最美的风景，一直在路上</title>
    <url>/2013/12/in-the-way/</url>
    <content><![CDATA[<p>人生的长卷在向远方铺开，无论你是伤春悲秋，还是留恋不舍，都阻挡不了它前行的脚步。独自走在路上，看沿途的风景，经历让我们学会了欣赏，学会了感恩，学会了现实和自持，也学会了删繁就简，安然生活。感谢所有的相遇和别离，就像时光刻在心底的纹路，也曾伤感过，惆怅过，但留下更多是温暖。</p>
<span id="more"></span>

<p>季节的转角处，觅一处静好，将心停靠，指上的光阴，静默不语，心上的阳光，与爱同在。流年，安之若素；记忆，温暖而绵长。若人生是一场旅行，那么无论繁华与落寂，都是过眼烟云，留下的是看风景的心情，有时候，让我们念念不忘的，也仅仅只是路过的风景。</p>
<p>盈一份洒脱，看人间冷暖，用素心素笔，写下暖意的诗行，眉间心上，是过尽千帆的安然。朴素相依的日子，牵起一双不离不弃的手，把如影随形的牵挂，写进岁月的素笺，心在懂得处，爱在回眸的距离，笑容的明媚，便是这一季最幸福的点缀。</p>
<p>人生其实有很多种从容别致的活法，只是我们太过计较，谁能数载春风长在？谁能将春花秋月尽览？若生命是一幅画，最重要的不是浓墨重彩，而是那一笔留白。有些故事的结局，或悲或喜，早有定数，经脉中那曾经的繁华，终会成为过往。过尽千帆，浮沉无我，简单才是人生的真味道。</p>
<p>简单是一种人生境界，是一种自然的流露，是繁华过后的领悟，是删繁就简的一种人生态度。人生在世，总会染上人情世故，沾上人间烟火，简单可以远离尘污，净化心灵，沉淀浮华，回归生命本真，还心灵一片平静，给生活一份从容。人本尘埃，多欲生烦忧，执着会负累，无忧便是净土。</p>
<p>用简单的心境，对待复杂的人生，方能淡看得失，从容入世，潇洒自如，拨开迷雾，拥抱晴天。心变得简单了，世界也就简单了，快乐便会生成。学会简单可以摆脱世事喧嚣，任潮起潮落，世事烦扰，我自安然。简单两个字，渗着智慧，透着静好，是清水涤心的纯净；是心素如简的恬淡；是随遇而安的人生态度，不以物喜，不以己悲，简单似禅。</p>
<p>生活，就是在日复一日的奔波中平淡；在粗茶淡饭中生香；在坎坷挫折中历练；在百味杂陈中安暖。若生命是一场旅途，有既定的路线，也有特定的美丽，重要的是看风景的心情，最美的不在终点，而在沿途的芬芳，无论顺境或逆境，都是岁月的一种恩赐。</p>
<p>所有的伤痛，都是通往幸福的必经之路；曾经的悲喜，都会随着时间的流逝，学会和过往温柔拥抱，体味岁月的静好，品尝一杯茶的清香；一只曲子的优美，用微笑去接纳生活中的不如意，用感恩的心为自己储存幸福，让日子在快乐中流淌，最美的便是历经风霜雪雨后的微笑。</p>
<p>人生的路，可以是笔直的大路，也会有纵横交错的小路；会经历风霜雪雨，也会有艳阳高照；会邂逅一朵花的灿烂，也会有满眼枯黄的凋零；会有细水长流的陪伴，也会有物是人非的薄凉；会有不期而遇的惊喜，也会有不得不告别的风景；会有曲曲折折的阻挠，也会有峰回路转的转机；会有世事纷扰的困惑，也会有对未来的憧憬与展望。</p>
<p>穿越世俗繁华的彼岸，寻一个搁浅遗憾的沙滩，所有的经历，都是岁月酿成的一坛酒，何必伤感于一朵花的凋零，何必悲悯于落红的无情，只要珍惜过，就该对着阳光微笑，经历了繁华与落寂，走过聚散依依的旅途，到最后能够支撑起内心的，只有自己，只要有随遇而安的心境，再遥远的路，也会走的安定从容。</p>
<p>站在季节之外，心于明媚处，拥一米阳光，揽一份暖意，让思绪静静的在时光中倘佯，聆听岁月温柔的呓语，感知静谧的纯净与通透。一份清浅，飞舞于指尖；淡淡的花香，在心中萦绕，尽情享受生命所赋予我们的美好。</p>
<p>人生有很多驿站，只要内心是安静的，无论是站在红尘外，静赏繁华，还是在尘世烟火中，百味尝尽，都会多了一份淡定与从容。尘世间的一切，来了开怀拥抱，走了挥手作别，只要心中有爱，看一场烟花的绚烂，或守一段细水长流的平淡，皆是美好。一直相信，有多少爱，就会有多少温暖，只要懂得，便是慈悲，爱是一盏灯，照亮别人，温暖自己。心怀感恩，让人生多一些暖色，每一个有爱的日子都是幸福。</p>
<p>生命的点滴，在细碎的流年光影中,被不动声色的记录。生活，在相遇与别离中继续，所有的平平仄仄，都会随着岁月的流逝而淡定从容。铺纸一素笺,写下温情的字眼，让思绪伴着阳光翩飞，让温暖牵住指尖的明媚，以一颗平常心，在简单的平淡中，演绎着稍纵即逝的美。</p>
<p>光与影交错的瞬间，总有些欣喜，如手指轻轻拈起蝴蝶的羽翼，触手可及。盈一份感悟，在属于自己的世界里，把握住自己的人生轨迹，以人淡如菊的方式，微笑着和过往说别离，做时光最从容的过客，因为最美的风景，一直在路上。</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的eval()函数</title>
    <url>/2013/12/javascript-eval/</url>
    <content><![CDATA[<p> 和其他很多解释性语言一样，JavaScript同样可以解释运行由JavaScript源代码组成的字符串，并产生一个值。JavaScript通过全局函数eval()来完成这个工作。</p>
<span id="more"></span>
<p>eval(“1+2”)，-&gt;3</p>
<p> 动态判断源代码中的字符串是一种很强大的语言特性，几乎没有必要在实际中应用。如果你使用了eval()，你应当仔细考虑是否真的需要使用它。</p>
<p>一、eval()是一个函数还是一个运算符</p>
<p>eval()是一个函数，但由于它已经被当成运算符来对待了。。JavaScript语言的早期版本定义了eval函数，现代JavaScript解释器进行了大量的代码分析和优化。而eval的问题在于，用于动态执行的代码通常来讲不能分析，换句话说，如果一个函数调用了eval，那么解释器将无法对这个函数做进一步优化，而将eval定义为函数的另一个问题是，它可以被赋予其他的名字，var f=eval；那么解释器就无法放心的优化任何调用了f()的函数。而当eval是一个运算符的时候，就可以避免这些问题。</p>
<p>二、eval()</p>
<p>eval()只有一个参数。如果传入的参数不是字符串，它直接返回这个函数。如果参数是字符串，它会把字符串当成JavaScript代码进行编译，如果编译失败者抛出一个语法错误异常。如果编译成功，则开始执行这一段代码，并返回字符串中的最后一个表达式会或语句的值，如果最后一个表达式或语句没有值，则最终返回undefined。如果字符串抛出一个异常，这个异常将把该调用传递给eval()。</p>
<p>关于eval最重要的是，它使用了调用它的变量作用域环境。也就是说，它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样。如果一个函数定义了一个局部变量x，然后调用eval(“x”)，它会返回局部变量的值。如果它调用eval(“x=1”)，它会改变局部变量的值。如果函数调用了eval(“var y=2;”),它声明了一个新的局部变量y，同样地，一个函数可以通过如下代码声明一个局部变量：</p>
<p><code>eval(&quot;function f()&#123;return x+1;&#125;&quot;);</code></p>
<p>如果在最顶层的代码中调用eval，当然，它会作用于全局变量和全局函数。</p>
<p>需要注意的是，传递给eval的字符串必须在语法上将的通，不能通过eval往函数中任意粘贴代码片段，比如：eval(“return ;”)是没有意义的，因为return只有在函数中才起到作用，并且事实上，eval的字符串执行时的上下文环境和调用函数的上下文环境是一样的，这不能使其作为函数的一部分来运行。如果字符串作为一个单独的脚本是有语义的，那么将其传递给eval作参数是完全没有问题的，否则，eval会抛出语法错误异常。</p>
<p>三、全局eval()</p>
<p>eval()具有更改布局变量的能力，这对于JavaScript优化器来说是一个很大的问题。然而作为一种权宜之计，JavaScript解释器针对那些调用了eval的函数所做的优化并不多。但当脚本定义了eval的一个别名，且用另一个名称调用它，JavaScript解释器又会如何工作呢？为了让JavaScript解释器的实现更加简化，ECMAScript3标准规定了任何解释器都不允许对eval赋予别名。如果eval函数通过别名调用的话，则会抛出一个EavlError异常。</p>
<p>实际上，大多数的实现并不是这么做的。当通过别名调用时，eval会将其字符串当成顶层的全局代码来执行。执行的代码可能会定义新的全局变量和全局函数，或者给全局变量赋值，但却不能使用或者修改主调函数中的局部变量，因此，这不会影响到函数内的代码优化。</p>
<p>ECMAScript5是反对使用EavlError的，并且规范了eval的行为，”直接的eval”，当直接使用非限定的”eval”名称来调用eval()函数时，通常称为”直接eval”。直接调用eval()时，它总是在调用它的上下文作用域内执行。其他的间接调用则使用全局对象作为其上下文作用域，并且无法读、写、定义局部变量和函数。下面有一段示例代码：</p>
<pre><code class="js">var geval=eval;                //使用别名调用evla将是全局eval
var x=&quot;global&quot;,y=&quot;global&quot;;    //两个全局变量
function f()&#123;                //函数内执行的是局部eval
    var x=&quot;local&quot;;            //定义局部变量
    eval(&quot;x += &#39; chenged&#39;;&quot;);//直接使用eval改变的局部变量的值
    return x;                //返回更改后的局部变量
&#125;
Function g()&#123;                //这个函数内执行了全局eval
    var y=&quot;local&quot;;
    geval(&quot;y += &#39; changed&#39;;&quot;); //直接调用改变了全局变量的值
    return y;
&#125;
console.log(f(),x);            //改变了布局变了，输出 &quot;local changed global&quot;
console.log(g(),y);            //改变了全局变量，输出    &quot;local global changed&quot;
</code></pre>
<p>全局的eval的这些行为不仅仅是处于代码优化其的需要而作出的一种折中方案，它实际上是一种非常有用的特性，它允许我们执行那些对上下文没有任何依赖的全局脚本代码段。真正需要eval来执行代码段的场景并不多见。但当你真的意识到它的必要性的时候，你更可能会使用全局eval而不是局部eval。</p>
<p>四、严格eval()</p>
<p>ECMAScript5严格模式对eval()函数的行为施加了更多的限制，甚至对标识符eval的使用也施加了限制。当在严格模式下调用eval时，或者eval执行的代码段以”Use strict” 指令开始，这里的eval是私有上下文环境中的局部eval。也就是说，在严格模式下，eval执行的代码段可以查询或更改局部变量，但不能在局部作用域中定义新的变量或函数。</p>
<p>此外，严格模式将”eval”列为保留字，这让eval()更像一个运算符。不能用一个别名覆盖eval()函数。并且变量名，函数名。函数参数或者异常捕获的参数都不能取名为eval。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>eval</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Maven插件介绍</title>
    <url>/2013/12/maven-plugins/</url>
    <content><![CDATA[<p>我们都知道Maven本质上是一个插件框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成，例如编译源代码是由maven- compiler-plugin完成的。进一步说，每个任务对应了一个插件目标（goal），每个插件会有一个或者多个目标，例如maven- compiler-plugin的compile目标用来编译位于<code>src/main/java/</code>目录下的主源码，testCompile目标用来编译位于<code>src/test/java/</code>目录下的测试源码。</p>
<p>用户可以通过两种方式调用Maven插件目标。第一种方式是将插件目标与生命周期阶段（lifecycle phase）绑定，这样用户在命令行只是输入生命周期阶段而已，例如Maven默认将maven-compiler-plugin的compile目标与 compile生命周期阶段绑定，因此命令<code>mvn compile</code>实际上是先定位到compile这一生命周期阶段，然后再根据绑定关系调用maven-compiler-plugin的compile目标。第二种方式是直接在命令行指定要执行的插件目标，例如<code>mvn archetype:generate</code> 就表示调用maven-archetype-plugin的generate目标，这种带冒号的调用方式与生命周期无关。</p>
<span id="more"></span>
<p>认识上述Maven插件的基本概念能帮助你理解Maven的工作机制，不过要想更高效率地使用Maven，了解一些常用的插件还是很有必要的，这可 以帮助你避免一不小心重新发明轮子。多年来Maven社区积累了大量的经验，并随之形成了一个成熟的插件生态圈。Maven官方有两个插件列表，第一个列 表的GroupId为org.apache.maven.plugins，这里的插件最为成熟，具体地址为：<a href="http://maven.apache.org/plugins/index.html">http://maven.apache.org/plugins/index.html</a>。第二个列表的GroupId为org.codehaus.mojo，这里的插件没有那么核心，但也有不少十分有用，其地址为：<a href="http://mojo.codehaus.org/plugins.html">http://mojo.codehaus.org/plugins.html</a>。</p>
<p>接下来笔者根据自己的经验介绍一些最常用的Maven插件，在不同的环境下它们各自都有其出色的表现，熟练地使用它们能让你的日常构建工作事半功倍。</p>
<h3 id="maven-antrun-plugin"><a href="#maven-antrun-plugin" class="headerlink" title="maven-antrun-plugin"></a>maven-antrun-plugin</h3><p><a href="http://maven.apache.org/plugins/maven-antrun-plugin/">http://maven.apache.org/plugins/maven-antrun-plugin/</a></p>
<p>maven-antrun-plugin能让用户在Maven项目中运行Ant任务。用户可以直接在该插件的配置以Ant的方式编写Target， 然后交给该插件的run目标去执行。在一些由Ant往Maven迁移的项目中，该插件尤其有用。此外当你发现需要编写一些自定义程度很高的任务，同时又觉 得Maven不够灵活时，也可以以Ant的方式实现之。maven-antrun-plugin的run目标通常与生命周期绑定运行。</p>
<h3 id="maven-archetype-plugin"><a href="#maven-archetype-plugin" class="headerlink" title="maven-archetype-plugin"></a>maven-archetype-plugin</h3><p><a href="http://maven.apache.org/archetype/maven-archetype-plugin/">http://maven.apache.org/archetype/maven-archetype-plugin/</a></p>
<p>Archtype指项目的骨架，Maven初学者最开始执行的Maven命令可能就是<code>mvn archetype:generate</code>，这实际上就是让maven-archetype-plugin生成一个很简单的项目骨架，帮助开发者快速上手。可能也有人看到一些文档写了<code>mvn archetype:create</code>， 但实际上create目标已经被弃用了，取而代之的是generate目标，该目标使用交互式的方式提示用户输入必要的信息以创建项目，体验更好。 maven-archetype-plugin还有一些其他目标帮助用户自己定义项目原型，例如你由一个产品需要交付给很多客户进行二次开发，你就可以为 他们提供一个Archtype，帮助他们快速上手。</p>
<h3 id="maven-assembly-plugin"><a href="#maven-assembly-plugin" class="headerlink" title="maven-assembly-plugin"></a>maven-assembly-plugin</h3><p><a href="http://maven.apache.org/plugins/maven-assembly-plugin/">http://maven.apache.org/plugins/maven-assembly-plugin/</a></p>
<p>maven-assembly-plugin的用途是制作项目分发包，该分发包可能包含了项目的可执行文件、源代码、readme、平台脚本等等。 maven-assembly-plugin支持各种主流的格式如zip、tar.gz、jar和war等，具体打包哪些文件是高度可控的，例如用户可以 按文件级别的粒度、文件集级别的粒度、模块级别的粒度、以及依赖级别的粒度控制打包，此外，包含和排除配置也是支持的。maven-assembly- plugin要求用户使用一个名为<code>assembly.xml</code>的元数据文件来表述打包，它的single目标可以直接在命令行调用，也可以被绑定至生命周期。</p>
<h3 id="maven-dependency-plugin"><a href="#maven-dependency-plugin" class="headerlink" title="maven-dependency-plugin"></a>maven-dependency-plugin</h3><p><a href="http://maven.apache.org/plugins/maven-dependency-plugin/">http://maven.apache.org/plugins/maven-dependency-plugin/</a></p>
<p>maven-dependency-plugin最大的用途是帮助分析项目依赖，<code>dependency:list</code>能够列出项目最终解析到的依赖列表，<code>dependency:tree</code>能进一步的描绘项目依赖树，<code>dependency:analyze</code>可以告诉你项目依赖潜在的问题，如果你有直接使用到的却未声明的依赖，该目标就会发出警告。maven-dependency-plugin还有很多目标帮助你操作依赖文件，例如<code>dependency:copy-dependencies</code>能将项目依赖从本地Maven仓库复制到某个特定的文件夹下面。</p>
<h3 id="maven-enforcer-plugin"><a href="#maven-enforcer-plugin" class="headerlink" title="maven-enforcer-plugin"></a>maven-enforcer-plugin</h3><p><a href="http://maven.apache.org/plugins/maven-enforcer-plugin/">http://maven.apache.org/plugins/maven-enforcer-plugin/</a></p>
<p>在一个稍大一点的组织或团队中，你无法保证所有成员都熟悉Maven，那他们做一些比较愚蠢的事情就会变得很正常，例如给项目引入了外部的 SNAPSHOT依赖而导致构建不稳定，使用了一个与大家不一致的Maven版本而经常抱怨构建出现诡异问题。maven-enforcer- plugin能够帮助你避免之类问题，它允许你创建一系列规则强制大家遵守，包括设定Java版本、设定Maven版本、禁止某些依赖、禁止 SNAPSHOT依赖。只要在一个父POM配置规则，然后让大家继承，当规则遭到破坏的时候，Maven就会报错。除了标准的规则之外，你还可以扩展该插 件，编写自己的规则。maven-enforcer-plugin的enforce目标负责检查规则，它默认绑定到生命周期的validate阶段。</p>
<h3 id="maven-help-plugin"><a href="#maven-help-plugin" class="headerlink" title="maven-help-plugin"></a>maven-help-plugin</h3><p><a href="http://maven.apache.org/plugins/maven-help-plugin/">http://maven.apache.org/plugins/maven-help-plugin/</a></p>
<p>maven-help-plugin是一个小巧的辅助工具，最简单的<code>help:system</code>可以打印所有可用的环境变量和Java系统属性。<code>help:effective-pom</code>和<code>help:effective-settings</code>最 为有用，它们分别打印项目的有效POM和有效settings，有效POM是指合并了所有父POM（包括Super POM）后的XML，当你不确定POM的某些信息从何而来时，就可以查看有效POM。有效settings同理，特别是当你发现自己配置的 settings.xml没有生效时，就可以用<code>help:effective-settings</code>来验证。此外，maven-help-plugin的describe目标可以帮助你描述任何一个Maven插件的信息，还有all-profiles目标和active-profiles目标帮助查看项目的Profile。</p>
<h3 id="maven-release-plugin"><a href="#maven-release-plugin" class="headerlink" title="maven-release-plugin"></a>maven-release-plugin</h3><p><a href="http://maven.apache.org/plugins/maven-release-plugin/">http://maven.apache.org/plugins/maven-release-plugin/</a></p>
<p>maven-release-plugin的用途是帮助自动化项目版本发布，它依赖于POM中的SCM信息。<code>release:prepare</code>用来准备版本发布，具体的工作包括检查是否有未提交代码、检查是否有SNAPSHOT依赖、升级项目的SNAPSHOT版本至RELEASE版本、为项目打标签等等。<code>release:perform</code>则 是签出标签中的RELEASE源码，构建并发布。版本发布是非常琐碎的工作，它涉及了各种检查，而且由于该工作仅仅是偶尔需要，因此手动操作很容易遗漏一 些细节，maven-release-plugin让该工作变得非常快速简便，不易出错。maven-release-plugin的各种目标通常直接在 命令行调用，因为版本发布显然不是日常构建生命周期的一部分。</p>
<h3 id="maven-resources-plugin"><a href="#maven-resources-plugin" class="headerlink" title="maven-resources-plugin"></a>maven-resources-plugin</h3><p><a href="http://maven.apache.org/plugins/maven-resources-plugin/">http://maven.apache.org/plugins/maven-resources-plugin/</a></p>
<p>为了使项目结构更为清晰，Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码，maven-resources-plugin则用来处理资源文件。默认的主资源文件目录是<code>src/main/resources</code>，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置maven-resources-plugin来实现。此外，资源文件过滤也是Maven的一大特性，你可以在资源文件中使用_${propertyName}_形式的Maven属性，然后配置maven-resources-plugin开启对资源文件的过滤，之后就可以针对不同环境通过命令行或者Profile传入属性的值，以实现更为灵活的构建。</p>
<h3 id="maven-surefire-plugin"><a href="#maven-surefire-plugin" class="headerlink" title="maven-surefire-plugin"></a>maven-surefire-plugin</h3><p><a href="http://maven.apache.org/plugins/maven-surefire-plugin/">http://maven.apache.org/plugins/maven-surefire-plugin/</a></p>
<p>可能是由于历史的原因，Maven 2/3中用于执行测试的插件不是maven-test-plugin，而是maven-surefire-plugin。其实大部分时间内，只要你的测试 类遵循通用的命令约定（以Test结尾、以TestCase结尾、或者以Test开头），就几乎不用知晓该插件的存在。然而在当你想要跳过测试、排除某些 测试类、或者使用一些TestNG特性的时候，了解maven-surefire-plugin的一些配置选项就很有用了。例如<code>mvn test -Dtest=FooTest</code>这样一条命令的效果是仅运行FooTest测试类，这是通过控制maven-surefire-plugin的test参数实现的。</p>
<h3 id="build-helper-maven-plugin"><a href="#build-helper-maven-plugin" class="headerlink" title="build-helper-maven-plugin"></a>build-helper-maven-plugin</h3><p><a href="http://mojo.codehaus.org/build-helper-maven-plugin/">http://mojo.codehaus.org/build-helper-maven-plugin/</a></p>
<p>Maven默认只允许指定一个主Java代码目录和一个测试Java代码目录，虽然这其实是个应当尽量遵守的约定，但偶尔你还是会希望能够指定多个 源码目录（例如为了应对遗留项目），build-helper-maven-plugin的add-source目标就是服务于这个目的，通常它被绑定到 默认生命周期的generate-sources阶段以添加额外的源码目录。需要强调的是，这种做法还是不推荐的，因为它破坏了 Maven的约定，而且可能会遇到其他严格遵守约定的插件工具无法正确识别额外的源码目录。</p>
<p>build-helper-maven-plugin的另一个非常有用的目标是attach-artifact，使用该目标你可以以classifier的形式选取部分项目文件生成附属构件，并同时install到本地仓库，也可以deploy到远程仓库。</p>
<h3 id="exec-maven-plugin"><a href="#exec-maven-plugin" class="headerlink" title="exec-maven-plugin"></a>exec-maven-plugin</h3><p><a href="http://mojo.codehaus.org/exec-maven-plugin/">http://mojo.codehaus.org/exec-maven-plugin/</a></p>
<p>exec-maven-plugin很好理解，顾名思义，它能让你运行任何本地的系统程序，在某些特定情况下，运行一个Maven外部的程序可能就是最简单的问题解决方案，这就是<code>exec:exec</code>的 用途，当然，该插件还允许你配置相关的程序运行参数。除了exec目标之外，exec-maven-plugin还提供了一个java目标，该目标要求你 提供一个mainClass参数，然后它能够利用当前项目的依赖作为classpath，在同一个JVM中运行该mainClass。有时候，为了简单的 演示一个命令行Java程序，你可以在POM中配置好exec-maven-plugin的相关运行参数，然后直接在命令运行<code>mvn exec:java</code> 以查看运行效果。</p>
<h3 id="jetty-maven-plugin"><a href="#jetty-maven-plugin" class="headerlink" title="jetty-maven-plugin"></a>jetty-maven-plugin</h3><p><a href="http://wiki.eclipse.org/Jetty/Feature/Jetty_Maven_Plugin">http://wiki.eclipse.org/Jetty/Feature/Jetty_Maven_Plugin</a></p>
<p>在进行Web开发的时候，打开浏览器对应用进行手动的测试几乎是无法避免的，这种测试方法通常就是将项目打包成war文件，然后部署到Web容器 中，再启动容器进行验证，这显然十分耗时。为了帮助开发者节省时间，jetty-maven-plugin应运而生，它完全兼容 Maven项目的目录结构，能够周期性地检查源文件，一旦发现变更后自动更新到内置的Jetty Web容器中。做一些基本配置后（例如Web应用的contextPath和自动扫描变更的时间间隔），你只要执行<code>mvn jetty:run</code>，然后在IDE中修改代码，代码经IDE自动编译后产生变更，再由jetty-maven-plugin侦测到后更新至Jetty容器，这时你就可以直接 测试Web页面了。需要注意的是，jetty-maven-plugin并不是宿主于Apache或Codehaus的官方插件，因此使用的时候需要额外 的配置<code>settings.xml</code>的pluginGroups元素，将org.mortbay.jetty这个pluginGroup加入。</p>
<h3 id="versions-maven-plugin"><a href="#versions-maven-plugin" class="headerlink" title="versions-maven-plugin"></a>versions-maven-plugin</h3><p><a href="http://mojo.codehaus.org/versions-maven-plugin/">http://mojo.codehaus.org/versions-maven-plugin/</a></p>
<p>很多Maven用户遇到过这样一个问题，当项目包含大量模块的时候，为他们集体更新版本就变成一件烦人的事情，到底有没有自动化工具能帮助完成这件 事情呢？（当然你可以使用sed之类的文本操作工具，不过不在本文讨论范围）答案是肯定的，versions-maven- plugin提供了很多目标帮助你管理Maven项目的各种版本信息。例如最常用的，命令<code>mvn versions:set -DnewVersion=1.1-SNAPSHOT</code>就能帮助你把所有模块的版本更新到1.1-SNAPSHOT。该插件还提供了其他一些很有用的目标，display-dependency- updates能告诉你项目依赖有哪些可用的更新；类似的display-plugin-updates能告诉你可用的插件更新；然后use- latest-versions能自动帮你将所有依赖升级到最新版本。最后，如果你对所做的更改满意，则可以使用<code>mvn versions:commit</code> 提交，不满意的话也可以使用<code>mvn versions:revert</code>进行撤销。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文介绍了一些最常用的Maven插件，这里指的常用是指经常需要进行配置的插件，事实上我们用Maven的时候很多其它插件也是必须的，例如 默认的编译插件maven-compiler-plugin和默认的打包插件maven-jar-plugin，但因为很少需要对它们进行配置，因此不在 本文讨论范围。了解常用的Maven插件能帮助你事倍功半地完成项目构建任务，反之你就可能会因为经常遇到一些难以解决的问题而感到沮丧。本文介绍的插件 基本能覆盖大部分Maven用户的日常使用需要，如果你真有非常特殊的需求，自行编写一个Maven插件也不是难事，更何况还有这么多开放源代码的插件供 你参考。</p>
<p>本文的这个插件列表并不是一个完整列表，读者有兴趣的话也可以去仔细浏览一下Apache和Codehaus Mojo的Maven插件列表，以的到一个更为全面的认识。最后，在线的Maven仓库搜索引擎如<a href="http://search.maven.org/">http://search.maven.org/</a>也能帮助你快速找到自己感兴趣的Maven插件。</p>
<p>来源：<a href="http://www.juvenxu.com/2011/05/11/infoq-maven-most-used-maven-plugins-a/">http://www.juvenxu.com/2011/05/11/infoq-maven-most-used-maven-plugins-a/</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>插件</tag>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle数据库常用SQL语句</title>
    <url>/2013/12/oracle-sql/</url>
    <content><![CDATA[<p>日常工作中常用到的sql语句，现总结如下，留作日后查看。</p>
<span id="more"></span>
<h4 id="1、按照两列中的最大值取-，只取两列其中的一列"><a href="#1、按照两列中的最大值取-，只取两列其中的一列" class="headerlink" title="1、按照两列中的最大值取 ，只取两列其中的一列"></a>1、按照两列中的最大值取 ，只取两列其中的一列</h4><pre><code class="sql">SELECT *  FROM t_doc T  ORDER BY GREATEST(T.Load_Count,T.Read_Count) desc
</code></pre>
<h4 id="2、取两列之和"><a href="#2、取两列之和" class="headerlink" title="2、取两列之和"></a>2、取两列之和</h4><pre><code class="sql">select  t.*,(nvl(T.Load_Count,0)+nvl(T.Read_Count,0 )) as c FROM t_doc T   order by c desc
</code></pre>
<h4 id="3、取两列字符串连接"><a href="#3、取两列字符串连接" class="headerlink" title="3、取两列字符串连接"></a>3、取两列字符串连接</h4><pre><code class="sql">select T.Load_Count||T.Read_Count FROM t_doc T
</code></pre>
<h4 id="4、获取oracle数据库当前用户下所有表名和表名的注释"><a href="#4、获取oracle数据库当前用户下所有表名和表名的注释" class="headerlink" title="4、获取oracle数据库当前用户下所有表名和表名的注释"></a>4、获取oracle数据库当前用户下所有表名和表名的注释</h4><pre><code class="sql">select a.TABLE_NAME,b.COMMENTS
from user_tables a,user_tab_comments b
WHERE a.TABLE_NAME=b.TABLE_NAME
order by TABLE_NAME
</code></pre>
<h4 id="5、两列结果合并为一列输出（两列数据类型必须一样）"><a href="#5、两列结果合并为一列输出（两列数据类型必须一样）" class="headerlink" title="5、两列结果合并为一列输出（两列数据类型必须一样）"></a>5、两列结果合并为一列输出（两列数据类型必须一样）</h4><pre><code class="sql">select a from tb
union all
select b from tb
</code></pre>
<h4 id="6、将一列多行拼接成一行"><a href="#6、将一列多行拼接成一行" class="headerlink" title="6、将一列多行拼接成一行"></a>6、将一列多行拼接成一行</h4><pre><code class="sql">select wmsys.wm_concat(name) from table_name
//wmsys.wm_concat()拼接字段 以逗号分开
</code></pre>
<h4 id="7、-不是-SELECTed-表达式"><a href="#7、-不是-SELECTed-表达式" class="headerlink" title="7、 不是 SELECTed 表达式"></a>7、 不是 SELECTed 表达式</h4><p>Oracle 数据库，执行下面语句出现错误“ORA-01791: 不是 SELECTed 表达式”：</p>
<pre><code class="sql">select distinct t.name from auth_employee t order by t.auth_employee_id asc
</code></pre>
<p>原来：SELECT语句中含有DISTINCT关键字或者有运算符时，排序用字段必须与SELECT语句中的字段相对应。<br>网上搜到解释如下：<br>在ORDER BY中指定多个列，结果将先按照子句中的第一列排序，然后第二个，依此类推。<br>在SELECT中未出现的列名也可用于ORDER BY 子句中，只要TABLE中有就行。<br>但如果SELECT子句中出现了DISTINCT关键字，则只能用出现过的列名，<br>而且如果SELECT子句中使用了任何运算符，在ORDER BY 子句中必须保持和SELECT子句中表达式完全一致，否则出现错误：“ORA-01791: 不是 SELECTed 表达式”。</p>
<h4 id="8、查询数据库表的建表时间"><a href="#8、查询数据库表的建表时间" class="headerlink" title="8、查询数据库表的建表时间"></a>8、查询数据库表的建表时间</h4><pre><code class="sql">SELECT OBJECT_NAME,CREATED FROM USER_OBJECTS
    WHERE object_type = &#39;TABLE&#39; ORDER BY  CREATED DESC
</code></pre>
<h4 id="9、查询序列的当前值"><a href="#9、查询序列的当前值" class="headerlink" title="9、查询序列的当前值"></a>9、查询序列的当前值</h4><pre><code class="sql">select ANALYSIS_FIX_SEQ.currval  from dual (注：此sql只能在nextval之后才可以使用)
select last_number from User_Sequences where sequence_name=&#39;ANALYSIS_FIX_SEQ&#39;
</code></pre>
<h4 id="10、恢复误删除的数据"><a href="#10、恢复误删除的数据" class="headerlink" title="10、恢复误删除的数据"></a>10、恢复误删除的数据</h4><pre><code class="sql">create table quick as
SELECT * FROM T_LOCATION_ALARM AS  OF TIMESTAMP  
to_timestamp(&#39;2013-11-29 11:00:00&#39;, &#39;yyyy-mm-dd hh24:mi:ss&#39;);
</code></pre>
<p>这样可以查询到这个时间点的数据</p>
<h4 id="11、恢复误删除的PL-SQL对象"><a href="#11、恢复误删除的PL-SQL对象" class="headerlink" title="11、恢复误删除的PL/SQL对象"></a>11、恢复误删除的PL/SQL对象</h4><pre><code class="sql">SELECT  r.object_name ,r.original_name,r.operation ,r.droptime
FROM user_recyclebin  r order by droptime desc;
</code></pre>
<p>通过这个sql就可以查询到已经删除的对象。</p>
<p>再通过下面这个sql就可以查询到对象的内容，不过需要管理权限</p>
<pre><code class="sql">SELECT NAME, TEXT FROM DBA_SOURCE AS OF TIMESTAMP
TO_TIMESTAMP(&#39;2013-11-29:11:20:15&#39;, &#39;yyyy-mm-dd hh24:mi:ss&#39;)
</code></pre>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>数据库</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2013/12/paixusuanfa/</url>
    <content><![CDATA[<p>最近开始研读算法导论，刚开始看，对于排序算法在这之前就不叫熟悉冒泡算法，对其他的算法也只是有所耳闻，并未深入研究。看过书后才知道还有这么多算法，先总结一下，留着日后查看，先了解算法原理，对于性能效率等问题先不研究了。</p>
<span id="more"></span>
<h3 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h3><p> 有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法–插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外，而第二部分就只包含这一个元素。在第一部分排序后，再把这个最后元素插入到此刻已是有序的第一部分里的位置。</p>
<p> 简单的说就像是在玩扑克牌的时候，先抓一张牌，抓第二张牌的时候就先跟手上的牌比一下，然后插到一个合适的位置，整个牌就是有序的了。</p>
<p>具体算法描述如下：</p>
<p>⒈ 从第一个元素开始，该元素可以认为已经被排序</p>
<p>⒉ 取出下一个元素，在已经排序的元素序列中从后向前扫描</p>
<p>⒊ 如果该元素（已排序）大于新元素，将该元素移到下一位置</p>
<p>⒋ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</p>
<p>⒌ 将新元素插入到下一位置中</p>
<p>⒍ 重复步骤2</p>
<p>算法实现：</p>
<pre><code class="java">int[] abs=new int[]&#123;5,35,69,38,41,2,11,85&#125;;
for(int i=0;i&lt;abs.length;i++)&#123;
    int j=i;
    int temp=abs[i];
    while(j&gt;0 &amp;&amp; temp&lt;abs[j-1])&#123;
        abs[j]=abs[j-1];
        j--;
    &#125;
    abs[j]=temp;
&#125;
printf(abs);
</code></pre>
<p>这样结果打印出来的就是排序好的数列。</p>
<h3 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h3><p>这应该是比较常用和简单的算法了。</p>
<p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>冒泡排序算法的运作如下：</p>
<ol>
<li><p> 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p>
</li>
<li><p> 针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li><p> 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
</li>
</ol>
<p>算法实现：</p>
<pre><code class="java">int[] abs=new int[]&#123;5,35,69,38,41,2,11,85&#125;;
for(int i=0;i&lt;abs.length;i++)&#123;
    for(int j=i;j&lt;abs.length;j++)&#123;
        if(abs[i]&gt;abs[j])&#123;
            int tmp=abs[i];
            abs[i]=abs[j];
            abs[j]=tmp;
        &#125;
    &#125;
&#125;
printf(abs);
</code></pre>
<h3 id="3、鸡尾酒排序"><a href="#3、鸡尾酒排序" class="headerlink" title="3、鸡尾酒排序"></a>3、鸡尾酒排序</h3><p>鸡尾酒排序是冒泡排序的一种变形，此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。数组中的数字本是无规律的排放，先找到最小的数字，把他放到第一位，然后找到最大的数字放到最后一位。然后再找到第二小的数字放到第二位，再找到第二大的数字放到倒数第二位。以此类推，直到完成排序。</p>
<p>算法实现：</p>
<pre><code class="java">for(int i = 0 ; i &lt; src.length/2 ; i++)&#123;
for(int j = 0 ; j &lt; src.length-i-1 ; j++)&#123;
    if(src[j] &lt; src[j+1])&#123;
        int temp = src[j];
        src[j] = src[j+1];
        src[j+1] = temp;
    &#125;
System.out.println(&quot;交换小&quot;+Arrays.toString(src));
&#125;
//将最大值排到队头
for(int j = src.length - i -1 ; j &gt; i ; j--)&#123;
    if(src[j] &gt; src[j-1])&#123;
        int temp = src[j];
        src[j] = src[j-1];
        src[j-1] = temp;
    &#125;
System.out.println(&quot;交换大&quot;+Arrays.toString(src));
&#125;
System.out.println(&quot;第&quot;+i+&quot;次排序结果：&quot;+Arrays.toString(src));
&#125;   
</code></pre>
<h3 id="4、二叉排序树"><a href="#4、二叉排序树" class="headerlink" title="4、二叉排序树"></a>4、二叉排序树</h3><p>二叉排序树（Binary Sort Tree）又称二叉查找树。 它或者是一棵空树；或者是具有下列性质的二叉树：</p>
<p>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>（3）左、右子树也分别为二叉排序树。</p>
<h3 id="5、其他排序方法"><a href="#5、其他排序方法" class="headerlink" title="5、其他排序方法"></a>5、其他排序方法</h3><p>排序方法还包括<strong>桶排序、计数排序、合并排序、鸽巢排序、Gnome排序、图书馆排序</strong>。</p>
<p>这些排序方法较为少见，就不详细说明了。</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle中TO_DATE用法</title>
    <url>/2013/12/oracle-todate/</url>
    <content><![CDATA[<p>Oracle中TO_DATE的用法，包括时间格式化以及常用的时间相关函数和方法。</p>
<span id="more"></span>
<p>TO_DATE格式(以时间:2007-11-02   13:45:25为例)</p>
<p>Year:</p>
<pre><code>yy     two digits   两位年                显示值:07
yyy    three digits 三位年                显示值:007
yyyy   four digits  四位年                显示值:2007
</code></pre>
<p>Month:</p>
<pre><code>mm     number       两位月               显示值:11
mon    abbreviated  字符集表示           显示值:11月,若是英文版,显示nov
month  spelled out  字符集表示           显示值:11月,若是英文版,显示november
</code></pre>
<p>Day:</p>
<pre><code>dd     number         当月第几天         显示值:02
ddd    number         当年第几天         显示值:02
dy     abbreviated    当周第几天简写     显示值:星期五,若是英文版,显示fri
day    spelled out    当周第几天全写     显示值:星期五,若是英文版,显示friday
</code></pre>
<p>Hour:</p>
<pre><code>hh     two digits     12小时进制        显示值:01
hh24   two digits     24小时进制        显示值:13
</code></pre>
<p>Minute:</p>
<pre><code>mi    two digits      60进制            显示值:45```

Second:
</code></pre>
<p>ss    two digits      60进制            显示值:25```</p>
<p>其它</p>
<pre><code>Q     digit           季度              显示值:4
WW    digit           当年第几周         显示值:44
W     digit           当月第几周         显示值:1
</code></pre>
<p>24小时格式下时间范围为： 0:00:00 - 23:59:59….</p>
<p>12小时格式下时间范围为： 1:00:00 - 12:59:59….</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><ol>
<li>日期和字符转换函数用法（to_date,to_char）</li>
</ol>
<pre><code class="sql">select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as nowTime from dual;   //日期转化为字符串  
select to_char(sysdate,&#39;yyyy&#39;)  as nowYear   from dual;   //获取时间的年  
select to_char(sysdate,&#39;mm&#39;)    as nowMonth  from dual;   //获取时间的月  
select to_char(sysdate,&#39;dd&#39;)    as nowDay    from dual;   //获取时间的日  
select to_char(sysdate,&#39;hh24&#39;)  as nowHour   from dual;   //获取时间的时  
select to_char(sysdate,&#39;mi&#39;)    as nowMinute from dual;   //获取时间的分  
select to_char(sysdate,&#39;ss&#39;)    as nowSecond from dual;   //获取时间的秒
</code></pre>
<h4 id="2-字符串和时间互转"><a href="#2-字符串和时间互转" class="headerlink" title="2. 字符串和时间互转"></a>2. 字符串和时间互转</h4><pre><code class="sql">select to_date(&#39;2004-05-07 13:23:44&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;) from dual
select to_char( to_date(222,&#39;J&#39;),&#39;Jsp&#39;) from dual //显示Two Hundred Twenty-Two    
</code></pre>
<h4 id="3-求某天是星期几"><a href="#3-求某天是星期几" class="headerlink" title="3.求某天是星期几"></a>3.求某天是星期几</h4><pre><code class="sql">select to_char(to_date(&#39;2002-08-26&#39;,&#39;yyyy-mm-dd&#39;),&#39;day&#39;) from dual;     //星期一     
select to_char(to_date(&#39;2002-08-26&#39;,&#39;yyyy-mm-dd&#39;),&#39;day&#39;,
&#39;NLS_DATE_LANGUAGE = American&#39;) from dual;   // monday   
//设置日期语言     
ALTER SESSION SET NLS_DATE_LANGUAGE=&#39;AMERICAN&#39;;     
//也可以这样     
TO_DATE (&#39;2002-08-26&#39;, &#39;YYYY-mm-dd&#39;, &#39;NLS_DATE_LANGUAGE = American&#39;)    
</code></pre>
<h4 id="4-两个日期间的天数"><a href="#4-两个日期间的天数" class="headerlink" title="4. 两个日期间的天数"></a>4. 两个日期间的天数</h4><pre><code class="sql">select floor(sysdate - to_date(&#39;20020405&#39;,&#39;yyyymmdd&#39;)) from dual;
</code></pre>
<h4 id="5-时间为null的用法"><a href="#5-时间为null的用法" class="headerlink" title="5. 时间为null的用法"></a>5. 时间为null的用法</h4><pre><code class="sql">select id, active_date from table1     
UNION     
select 1, TO_DATE(null) from dual;  //注意要用TO_DATE(null)    
</code></pre>
<h4 id="6-月份差"><a href="#6-月份差" class="headerlink" title="6.月份差"></a>6.月份差</h4><pre><code class="sql">a_date between to_date(&#39;20011201&#39;,&#39;yyyymmdd&#39;) and to_date(&#39;20011231&#39;,&#39;yyyymmdd&#39;)     
//那么12月31号中午12点之后和12月1号的12点之前是不包含在这个范围之内的。     
//所以，当时间需要精确的时候，觉得to_char还是必要的
</code></pre>
<h4 id="7-日期格式冲突问题"><a href="#7-日期格式冲突问题" class="headerlink" title="7. 日期格式冲突问题"></a>7. 日期格式冲突问题</h4><p>输入的格式要看你安装的ORACLE字符集的类型, 比如: US7ASCII, date格式的类型就是: ‘01-Jan-01’  </p>
<pre><code class="sql">alter system set NLS_DATE_LANGUAGE = American     
alter session set NLS_DATE_LANGUAGE = American     
//或者在to_date中写     
select to_char(to_date(&#39;2002-08-26&#39;,&#39;yyyy-mm-dd&#39;),
   &#39;day&#39;,&#39;NLS_DATE_LANGUAGE = American&#39;) from dual;     
//注意我这只是举了NLS_DATE_LANGUAGE，当然还有很多，可查看     
select * from nls_session_parameters     
select * from V$NLS_PARAMETERS    
</code></pre>
<h4 id="8-查询特殊条件天数"><a href="#8-查询特殊条件天数" class="headerlink" title="8.查询特殊条件天数"></a>8.查询特殊条件天数</h4><pre><code class="sql">select count(*)     
from ( select rownum-1 rnum     
   from all_objects     
   where rownum &lt;= to_date(&#39;2002-02-28&#39;,&#39;yyyy-mm-dd&#39;) - to_date(&#39;2002-     
   02-01&#39;,&#39;yyyy-mm-dd&#39;)+1     
  )     
where to_char( to_date(&#39;2002-02-01&#39;,&#39;yyyy-mm-dd&#39;)+rnum-1, &#39;D&#39; )     
    not in ( &#39;1&#39;, &#39;7&#39; )     

//查找2002-02-28至2002-02-01间除星期一和七的天数     
//在前后分别调用DBMS_UTILITY.GET_TIME, 让后将结果相减(得到的是1/100秒, 而不是毫秒).    
</code></pre>
<h4 id="9-查找月份"><a href="#9-查找月份" class="headerlink" title="9. 查找月份"></a>9. 查找月份</h4><pre><code class="sql">select months_between(to_date(&#39;01-31-1999&#39;,&#39;MM-DD-YYYY&#39;),
to_date(&#39;12-31-1998&#39;,&#39;MM-DD-YYYY&#39;)) &quot;MONTHS&quot; FROM DUAL;     
//结果为：1     
select months_between(to_date(&#39;02-01-1999&#39;,&#39;MM-DD-YYYY&#39;),
to_date(&#39;12-31-1998&#39;,&#39;MM-DD-YYYY&#39;)) &quot;MONTHS&quot; FROM DUAL;     
//结果为：1.03225806451613
</code></pre>
<h4 id="10-Next-day的用法"><a href="#10-Next-day的用法" class="headerlink" title="10. Next_day的用法"></a>10. Next_day的用法</h4><pre><code class="sql">Next_day(date, day)     
Monday-Sunday, for format code DAY     
Mon-Sun, for format code DY     
1-7, for format code D    
</code></pre>
<h4 id="11-获得小时数"><a href="#11-获得小时数" class="headerlink" title="11.获得小时数"></a>11.获得小时数</h4><pre><code class="sql">//extract()找出日期或间隔值的字段值
SELECT EXTRACT(HOUR FROM TIMESTAMP &#39;2001-02-16 2:38:40&#39;) from offer     
select sysdate ,to_char(sysdate,&#39;hh&#39;) from dual;     

SYSDATE               TO_CHAR(SYSDATE,&#39;HH&#39;)     
--      
2003-10-13 19:35:21   07     

select sysdate ,to_char(sysdate,&#39;hh24&#39;) from dual;     

SYSDATE               TO_CHAR(SYSDATE,&#39;HH24&#39;)     
-- --     
2003-10-13 19:35:21   19    
</code></pre>
<h4 id="12-年月日的处理"><a href="#12-年月日的处理" class="headerlink" title="12.年月日的处理"></a>12.年月日的处理</h4><pre><code class="sql">SELECT
  older_date,
  newer_date,
  years,
  months,
  ABS (
    TRUNC (
      newer_date - ADD_MONTHS (older_date, years * 12 + months)
    )
  ) days
FROM
  (
    SELECT
      TRUNC (
        MONTHS_BETWEEN (newer_date, older_date) / 12
      ) YEARS,
      MOD (
        TRUNC (
          MONTHS_BETWEEN (newer_date, older_date)
        ),
        12
      ) MONTHS,
      newer_date,
      older_date
    FROM
      (
        SELECT
          hiredate older_date,
          ADD_MONTHS (hiredate, ROWNUM) + ROWNUM newer_date
        FROM
          emp
      )
  )   
</code></pre>
<h4 id="13-处理月份天数不定的办法"><a href="#13-处理月份天数不定的办法" class="headerlink" title="13.处理月份天数不定的办法"></a>13.处理月份天数不定的办法</h4><pre><code class="sql">select to_char(add_months(last_day(sysdate) +1, -2), &#39;yyyymmdd&#39;),
    last_day(sysdate) from dual    
</code></pre>
<h4 id="14-找出今年的天数"><a href="#14-找出今年的天数" class="headerlink" title="14.找出今年的天数"></a>14.找出今年的天数</h4><pre><code class="sql">select add_months(trunc(sysdate,&#39;year&#39;), 12) - trunc(sysdate,&#39;year&#39;) from dual    
//闰年的处理方法     
to_char( last_day( to_date(&#39;02&#39;    | | :year,&#39;mmyyyy&#39;) ), &#39;dd&#39; )     
//如果是28就不是闰年
</code></pre>
<h4 id="15-yyyy与rrrr的区别"><a href="#15-yyyy与rrrr的区别" class="headerlink" title="15.yyyy与rrrr的区别"></a>15.yyyy与rrrr的区别</h4><pre><code class="sql">YYYY99  TO_C     

yyyy 99 0099     
rrrr 99 1999     
yyyy 01 0001     
rrrr 01 2001   
</code></pre>
<h4 id="16-不同时区的处理"><a href="#16-不同时区的处理" class="headerlink" title="16.不同时区的处理"></a>16.不同时区的处理</h4><pre><code class="sql">select to_char( NEW_TIME( sysdate, &#39;GMT&#39;,&#39;EST&#39;), &#39;dd/mm/yyyy hh:mi:ss&#39;) ,
sysdate   from dual;    
</code></pre>
<h4 id="17-5秒钟一个间隔"><a href="#17-5秒钟一个间隔" class="headerlink" title="17. 5秒钟一个间隔"></a>17. 5秒钟一个间隔</h4><pre><code class="sql">Select TO_DATE(FLOOR(TO_CHAR(sysdate,&#39;SSSSS&#39;)/300) * 300,&#39;SSSSS&#39;) ,
TO_CHAR(sysdate,&#39;SSSSS&#39;)   from dual    
//2002-11-1 9:55:00 35786     
//SSSSS表示5位秒数    
</code></pre>
<h4 id="18-一年的第几天"><a href="#18-一年的第几天" class="headerlink" title="18.一年的第几天"></a>18.一年的第几天</h4><pre><code class="sql">select TO_CHAR(SYSDATE,&#39;DDD&#39;),sysdate from dual   
//310  2002-11-6 10:03:51    
</code></pre>
<h4 id="19-计算小时-分-秒-毫秒"><a href="#19-计算小时-分-秒-毫秒" class="headerlink" title="19.计算小时,分,秒,毫秒"></a>19.计算小时,分,秒,毫秒</h4><pre><code class="sql">SELECT
  Days,
  A,
  TRUNC (A * 24) Hours,
  TRUNC (A * 24 * 60 - 60 * TRUNC(A * 24)) Minutes,
  TRUNC (
    A * 24 * 60 * 60 - 60 * TRUNC (A * 24 * 60)
  ) Seconds,
  TRUNC (
    A * 24 * 60 * 60 * 100 - 100 * TRUNC (A * 24 * 60 * 60)
  ) mSeconds
FROM
  (
    SELECT
      TRUNC (SYSDATE) Days,
      SYSDATE - TRUNC (SYSDATE) A
    FROM
      dual
  ) SELECT
    *
  FROM
    tabname
  ORDER BY
    DECODE (MODE, &#39;FIFO&#39;, 1 ,- 1) * TO_CHAR (rq, &#39;yyyymmddhh24miss&#39;)

//   floor((date2-date1) /365) 作为年     
//  floor((date2-date1, 365) /30) 作为月     
//  d(mod(date2-date1, 365), 30)作为日.
</code></pre>
<h4 id="20-next-day函数"><a href="#20-next-day函数" class="headerlink" title="20.next_day函数"></a>20.next_day函数</h4><pre><code class="sql">//返回下个星期的日期,day为1-7或星期日-星期六,1表示星期日
next_day(sysdate,6)是从当前开始下一个星期五。后面的数字是从星期日开始算起。     
// 1  2  3  4  5  6  7     
//日 一 二 三 四 五 六   
select (sysdate-to_date(&#39;2003-12-03 12:55:45&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;))*24*60*60 from dual
//日期 返回的是天 然后 转换为ss
</code></pre>
<h4 id="21-round-舍入到最接近的日期"><a href="#21-round-舍入到最接近的日期" class="headerlink" title="21.round[舍入到最接近的日期]"></a>21.round[舍入到最接近的日期]</h4><pre><code class="sql">select sysdate S1,
round(sysdate) S2 ,
round(sysdate,&#39;year&#39;) YEAR,
round(sysdate,&#39;month&#39;) MONTH ,
round(sysdate,&#39;day&#39;) DAY from dual
</code></pre>
<h4 id="22-trunc-截断到最接近的日期-单位为天-返回的是日期类型"><a href="#22-trunc-截断到最接近的日期-单位为天-返回的是日期类型" class="headerlink" title="22.trunc[截断到最接近的日期,单位为天] ,返回的是日期类型"></a>22.trunc[截断到最接近的日期,单位为天] ,返回的是日期类型</h4><pre><code class="sql">select sysdate S1,                    
   trunc(sysdate) S2,                 //返回当前日期,无时分秒
   trunc(sysdate,&#39;year&#39;) YEAR,        //返回当前年的1月1日,无时分秒
   trunc(sysdate,&#39;month&#39;) MONTH ,     //返回当前月的1日,无时分秒
   trunc(sysdate,&#39;day&#39;) DAY           //返回当前星期的星期天,无时分秒
 from dual
</code></pre>
<h4 id="23-返回日期列表中最晚日期"><a href="#23-返回日期列表中最晚日期" class="headerlink" title="23.返回日期列表中最晚日期"></a>23.返回日期列表中最晚日期</h4><pre><code class="sql">   select greatest(&#39;01-1月-04&#39;,&#39;04-1月-04&#39;,&#39;10-2月-04&#39;) from dual
</code></pre>
<h4 id="24-计算时间差"><a href="#24-计算时间差" class="headerlink" title="24.计算时间差"></a>24.计算时间差</h4><pre><code class="sql">     注:oracle时间差是以天数为单位,所以换算成年月,日
      select floor(to_number(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,
      &#39;yyyy-mm-dd hh24:mi:ss&#39;))/365) as spanYears from dual        //时间差-年
      select ceil(moths_between(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,
      &#39;yyyy-mm-dd hh24:mi:ss&#39;))) as spanMonths from dual           //时间差-月
      select floor(to_number(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,
      &#39;yyyy-mm-dd hh24:mi:ss&#39;))) as spanDays from dual             //时间差-天
      select floor(to_number(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,
      &#39;yyyy-mm-dd hh24:mi:ss&#39;))*24) as spanHours from dual         //时间差-时
      select floor(to_number(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,
      &#39;yyyy-mm-dd hh24:mi:ss&#39;))*24*60) as spanMinutes from dual    //时间差-分
      select floor(to_number(sysdate-to_date(&#39;2007-11-02 15:55:03&#39;,
      &#39;yyyy-mm-dd hh24:mi:ss&#39;))*24*60*60) as spanSeconds from dual //时间差-秒
</code></pre>
<h4 id="25-更新时间"><a href="#25-更新时间" class="headerlink" title="25.更新时间"></a>25.更新时间</h4><pre><code class="sql"> //oracle时间加减是以天数为单位,设改变量为n,所以换算成年月,日
 select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),
    to_char(sysdate+n*365,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual        //改变时间-年
 select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),
     add_months(sysdate,n) as newTime from dual                                 //改变时间-月
 select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),
     to_char(sysdate+n,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual            //改变时间-日
 select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),
     to_char(sysdate+n/24,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual         //改变时间-时
 select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),
     to_char(sysdate+n/24/60,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual      //改变时间-分
 select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;),
     to_char(sysdate+n/24/60/60,&#39;yyyy-mm-dd hh24:mi:ss&#39;) as newTime from dual   //改变时间-秒
</code></pre>
<h4 id="26-查找月的第一天-最后一天"><a href="#26-查找月的第一天-最后一天" class="headerlink" title="26.查找月的第一天,最后一天"></a>26.查找月的第一天,最后一天</h4><pre><code class="sql">     SELECT Trunc(Trunc(SYSDATE, &#39;MONTH&#39;) - 1, &#39;MONTH&#39;) First_Day_Last_Month,
       Trunc(SYSDATE, &#39;MONTH&#39;) - 1 / 86400 Last_Day_Last_Month,
       Trunc(SYSDATE, &#39;MONTH&#39;) First_Day_Cur_Month,
       LAST_DAY(Trunc(SYSDATE, &#39;MONTH&#39;)) + 1 - 1 / 86400 Last_Day_Cur_Month
   FROM dual;
</code></pre>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>日期</tag>
        <tag>to_date</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven排除项目中同名不同版本的jar</title>
    <url>/2014/01/maven-dependency/</url>
    <content><![CDATA[<p>有人认为Maven是一个依赖管理工具，当然这种想法是错误的（确切的说Maven是一个项目管理工具，贯穿了整个项目生命周期，编译，测试，打包，发布…），但Maven给人造成这种错误的印象也是有原因的，因为Maven的依赖管理十分强大，用好了Maven，你不再需要面对一大堆jar感到头大，依赖冲突，无用依赖等问题也能够得到有效的防止和解决。</p>
<span id="more"></span>
<p>今天突然发现web项目打包后的exe居然有200M+了，心想不应该有这么大的啊，于是检查了一番发现引用的jar有130+个，仔细一瞅发现好多同名的但是不同版本的jar，比如说有commons-httpclient就有两个，3.0和3.1版本的。这样直接导致了lib下有很多重复的jar，安装程序体积自然就上去了。</p>
<p>打开POM.xml，运行了一下mvn dependency:tree 命令，查看依赖关系树形结构发现有两个jar都是依赖了commons-httpclient这个jar，但是这两个依赖的版本是不一样的，所以maven就把两个版本的都添加进来了。</p>
<p>解决办法就是通过exclusions配置dependency中要排除的jar文件。<br>示例如下：</p>
<pre><code class="js">&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.xfire &lt;/groupId&gt;
    &lt;artifactId&gt;xfire-all &lt;/artifactId&gt;
    &lt;version&gt;1.2.6 &lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework &lt;/groupId&gt;
            &lt;artifactId&gt;spring &lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>这样就排除了xfire中的spring依赖。同理，根据maven依赖树可以看到哪些jar是重复依赖的，然后通过exclusions排除掉重复的项就可以了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>jar</tag>
        <tag>版本</tag>
      </tags>
  </entry>
  <entry>
    <title>ExtJs 刷新后，默认选中刷新前最后一次选中的节点</title>
    <url>/2014/02/extjs-tree-refresh/</url>
    <content><![CDATA[<p>在对树节点进行操作后往往需要进行reload操作刷新一下树，但是很多业务都需要在树形刷新后默认选中最后一次选中的节点。这样就必须先保存前一次选中节点的信息，在reload之后再次通过节点的信息进行expand逐层展开到这个节点上。</p>
<span id="more"></span>
<p>查询了好久终于找到一个可行的方案，就是通过节点的path来记录节点的位置信息，然后通过path从root节点开始逐层展开，直到最后一个节点。<br>完成的代码如下：</p>
<p>首先是extjs3.x版本中的方法：</p>
<pre><code class="js">//获取选中的节点  
var node = tree.getSelectionModel().getSelectedNode();  
if(node == null) &#123; //没有选中 重载树  
    tree.getRootNode().reload();  
&#125; else &#123;        //重载树 并默认选中上次选择的节点    
    var path = node.getPath(&#39;id&#39;);  
    tree.getLoader().load(tree.getRootNode(),  
         function(treeNode) &#123;  
             tree.expandPath(path, &#39;id&#39;, function(bSucess, oLastNode) &#123;  
                  tree.getSelectionModel().select(oLastNode);  
              &#125;);  
         &#125;, this);    
&#125;
</code></pre>
<p>跟Extjs3.0不同Extjs4.2的写法如下</p>
<pre><code class="js">idPath = selNode.getPath(&quot;id&quot;);                 
tree.getStore().load(&#123;                     
  node: tree.getRootNode(),                     
  callback: function () &#123;                          
    tree.expandPath(idPath, &#39;id&#39;);                  
  &#125;             
&#125;);
</code></pre>
<p>需要注意的是后台返回的树的json数据时节点必须包含<code>id</code>属性，原本我没有这个属性，但是我把getPath方法中的参数改成其他的一个属性。事实证明这样是达不到效果的，最后在json中添加了id属性才成功的。</p>
]]></content>
      <categories>
        <category>ExtJs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
        <tag>tree</tag>
        <tag>树</tag>
        <tag>checkbox</tag>
      </tags>
  </entry>
  <entry>
    <title>实现用CSS切割图片的方法</title>
    <url>/2014/04/css-cut-image/</url>
    <content><![CDATA[<p>切割图片这里不是真正的切割，只是用CSS取图片中的一部分而已。这样做的好处就是减少了打开网页时请求图片的次数。主要有两种方式，一是做为某一元素的背景图片，二是用img元素的属性。</p>
<span id="more"></span>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>用CSS中元素的<code>background</code> : <code>background-color </code>|| <code>background-image </code>|| <code>background-repeat</code> || <code>background-attachment </code>|| <code>background-position</code>。<br>示例代码如下：</p>
<pre><code class="css">background:transparent url(123.jpg) no-repeat scroll -140px -20px;
</code></pre>
<p>解释：</p>
<pre><code class="css">transparent表示透明无颜色
url(123.jpg) 表示背景图片
no-repeat 表示图片不重复
scroll 表示背景图片随浏览器下拉而滚动
-140px 表示水平位置在图片的-140px处（以图片的左上角为0,0）
-20px 表示垂直位置在图片的-20px处（以图片的左上角为0,0）
</code></pre>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>用img的clip属性中的<code>rect</code>，<code>clip:rect(y1 y1 x2 x1)</code>参数说明如下：</p>
<p>y1=定位的y坐标(垂直方向)的起点</p>
<p>x1=定位的x坐标(水平方向)的起点</p>
<p>y2=定位的y坐标(垂直方向)的终点</p>
<p>x2=定位的x坐标(水平方向)的终点</p>
<p>可以看成<code>clip:rect(上，左，下，右)</code></p>
<p>注:坐标的起点是在左上角</p>
<p>示例代码：</p>
<pre><code class="css">img&#123;
    position:absolute;
    clip:rect(20px 100px 50px 20px);
&#125;
</code></pre>
<p>上面可以看出控制图片显示的关键在于<code>clip:rect(20px 100px 50px 20px)</code>这句，千万不要忘记<code>position:absolute;</code>这是用于使用绝对值来定位元素。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>cut</tag>
        <tag>图片</tag>
        <tag>切割</tag>
      </tags>
  </entry>
  <entry>
    <title>ExtJs4之Store、Reader和Writer</title>
    <url>/2014/04/extjs-reader-writer-store/</url>
    <content><![CDATA[<p>ExtJs4中的Store是最常用的组件了，本文对store以及reader和writer做了详细的说明。</p>
<span id="more"></span>
<h2 id="1-Reader数据读取器"><a href="#1-Reader数据读取器" class="headerlink" title="1.Reader数据读取器"></a>1.Reader数据读取器</h2><p>数据读取器主要用于将数据代理读取到的原始数据按照不同的规则进行解析，将解析后的数据保存在Model模型对象中。数据读取器相当于原始数据格式与Extjs标准数据格式之间的桥梁，它屏蔽了原始数据格式不同对程序开发造成的影响。在Extjs中提供的数据解析器主要有如下3种：</p>
<p>Ext.data.reader.Json  JSON数据读取器</p>
<p>Ext.data.reader.Xml  XML数据读取器</p>
<p>Ext.data.reader.Array&nbsp; 数组数据读取器</p>
<h3 id="1-1-Ext-data-reader-Reader"><a href="#1-1-Ext-data-reader-Reader" class="headerlink" title="1.1 Ext.data.reader.Reader"></a>1.1 Ext.data.reader.Reader</h3><p>Ext.data.reader.Reader是读取器的父类，主要用于从数据源读取结构化数据，它有两个子类分别是JsonReader和XmlReader。下表列出了它的主要配置项和方法。</p>
<p>表1-1 Ext.data.reader.Reader主要配置项</p>
<p>|配置项|参数类型|说明|<br>|:—|—|<br>|idProperty|String|设置作为数据唯一表示的字段名，默认为Model模型的id字段|<br>|implicitIncludes|Boolean|设置是否级联读取数据，默认为true|<br>|messageProperty|String|设置获取响应信息的属性名|<br>|root|String|设置返回信息的根名称，为必选项|<br>|successProperty|String|设置获取成功状态的属性名，默认为success|<br>|totalProperty|String|设置获取记录总数的属性名，默认为total|</p>
<p>表1-2 Ext.data.reader.Reader主要方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">read(Object response):Ext.data.ResultSet</td>
<td>读取响应对象，返回结果集response：可以是一个XMLHttpRequest对象，可以是一个普通的Json对象</td>
</tr>
</tbody></table>
<p>Ext.data.reader.Reader支持嵌套数据的读取，它会根据实体模型Model中关系API简历关联关系遍历响应数据。</p>
<h3 id="1-2-Ext-data-reader-Json"><a href="#1-2-Ext-data-reader-Json" class="headerlink" title="1.2 Ext.data.reader.Json"></a>1.2 Ext.data.reader.Json</h3><p>Ext.data.reader.Json 是读取Json数据的数据读取器，它根据实体模型Model中字段定义的映射关系解析原始数据，形成记录集。</p>
<p>表 1-3 Ext.data.reader.Json 主要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">record</td>
<td>String</td>
<td>定位在Json响应信息中发现记录数据的位置，一般情况下不需要该配置项</td>
</tr>
<tr>
<td align="left">useSimpleAccessors</td>
<td>Boolean</td>
<td>设置是否使用简单是陪方式，默认为false.如属性foo.bar.baz在默认情况下会从root中找foo属性,然后在foo中找bar属性,在bar中找baz属性.在简单模式下会最为一个整体处理,不会拆分.</td>
</tr>
</tbody></table>
<p>表1-4 Ext.data.reader.Json 主要方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">readRecords(Object data):Ext.data.ResultSet</td>
<td>从json对象中读取信息,返回结果集data:数据对象,在该对象中包含与配置项root和titalProperty对应的属性,分别表示包含记录信息的数组和总记录数</td>
</tr>
</tbody></table>
<h3 id="1-3-Ext-data-reader-Xml"><a href="#1-3-Ext-data-reader-Xml" class="headerlink" title="1.3 Ext.data.reader.Xml"></a>1.3 Ext.data.reader.Xml</h3><p>Ext.data.reader.Xml 是读取xml文档格式信息的数据读取器，它根据实体模型Model中字段定义的映射关系解析原始信息，形成记录集。</p>
<p>注意：为了使浏览器可以正确的解析xml文档，必须设置相应的content-type类型为<code>text/xml</code></p>
<p>表1-5 Ext.data.reader.Xml 主要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">record</td>
<td>String</td>
<td>包含记录信息元素的DomQuery路径</td>
</tr>
</tbody></table>
<p>表 1-6 Ext.data.reader.Xml 主要方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getData(Object date):Object readRecords(Object doc): Ext.data.ResultSet</td>
<td>获取标准化的数据对象</td>
</tr>
<tr>
<td align="left">从xml数据文档中读取信息，形成记录集doc：xml数据文档对象</td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-4-Ext-data-reader-Array"><a href="#1-4-Ext-data-reader-Array" class="headerlink" title="1.4 Ext.data.reader.Array"></a>1.4 Ext.data.reader.Array</h3><p>Ext.data.reader.Array继承自Ext.data.reader.Json，是读取二维数据信息的读取器，内层数组是一个包含字段数据的数据行，如果字段映射存在字段将根据它的下标取值到model中，如果字段映射不存在则字段按字段的原始位置进行取值。Ext.data.reader.Array的主要配置项和方法请参考Ext.data.reader.Json相关说明。</p>
<h2 id="2-Writer数据写入器"><a href="#2-Writer数据写入器" class="headerlink" title="2.Writer数据写入器"></a>2.Writer数据写入器</h2><p>数据写入器主要用于将数据代理提交到服务器的数据进行编码，相当于Extjs标准数据格式与服务器数据格式之间的桥梁，他屏蔽了服务器端数据格式不同对程序开发造成的影响。在Extjs中提供的数据写入器有：</p>
<p>Ext.data.writer.Json =&gt; Json写入器</p>
<p>Ext.data.writer.Xml =&gt; xml写入器</p>
<h3 id="2-1-Ext-data-writer-Writer"><a href="#2-1-Ext-data-writer-Writer" class="headerlink" title="2.1 Ext.data.writer.Writer"></a>2.1 Ext.data.writer.Writer</h3><p>Ext.data.writer.Writer 是数据写入器的父类，它负责处理请求对象，将数据转换为指定格式，对于客户端代理是不需要指定Writer 写入器的。</p>
<p>表2-1 Ext.data.writer.Writer 主要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nameProperty</td>
<td>String</td>
<td>设置发送到服务器数据的键值属性名</td>
</tr>
<tr>
<td align="left">writerAllFields</td>
<td>Boolean</td>
<td>设置是否向服务器写入所有字段，false则指包含被修改的字段，默认为true</td>
</tr>
</tbody></table>
<p>表2-2 Ext.data.writer.Writer&nbsp; 主要方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getRecordData(Object record)：Object</td>
<td>获取格式化之后的数据;record；需要发送的服务器记录对象</td>
</tr>
</tbody></table>
<h3 id="2-2-Ext-data-writer-Json"><a href="#2-2-Ext-data-writer-Json" class="headerlink" title="2.2 Ext.data.writer.Json"></a>2.2 Ext.data.writer.Json</h3><p>JSON格式的数据写入器，它会将实体模型model中的数据转化为json格式发送到服务器。</p>
<pre><code class="js">wirter：&#123;
    type:&#39;json&#39;
&#125;
</code></pre>
<p>发往服务器的数据为：<code>&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:24&#125;</code>.</p>
<h3 id="2-3Ext-data-writer-Xml"><a href="#2-3Ext-data-writer-Xml" class="headerlink" title="2.3Ext.data.writer.Xml"></a>2.3Ext.data.writer.Xml</h3><p>XML格式的数据写入器，它会将Model中的数据转换为xml发送到服务器。</p>
<p>表2-2 Ext.data.writer.Xml 主要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">defaultDocumentRoot</td>
<td>String</td>
<td>设置当documentRoot为空时的默认根标签名称</td>
</tr>
<tr>
<td align="left">documentRoot</td>
<td>String</td>
<td>设置xml文档的根标签名称，默认为xmlData</td>
</tr>
<tr>
<td align="left">header</td>
<td>String</td>
<td>设置xml文档的头属性，如encoding编码或version版本，默认为””</td>
</tr>
<tr>
<td align="left">record</td>
<td>String</td>
<td>设置记录节点的标签名称，默认为rocord</td>
</tr>
</tbody></table>
<h2 id="3-Store数据集"><a href="#3-Store数据集" class="headerlink" title="3. Store数据集"></a>3. Store数据集</h2><p>Store数据集是一个客户端模型对象Model的缓存，它可以为Extjs组件提供数据输入，store通过数据代理夹在数据，也可以手工调用lodaData等方法加载数据，解析后的数据对象缓存在Store数据集中，并通过存取函数进行访问。</p>
<p>在Extjs提供的数据集类主要包括：</p>
<p><code>Ext.data.AbstractStore</code>、<code>Ext.data.Store</code>、<code>Ext.data.ArrayStore</code>、<code>Ext.data.DirectStore</code>、<code>Ext.data.JsonPStore</code>、<code>Ext.data.JsonStore</code>、<code>Ext.data.XmlStore</code>。</p>
<h3 id="3-1-Ext-data-AbstractStore"><a href="#3-1-Ext-data-AbstractStore" class="headerlink" title="3.1 Ext.data.AbstractStore"></a>3.1 Ext.data.AbstractStore</h3><p>Ext.data.AbstractStore是Ext.data.Store 和Ext.data.TreeStore的父类，它不能被直接实例化，但提供了大量的方法供子类使用，除非需要创建新的Store类，否则在大多数情况下应该使用Ext.data.Store类。</p>
<p>表3-1 Ext.data.AbstractStore 主要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">autoLoad</td>
<td>Boolean/Object</td>
<td>设置数据集是否自动加载数据，如果设置为true或提供了加载的配置对象则数据集在创建后后自动调用load方法加载数据，默认为false。</td>
</tr>
<tr>
<td align="left">autoSync</td>
<td>Boolean</td>
<td>设置是否在数据修改后自动通过数据代理进行同步</td>
</tr>
<tr>
<td align="left">fields</td>
<td>Array</td>
<td>设置应用于模型的字段定义，store或自动根据fields定义创建模型类</td>
</tr>
<tr>
<td align="left">proxy</td>
<td>String/Ext.data.proxy.Proxy/Object</td>
<td>设置代理，可以是字符串，配置对象或者代理实例</td>
</tr>
<tr>
<td align="left">storeId</td>
<td>String</td>
<td>设置数据集id，这个id将被注册到Ext.data.StoreManager中</td>
</tr>
</tbody></table>
<p>表3-2 Ext.data.AbstractStore 主要方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getNewRecords：Array</td>
<td>获取所有新增但未调用代理进行数据同步的记录数组</td>
</tr>
<tr>
<td align="left">getProxy：Ext.data.proxy.Proxy</td>
<td>获取数据代理</td>
</tr>
<tr>
<td align="left">getUpdatedRecords：Array</td>
<td>获取被修改但是未调用代理进行数据同步的记录数组</td>
</tr>
<tr>
<td align="left">isLoading：Boolean</td>
<td>获取当前store是否处于加载状态</td>
</tr>
<tr>
<td align="left">load(Object options):void</td>
<td>加载数据，options：传到代理中的Ext.data.Operation操作参数配置对象</td>
</tr>
<tr>
<td align="left">sync：Void</td>
<td>同步数据</td>
</tr>
</tbody></table>
<h3 id="3-2-Ext-data-Store"><a href="#3-2-Ext-data-Store" class="headerlink" title="3.2 Ext.data.Store"></a>3.2 Ext.data.Store</h3><p>Ext.data.Store 是一个基本的数据集类，它通过数据代理读取数据，提供了排序、过滤、查找等基本功能。</p>
<p>表3-3 Ext.data.Store主要配置项</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">buffered</td>
<td>Boolean</td>
<td>设置是否允许Store缓存之前读取的数据</td>
</tr>
<tr>
<td align="left">clearOnPageLoad</td>
<td>Boolean</td>
<td>设置在分页查询中是否请求当前页面数据，默认为true，设置为false则允许在一页中显示大量数据</td>
</tr>
<tr>
<td align="left">data</td>
<td>Array</td>
<td>内置数据对象组成的数组，在数据集初始化之后该数组会读入数据集</td>
</tr>
<tr>
<td align="left">model</td>
<td>String</td>
<td>设置store关联的Model模型</td>
</tr>
<tr>
<td align="left">proxy</td>
<td>String/Ext.data.proxy.Proxy/Object</td>
<td>设置数据代理</td>
</tr>
<tr>
<td align="left">purgePageCount</td>
<td>Number</td>
<td>设置在更新缓存数据之前,缓存数据的最大页数,设置为0则不更新缓存数据,该配置项只在buffered设置为true时生效</td>
</tr>
<tr>
<td align="left">remotrFilter</td>
<td>Boolean</td>
<td>设置是否使用远程过滤,默认为fakse</td>
</tr>
<tr>
<td align="left">remoteGroup</td>
<td>Boolean</td>
<td>设置是否使用远程分组,默认为fakse</td>
</tr>
<tr>
<td align="left">remoteSort</td>
<td>Boolean</td>
<td>设置是否使用远程排序,默认为fakse</td>
</tr>
<tr>
<td align="left">sortOnFilter</td>
<td>Boolean</td>
<td>设置在过滤数据时是否同时进行排序,默认为true,该配置项只在客户端过滤时生效</td>
</tr>
</tbody></table>
<p>表3-4 Ext.data.Store主要方法</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Store(Object config)</td>
<td>创建一个新的数据集对象,config:一个包含数据集必要信息的配置对象</td>
</tr>
<tr>
<td align="left">add(Object data):Array</td>
<td>增加数据记录到数据集中,data:一个数据对象的数组</td>
</tr>
<tr>
<td align="left">aggregate(Function fn,[Object scope],Boolean grouped,[Array args]):void</td>
<td>允许在数据集上聚合函数fn:聚合函数,分组后的记录数是唯一的参数;scope:聚合函数的执行范围;grouped:设置是否对Store中的每一组调用聚合函数,该参数只在具有一个分组字段groupFiled时生效;args:传递到聚合函数中的任何其他参数</td>
</tr>
<tr>
<td align="left">average(String field,Boolean grouped):void</td>
<td>获取指定字段的平均值,field:计算平均值的字段名;grouped:设置是否对Store中的每一组调用聚合函数,该参数只在具有一个分组字段groupFiled时生效</td>
</tr>
<tr>
<td align="left">clearFilter(Boolean suppressEvent):void</td>
<td>清除过滤器;suppressEvent：设置是否压制事件，如果为true则在清空过滤器时不会触发datachanged事件</td>
</tr>
<tr>
<td align="left">clearGrouping：void</td>
<td>清除分组</td>
</tr>
<tr>
<td align="left">collect(String dataIndex，[Boolean allowNull],[Boolean bypassFilter]):void</td>
<td>收集数据集中指定索引的唯一值集;dataindex:索引属性名;allownull:true则允许为空/undefined或者空字符串;bypassFIlter:true则收集所有记录,false则收集过滤后的数据</td>
</tr>
<tr>
<td align="left">count(Boolean grouped) :void</td>
<td>获取Store中的记录数;grouped:true则以分组的方式计算记录数,该参数只在具有一个分组字段groupFiled时生效</td>
</tr>
<tr>
<td align="left">each(Function fn,[Object scope]):void</td>
<td>遍历数据集中的记录对象,并将数据记录对象传入指定的函数中;fn:遍历数据集调用的函数,当前数据记录对象作为第一个参数传递到该函数中,返回false则终止循环;scope:函数作用域</td>
</tr>
<tr>
<td align="left">filter(Mixed filters，String value)：void</td>
<td>过滤数据集;filter：过滤器集合;value：过滤值，当第一个参数为字段名时生效</td>
</tr>
<tr>
<td align="left">filterBy(Function fn,[Object scope]):void</td>
<td>通过特殊函数过滤数据集.数据集中的每一个数据记录对象都会传入该函数,如果函数返回true则记录被保留,否则记录会被过滤掉;fn:过滤函数,一下2个参数将被传递到该函数中;Record:当前传入过滤函数的记录对象;id:数据记录的id;scope:过滤函数的作用域</td>
</tr>
<tr>
<td align="left">find(String fieldName,String/RegExp value,[Number startIndex],[Boolean anyMatch],[Boolean caseSensitive],Boolean exactMatch):Number</td>
<td>在数据集中查询匹配字段值的第一个记录,该记录的索引值将被返回(匹配失败返回-1);fieldName:要查找的字段名;value:任意一个匹配字段值的字符串或者正则表达式;startInde:开始查找的索引位置;anyMatch:true则匹配字段值的全部,否则从开头进行匹配;caseSensitive:true表示区分大小写;exactMatch:true表示执行精确匹配,默认为false</td>
</tr>
<tr>
<td align="left">findBy(Function fn,[Object scope],[Number startIndex]):Number</td>
<td>通过调用查询函数匹配数据集中第一个满足要求的记录,该记录的索引值将被返回,失败返回-1.fn:查询函数,一下2个参数将被传递到该函数中;Record:当前传入过滤函数的数据记录对象,可以通过调用Ext.data.Record.get方法获取字段值;id:数据记录id;scope:作用域;startIndex:开始查询的索引位置</td>
</tr>
<tr>
<td align="left">fineExact(String fieldName,Mixed value,[Number startIndex]):Number</td>
<td>通过指定字段名和匹配值查询数据集第一个满足要求的记录,该记录的索引值将被返回,失败返回-1.fieldName:字段名;value:匹配值;startIndex:开始查询的索引位置</td>
</tr>
<tr>
<td align="left">findRecord()</td>
<td>参考find方法,返回值为记录对象</td>
</tr>
<tr>
<td align="left">first(Boolean grouped):Model/undefined</td>
<td>便利函数,用于获取Store中的第一条记录;grouped:true则返回所有分组的第一条记录,该参数只在具有一个分组字段groupFiled时生效</td>
</tr>
<tr>
<td align="left">getAt(Number index):Model</td>
<td>取得指定索引位置的数据记录对象;index:数据记录对象在数据集中的索引位置</td>
</tr>
<tr>
<td align="left">getById(String Id):Model</td>
<td>取得指定id的数据记录对象</td>
</tr>
<tr>
<td align="left">getCount():Number</td>
<td>取得数据集中缓存的数据记录总数.如果使用了分页则该值可能不是数据的总数量,如果被解析的数据对象中包含了数据的总数量则可以通过getTotalCaout方法得到</td>
</tr>
<tr>
<td align="left">getGroupString(Model instance):void</td>
<td>取得指定模型实例的分组字符串</td>
</tr>
<tr>
<td align="left">getGroups:Array</td>
<td>取得分组的数据对象</td>
</tr>
<tr>
<td align="left">getPageFromRecordIndex(Number index):Number</td>
<td>获取指定索引记录所在的页号</td>
</tr>
<tr>
<td align="left">getRange([Number startindex],[Number endIndex]):Model[]</td>
<td>取得指定范围的数据记录数组,index默认为0到最后一个记录的索引</td>
</tr>
<tr>
<td align="left">getTotalCount():Number</td>
<td>取得从服务器返回的数据记录总数.如果使用分页则该值必须包含咋服务器返回的数据对象中,当客户端数据集内容发生变化时不会更新该值</td>
</tr>
<tr>
<td align="left">group(String/Array groupers,String direction):void</td>
<td>分组数据;groupers:一个字段名,或分组器配置对象组成的数组;direction:排序方式,默认为ASC</td>
</tr>
<tr>
<td align="left">hasPendingRequests:number</td>
<td>获取未完成的请求数量</td>
</tr>
<tr>
<td align="left">indexOf(Model record):number</td>
<td>取得数据记录对象在数据集缓存中的索引位置,如果数据记录对象不在缓存中则返回-1</td>
</tr>
<tr>
<td align="left">indexOfId(String id):Number</td>
<td>取得指定Id的数据记录对象在数据集缓存中的索引位置,如果数据记录对象不在缓存中则返回-1</td>
</tr>
<tr>
<td align="left">ndexOfTatal(Model record):number</td>
<td>取得数据记录在0到totalCount之间的索引位置</td>
</tr>
<tr>
<td align="left">insert(number index, Model[] records):void</td>
<td>插入数据记录到数据集中指定的索引位置,该操作会触发数据集的add事件</td>
</tr>
<tr>
<td align="left">isFiltered():Boolean</td>
<td>返回当期数据集中的数据是否经过过滤</td>
</tr>
<tr>
<td align="left">isGrouped():Boolean</td>
<td>返回当期数据集中的数据是否经过分组</td>
</tr>
<tr>
<td align="left">last(Boolean grouped):Model/undefined</td>
<td>获取Store中的最后一条记录</td>
</tr>
<tr>
<td align="left">load(object/Function options):void</td>
<td>使用数据代理加载数据</td>
</tr>
<tr>
<td align="left">loadData(Array data,[Boolean append]):void</td>
<td>直接加载数组数据到Store中,append:true表示将数据追加到缓存中,false表示用新数据替换旧数据</td>
</tr>
<tr>
<td align="left">loadPage(Number page):void</td>
<td>读取指定页码的数据,会根据page参数计算出start和limit参数进行传递</td>
</tr>
<tr>
<td align="left">loadRecords( Array reocrds,object options):void</td>
<td>加载数组数据到store中,会触发datachanged事件,该方法通常被数据代理内部使用</td>
</tr>
<tr>
<td align="left">max(String field,Boolean grouped):Mixed/undefined</td>
<td>取得指定字段的最大值</td>
</tr>
<tr>
<td align="left">min(String field,Boolean grouped):Mixed/undefined</td>
<td>获取指定字段的最小值</td>
</tr>
<tr>
<td align="left">nextPage：void</td>
<td>读取当前数据集的下一页数据</td>
</tr>
<tr>
<td align="left">prefetch（Number page，Object options）:void</td>
<td>预读指定页码的数据</td>
</tr>
<tr>
<td align="left">previousPage：void</td>
<td>读取当前数据集的上一页数据</td>
</tr>
<tr>
<td align="left">queryBy（Function fn,[Object scope]）:MixedCollection</td>
<td>通过调用过滤函数来查询满足要求的记录,如果过滤函数返回true则当前数据记录对象将包含在查询结果中</td>
</tr>
<tr>
<td align="left">remove(Model/Array records)</td>
<td>从数据集中删除数据记录对象,该操作会触发数据集的remove事件,在remove事件之后触发datachanged事件</td>
</tr>
<tr>
<td align="left">removeAll（Boolean silent）：void</td>
<td>从数据集中删除所有数据,silent为true则不触发事件</td>
</tr>
<tr>
<td align="left">removeAt（Number index)：void</td>
<td>从数据集中删除指定索引位置的数据</td>
</tr>
<tr>
<td align="left">sum(String field,Boolean grouped):Number</td>
<td>获取指定字段的和值</td>
</tr>
</tbody></table>
<h3 id="3-3-Ext-data-ArrayStore、Ext-data-JsonStore和Ext-data-XmlStore"><a href="#3-3-Ext-data-ArrayStore、Ext-data-JsonStore和Ext-data-XmlStore" class="headerlink" title="3.3 Ext.data.ArrayStore、Ext.data.JsonStore和Ext.data.XmlStore"></a>3.3 Ext.data.ArrayStore、Ext.data.JsonStore和Ext.data.XmlStore</h3><p>为了方便使用Store读取各类数据,Extjs提供了内置数据读取器的辅助Store类来加速程序的开发过程,</p>
<p>Ext.data.JsonStore:内置了Ext.data.reader.Json</p>
<p>Ext.data.XmlStore:内置了Ext.data.reader.Xml</p>
<p>Ext.data.ArrayStore:内置了Ext.data.reader.Array</p>
<p>详细使用同Store类似,就不再详细说明</p>
<h3 id="3-4-Ext-data-DirectStore和Ext-data-JsonPStore"><a href="#3-4-Ext-data-DirectStore和Ext-data-JsonPStore" class="headerlink" title="3.4 Ext.data.DirectStore和Ext.data.JsonPStore"></a>3.4 Ext.data.DirectStore和Ext.data.JsonPStore</h3><p>extjs还提供了内置不同代理以及数据读取器的辅助类</p>
<p>Ext.data.DirectStore:内置了Ext.data.proxy.Direct代理和Ext.data.reader.Json读取器</p>
<p>Ext.data.JsonPStore:内置了Ext.data.proxy.JsonP代理和Ext.data.reader.Json读取器</p>
<p>详细也不再详细说明.</p>
<p>–本篇完–</p>
]]></content>
      <categories>
        <category>ExtJs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
        <tag>store</tag>
        <tag>reader</tag>
        <tag>writer</tag>
      </tags>
  </entry>
  <entry>
    <title>ExtJs4中的复选树级联选择</title>
    <url>/2014/02/extjs4-check-tree/</url>
    <content><![CDATA[<p>这几天要把项目中的几个模块有ext3升级到ext4，还要保持页面展示和功能要跟3.x版本的一样。升级并不是一件简单的是，基本相当于重写了，3.x版本的复选框树级联操作是在网上找的一个现成的插件，直接搬运到4.2中就不能用了，但是又找不到可用的插件。百度谷歌了好久，还真让我搞出来一个方法，记录下来吧，也分享给大家。如有不合理或者更好的方法希望不吝赐教。</p>
<span id="more"></span>
<p>在3.x版本中要实现级联选择的话，我使用的是一个<code>TreeCheckNodeUI.js</code>这个文件百度一下都能找到啊，就不详细说明了，很好用。</p>
<p>在4.2中实现的方法是在<code>treepanel</code>的配置项<code>viewConfig</code>中添加函数<code>onCheckboxChange</code>，表示复选框选择状态发生变化是触发的事件，先把代码贴出来：</p>
<pre><code class="js">viewConfig:&#123;
  onCheckboxChange: function(e, t) &#123;
         var item = e.getTarget(this.getItemSelector(), this.getTargetEl()), record;
         if (item) &#123;
             record = this.getRecord(item);
             var check = !record.get(&#39;checked&#39;);
             record.set(&#39;checked&#39;, check);
             if (check) &#123;
                 record.bubble(function(parentNode) &#123;
                     parentNode.set(&#39;checked&#39;, true);
                 &#125;);
                 record.cascadeBy(function(node) &#123;
                     node.set(&#39;checked&#39;, true);
                 &#125;);
                 record.expand();
               record.expandChildren();
             &#125; else &#123;
               record.collapse();
               record.collapseChildren();
                 record.cascadeBy(function(node) &#123;
                     node.set(&#39;checked&#39;, false);
                 &#125;);
               record.bubble(function(parentNode) &#123;
                var childHasChecked=false;
                var childNodes = parentNode.childNodes;
              if(childNodes || childNodes.length&gt;0)&#123;
                for(var i=0;i&lt;childNodes.length;i++)&#123;
                  if(childNodes[i].data.checked)&#123;
                    childHasChecked= true;
                    break;
                  &#125;
                &#125;
              &#125;
                if(!childHasChecked)&#123;
                       parentNode.set(&#39;checked&#39;, false);
                     &#125;
                 &#125;);

             &#125;
         &#125;
     &#125;
&#125;
</code></pre>
<p>其实这段代码我也不是很懂，几个方法是百度出来的，然后纯属于东拼西凑，最后居然还实现了功能，等闲来再好好了解一下这段代码的意思。</p>
<p>还遇到过一个问题，3.x的版本中有个grid的单元格悬浮展示数据的功能，其实就是一个<code>quicktip</code>将单元格中的内容展示出来。同样的，直接搬运到extjs4中还是实现不了的，又花了半天时间才找到一个方法，还是直接贴出代码吧：</p>
<pre><code class="js">&#123;
  header : &quot;姓名&quot;,
  width : 100,
  dataIndex : &quot;name&quot;,
  menuDisabled : true,
  sortable : false,
  renderer : function(value, metadata, record, rowIndex,
      columnIndex, store) &#123;
    value = value.replace(/&lt;/g, &#39;&amp;lt&#39;);
    metadata.tdAttr = &#39;data-qtip=&quot;&#39; + value+ &#39;&quot;&#39;;
    return value;
  &#125;
&#125;
</code></pre>
<p>给colmodel中的列添加一个<code>renderer</code>函数，给单元格所在的<code>td</code>添加一个<code>qtip</code>，将单元格的内容放到里面就可以了。</p>
<p>extjs的qtip提示会有个小问题，也不知道是不是bug，如果value的值中包含了空格，横线等特殊符号的时候qtip显示的内容不完整，只能显示第一个空格之前的内容。为了避免这种情况可以用<code>xmp</code>标签将value包含起来：<br><code>metadata.tdAttr = &#39;data-qtip=&quot;&lt;xmp&gt;&#39; + value+ &#39;&lt;/xmp&gt;&quot;&#39;;</code></p>
<p>还有一种办法就是给grid添加一个鼠标移动事件，当鼠标移动到单元格内的时候取到单元格的内容，然后生成一个tooltip显示出来。代码如下：</p>
<pre><code class="js">listeners:&#123;
   &#39;render&#39;: function(g) &#123;    
       g.on(&quot;itemmouseenter&quot;, function(view,record,mode,index,e) &#123;
           var view = g.getView();
           logGrid.tip = Ext.create(&#39;Ext.tip.ToolTip&#39;, &#123;  
              target: view.el,
              delegate: view.getCellSelector(),
              trackMouse: true,
              renderTo: Ext.getBody(),
              listeners: &#123;   
                  beforeshow: function updateTipBody(tip) &#123;
                      tip.update(tip.triggerElement.innerHTML);
                  &#125;  
              &#125;  
           &#125;);  
       &#125;);    
   &#125;  
&#125;
</code></pre>
]]></content>
      <categories>
        <category>ExtJs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
        <tag>tree</tag>
        <tag>树</tag>
        <tag>级联</tag>
        <tag>选择</tag>
      </tags>
  </entry>
  <entry>
    <title>ExtJs4之树组件</title>
    <url>/2014/04/extjs-tree/</url>
    <content><![CDATA[<p><code>TreePanel</code>是ExtJS中最多能的组件之一，它非常适合用于展示分层的数据。<code>TreePanel</code>和<code>GridPanel</code>继承自相同的基类，所以所有从<code>GridPanel</code>能获得到的特性、扩展、插件等带来的好处，在<code>TreePanel</code>中也同样可以获得。列、列宽调整、拖拽、渲染器、排序、过滤等特性，在两种组件中都是差不多的工作方式。</p>
<span id="more"></span>
<p>让我们开始创建一个简单的树组件</p>
<p>首先创建Store:</p>
<pre><code class="js">var treeStore = Ext.create(&#39;Ext.data.TreeStore&#39;, &#123;
    proxy: &#123;
        type: &#39;ajax&#39;,
        url: &#39;grade.htm?getAllGrades&#39;
    &#125;,
    root: &#123;
        text: &#39;name&#39;,
        id: &#39;id&#39;,
        expanded: true,
        leaf:true
    &#125;,
    folderSort: true,
    sorters: [&#123;
        property: &#39;id&#39;,
        direction: &#39;ASC&#39;
    &#125;]
&#125;);
</code></pre>
<p>表1 Ext.data.TreeStore主要配置项</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>clearOnLoad</td>
<td>Boolean</td>
<td>设置加加载节点数据时,是否清楚前一次加载的数据,默认为true</td>
</tr>
<tr>
<td>defaultRootId</td>
<td>String</td>
<td>设置默认的根节点id,默认为root</td>
</tr>
<tr>
<td>defaultRootProperty</td>
<td>String</td>
<td>设置默认的根属性</td>
</tr>
<tr>
<td>nodeParam</td>
<td>String</td>
<td>异步加载节点时的参数名称,默认为node</td>
</tr>
</tbody></table>
<p>创建TreePane:</p>
<pre><code class="js">var gradeTree=Ext.create(&#39;Ext.tree.Panel&#39;, &#123;
   store: treeStore,
    id:&#39;gradeTree&#39;,
    bodyStyle: &#39;background-color:#DEEBF7&#39;,
    height: 300,
    width: 250,
    useArrows: true,
    root: &#123;
    text:&#39;我的班级&#39;,
    id:&#39;0&#39;
    &#125;,
    rootVisible : true,
    tbar:new Ext.Toolbar(&#123;
    style:&#39;border-top:0px;border-left:0px&#39;,
    items:[&#123;
        iconCls: &#39;icon-expand-all&#39;,
        text:&#39;展开&#39;,
        tooltip: &#39;展开所有&#39;,
        handler: function()&#123;
             gradeTree.getRootNode().expand(true);
        &#125;,
        scope: this
    &#125;,&#39;-&#39;,&#123;
        iconCls: &#39;icon-collapse-all&#39;,
        text:&#39;折叠&#39;,
        tooltip: &#39;折叠所有&#39;,
        handler: function()&#123;
           gradeTree.getRootNode().collapse(true);
        &#125;,
        scope: this
    &#125;]
    &#125;)
&#125;);
</code></pre>
<p>Tree节点点击事件:</p>
<pre><code class="js">gradeTree.on(&#39;itemclick&#39;,function(view,record,item,index,e,opts)&#123;  
    //获取当前点击的节点  
    var treeNode=record.raw;  
    var id = treeNode.id;  
    var text=treeNode.text;  
    studentStore.loadPage(1,&#123;params:&#123;gradeId:id&#125;&#125;);
&#125;);
</code></pre>
<p>表2 Ext.tree.Panel主要配置项</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>animate</td>
<td>Boolean</td>
<td>设置在展开和收缩节点的时候是否启用动画效果,默认为Ext.enableFx</td>
</tr>
<tr>
<td>displayField</td>
<td>String</td>
<td>设置节点标题的字段名,默认为text</td>
</tr>
<tr>
<td>hideHearers</td>
<td>Boolean</td>
<td>设置为true则隐藏标题</td>
</tr>
<tr>
<td>lines</td>
<td>Boolean</td>
<td>设置是否显示节点前的虚线,默认为true</td>
</tr>
<tr>
<td>root</td>
<td>Object</td>
<td>允许不为tree.Panel指定Store而通过预读数据创建简单的树结构</td>
</tr>
<tr>
<td>rootVisible</td>
<td>Boolean</td>
<td>设置根节点是否可见,默认为true</td>
</tr>
<tr>
<td>singleExpland</td>
<td>Boolean</td>
<td>设置是否单一展开节点,默认为false</td>
</tr>
<tr>
<td>useArrows</td>
<td>Boolean</td>
<td>设置为true则使用Vista风格的箭头,默认为false</td>
</tr>
</tbody></table>
<p>表3 Ext.tree.Panel主要方法</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">collpaseAll([Function callback],[Object scope]):void</td>
<td>收缩所有展开的节点;参数说明:callback:收缩完毕后的回调函数 ;scope:回调函数执行的作用域</td>
</tr>
<tr>
<td align="left">expandAll([Function callback],[Object scope]):void</td>
<td>展开所有展开的节点;参数说明:callback:展开完毕后的回调函数;scope:回调函数执行的作用域</td>
</tr>
<tr>
<td align="left">expandPath(String path,[String field],[String separator],[Function callback],[Object scope]):void</td>
<td>展开树节点到指定的路径;参数说明:path:路径字符串;filed(可选):获取数据的字段名,默认为id属性;separator:路径风格符,默认为’/‘;callback:当节点展开后的回调函数,传入函数的参数包括:success:表示是否展开成功; lastNode:展开的最后一个节点scope:回调函数执行的作用域</td>
</tr>
<tr>
<td align="left">getChecked():Array</td>
<td>得到一个已选节点的数组</td>
</tr>
<tr>
<td align="left">selectPath(String path,[String field],[String separator],[Function callback],[Object scope]):void</td>
<td>选择特定路径的树节点参数说明:同expandPath方法.</td>
</tr>
</tbody></table>
<p>代码示例1:多列树</p>
<pre><code class="js">Ext.onReady(function()&#123;
    var tree = Ext.create(&#39;Ext.tree.Panel&#39;, &#123;
        title: &#39;TreeGrid（多列树示例）&#39;,
        renderTo: Ext.getBody(),
        width : 200,
        height : 120,
        fields: [&#39;name&#39;, &#39;description&#39;],
        columns: [&#123;
        xtype:&#39;treecolumn&#39;,//树状表格列
        text: &#39;名称&#39;,
        dataIndex: &#39;name&#39;,
        width: 100,
        sortable: true
        &#125;, &#123;
        text: &#39;描述&#39;,
        dataIndex: &#39;description&#39;,
        flex: 1,
        sortable: true
        &#125;],
        root: &#123;
        name: &#39;树根&#39;,
        description: &#39;树根的描述&#39;,
        expanded: true,
        children: [&#123;
            name: &#39;节点一&#39;,
            description: &#39;节点一的描述&#39;,
            leaf: true
        &#125;, &#123;
            name: &#39;节点二&#39;,
            description: &#39;节点二的描述&#39;,
            leaf: true
        &#125;]
        &#125;
    &#125;);
&#125;);
</code></pre>
<p>代码示例2:带复选框的树</p>
<pre><code class="js">Ext.onReady(function()&#123;
    var tree = Ext.create(&#39;Ext.tree.Panel&#39;, &#123;
        title: &#39;复选框示例&#39;,
        width : 150,
        height : 100,
        renderTo: Ext.getBody(),
        root: &#123;
        text: &#39;树根&#39;,//节点名称
        expanded: true,//默认展开根节点
        children: [&#123;
            text: &#39;节点一&#39;,//节点名称
            checked : true,//默认选中
            leaf: true//true说明为叶子节点
        &#125;, &#123;
            text: &#39;节点二&#39;,//节点名称
            checked:false,//默认不选中
            leaf: true//true说明为叶子节点
        &#125;]
        &#125;
    &#125;);
&#125;);
</code></pre>
<p>代码示例3:树面板之间的拖拽</p>
<pre><code class="js">Ext.onReady(function()&#123;
        //创建树面板一
        Ext.create(&#39;Ext.tree.Panel&#39;, &#123;
            title: &#39;树一&#39;,
            width: 200,
            height: 150,
            renderTo: &#39;tree1&#39;,
            root: &#123;
                text: &#39;树根&#39;,//节点名称
                expanded: true,//默认展开根节点
                children: [&#123;
                    text: &#39;节点一&#39;,//节点名称
                    leaf: true//true说明为叶子节点
                &#125;, &#123;
                    text: &#39;节点二&#39;,//节点名称
                    leaf: true//true说明为叶子节点
                &#125;]
            &#125;,
            viewConfig: &#123;
        plugins: &#123;
        allowContainerDrop : true,
        ptype: &#39;treeviewdragdrop&#39;,
        nodeHighlightOnRepair : true &#125; &#125;
        &#125;);

        //创建树面板二
        Ext.create(&#39;Ext.tree.Panel&#39;, &#123;
            title: &#39;树二&#39;,
            width: 200,
            height: 150,
            renderTo: &#39;tree2&#39;,
            root: &#123;
                text: &#39;树根&#39;,
                expanded: true
            &#125;,
           viewConfig: &#123;
           plugins: &#123;
           allowContainerDrop : true,
           ptype: &#39;treeviewdragdrop&#39;
         &#125;
       &#125;
   &#125;);
&#125;);
</code></pre>
]]></content>
      <categories>
        <category>ExtJs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
        <tag>tree</tag>
        <tag>树</tag>
        <tag>extjs4</tag>
      </tags>
  </entry>
  <entry>
    <title>Liquid基础语法</title>
    <url>/2014/04/liquid-for-designers/</url>
    <content><![CDATA[<p>Liquid基础语法。</p>
<span id="more"></span>

## Output输出

简单输出示例：

```ruby
Hello {{name}}
Hello {{user.name}}
Hello {{ 'tobi' }}
```

## Advanced output: Filters 高级输出：过滤器

输出标记需要的过滤器。过滤器是简单的方法。第一个参数在过滤器的左侧就是过滤器的输入，即需要过滤的内容。过滤器的返回值将是过滤器运行时过滤后的左侧的参数。当没有更多的过滤器，模板会收到结果字符串。

代码示例：

```ruby
Hello {{ 'tobi' | upcase }}
Hello tobi has {{ 'tobi' | size }} letters!
Hello {{ '*tobi*' | textilize | upcase }}
Hello {{ 'now' | ---
date: "%Y %h" }}
```

## Standard Filters标准过滤器

*   `date` -时间格式化
*   `capitalize`-设置输入中的某个单词*   
*   `downcase`-将输入的字符串转换为小写*  
*   `upcase`-将输入的字符串转换为大写
*   `first`-获得传入的数组的第一个元素
*   `last`-获得传入的数组的最后一个元素
*   `join`-用数组的分隔符连接数组中的元素
*   `sort`-数组中的元素排序
*   `map`-通过指定的属性过滤数组中的元素
*   `size`-返回一个数组或字符串的大小
*   `escape`-转义一个字符串
*   `escape_once`-返回HTML的转义版本，而不会影响现有的实体转义
*   `strip_html`-从字符串去除HTML
*   `strip_newlines` -从字符串中去除所有换行符（\ n）的
*   `newline_to_br`-用HTML标记替换每个换行符（\ n）
*   `replace`-替换，例如：`{{ 'foofoo' | replace:'foo','bar' }} #=> 'barbar'`
*   `replace_first`-替换第一个，例如： `'{{barbar' | replace_first:'bar','foo' }} #=> 'foobar'`
*   `remove`-删除，例如：`{{'foobarfoobar' | remove:'foo' }} #=> 'barbar'`
*   `remove_first`-删除第一个，例如：`{{  'barbar' | remove_first:'bar' }} #=> 'bar'`
*   `truncate`-截取字符串到第x个字符
*   `truncatewords`-截取字符串到第x个词
*   `prepend`-前置添加字符串，例如：`{{ 'bar' | prepend:'foo' }} #=> 'foobar'`
*   `append`-后置追加字符串，例如：`{{'foo' | append:'bar' }} #=> 'foobar' `
*   `minus`-减法，例如：`{{ 4 | minus:2 }} #=> 2`
*   `plus`-加法，例如：`{{'1' | plus:'1' }} #=> '11', {{ 1 | plus:1 }} #=> 2`
*   `times`-乘法，例如：`{{ 5 | times:4 }} #=> 20`
*   `divided_by`-除法，例如：`{{ 10 | divided_by:2 }} #=> 5`
*   `split`-通过正则表达式切分字符串为数组，例如：`{{"a~b" | split:"~" }} #=> ['a','b']`
*   `modulo`-取模，例如：`{{ 3 | modulo:2 }} #=> 1`

## 标记

目前支持的标记的列表：

* **assign** -将某个值赋给一个变量
* **capture**-标记文本赋值给一个变量
* **case**-标准的case...when代码块
* **comment**-块标记，注释掉该块中的文本
* **cycle**-通常在循环中使用的值之间交替，如颜色或DOM类。
* **for**-for循环
* **if**-标准的if/else代码块
* **include** -包含另外一个模版
* **raw**-暂时停用标签处理以避免出现语法冲突
* **unless**-if的反义词

## Comments

注释是最简单的标签，它会隐藏标记的内容。例如：

` We made 1 million dollars {% comment %} in losses {% endcomment %} this year.`

## Raw
Raw暂时禁用标签处理。这是用于生成内容，它使用相互矛盾的语法非常有用。例如：

```ruby
{% raw %}
  In Handlebars, {{ this }} will be HTML-escaped, but {{{ that }}} will not.
｛% endraw %｝
```

## If / Else
`if / else`语句对任何其他编程语言都应该是众所周知的。Liquid允许使用`if`,`unless`,以及可选的`elsif`和`else`,例如：


```ruby
{% if user %}
  Hello {{ user.name }}
{% endif %}
```

```ruby
# Same as above
{% if user != null %}
  Hello {{ user.name }}
{% endif %}
```

```ruby
{% if user.name == 'tobi' %}
  Hello tobi
{% elsif user.name == 'bob' %}
  Hello bob
{% endif %}
```

```ruby
{% if user.name == 'tobi' or user.name == 'bob' %}
  Hello tobi or bob
{% endif %}
```
```ruby
{% if user.name == 'bob' and user.age > 45 %}
  Hello old bob
{% endif %}
```
```ruby
{% if user.name != 'tobi' %}
  Hello non-tobi
{% endif %}
```
```ruby
# Same as above
{% unless user.name == 'tobi' %}
  Hello non-tobi
{% endunless %}
```
```ruby
# Check for the size of an array
{% if user.payments == empty %}
   you never paid !
{% endif %}

{% if user.payments.size > 0  %}
   you paid !
{% endif %}
```
```ruby
{% if user.age > 18 %}
   Login here
{% else %}
   Sorry, you are too young
{% endif %}
```
```ruby
# array = 1,2,3
{% if array contains 2 %}
   array includes 2
{% endif %}
```
```ruby
# string = 'hello world'
{% if string contains 'hello' %}
   string includes 'hello'
{% endif %}
```


##　Case Statement
如果您需要更多的条件，您可以使用`case`语句：

```ruby
{% case condition %}
{% when 1 %}
hit 1
{% when 2 or 3 %}
hit 2 or 3
{% else %}
... else ...
{% endcase %}
```

例如：

```ruby
{% case template %}
{% when 'label' %}
     // {{ label.title }}
{% when 'product' %}
     // {{ product.vendor | link_to_vendor }} / {{ product.title }}
{% else %}
     // {{page_title}}
{% endcase %}
```

## Cycle

通常你有不同的颜色或类似的任务之间切换。 Liquid已经内置了对此类操作的支持，使用`cycle`标记。

```ruby
{% cycle 'one', 'two', 'three' %}
{% cycle 'one', 'two', 'three' %}
{% cycle 'one', 'two', 'three' %}
{% cycle 'one', 'two', 'three' %}
```

结果为：

```ruby
one
two
three
one
```

如果未提供循环体的名称，那么它假设用同样的参数多次调用同一个循环体。

如果你想完全控制循环体，您可以选择指定循环体的名称。这甚至可以是一个变量。

```ruby
{% cycle 'group 1': 'one', 'two', 'three' %}
{% cycle 'group 1': 'one', 'two', 'three' %}
{% cycle 'group 2': 'one', 'two', 'three' %}
{% cycle 'group 2': 'one', 'two', 'three' %}
```

得到结果为：

```ruby
one
two
one
two
```

## For loops
Liquid 可以使用`for`遍历集合。

```ruby
{% for item in array %}
  {{ item }}
{% endfor %}
```

当遍历一个键值对集合时，`item[0]`是key的值，`item[1]`则是value的值。

```ruby
{% for item in hash %}
  {{ item[0] }}: {{ item[1] }}
{% endfor %}
```

在每次`for`循环中，下面的辅助变量可用于额外的需求：

```ruby
forloop.length      # => 整个for循环的长度
forloop.index       # => 当前迭代的索引
forloop.index0      # => 当前迭代的索引(从0开始)
forloop.rindex      # => 剩余的迭代次数
forloop.rindex0     # => 剩余的迭代次数(从0开始)
forloop.first       # => 是否是第一次迭代?
forloop.last        # => 是否是最后一次迭代?
```

你还可以使用多个属性来过滤循环中的内容。

`limit:int`可以限制你有多少个项目获得 `offset:int`可以让你从第n项开始遍历。

```ruby
# array = [1,2,3,4,5,6]
{% for item in array limit:2 offset:2 %}
  {{ item }}
{% endfor %}
# results in 3,4
```

倒序循环

```ruby
{% for item in collection reversed %}
	{{item}}
{% endfor %}
```

你可以通过定义一系列的数字来代替现有的集合循环。范围可以通过包括文本和变量的数字来定义：

```ruby
# if item.quantity is 4...
{% for i in (1..item.quantity) %}
  {{ i }}
{% endfor %}
# results in 1,2,3,4
```

##Variable Assignment
您可以将数据存储在自己的变量，在输出或其他标记随意使用。创建一个变量最简单的方法是使用`assign`标签，它有一个非常简单的语法：

```ruby
{% assign name = 'freestyle' %}

{% for t in collections.tags %}
	{% if t == name %}
  		Freestyle!
	{% endif %}
{% endfor %}
```

这样做的另一种方法是将分配`true / false`值的变量：

```ruby
{% assign freestyle = false %}

{% for t in collections.tags %}
	{% if t == 'freestyle' %}
  		{% assign freestyle = true %}
	{% endif %}
{% endfor %}

{% if freestyle %}
  Freestyle!
{% endif %}
```

如果你想将多个字符串合并成一个单一的字符串，并将其保存到变量中，你可以使用`capture`标记。这个标签“捕获”内容无论它是否已经实现，然后分配捕获的值。而不是只能捕获屏幕上已经存在的内容。

```xml
 {% capture attribute_name %}{{ item.title | handleize }}-{{ i }}-color{% endcapture %}

  <label for="{{ attribute_name }}">Color:</label>
  <select name="attributes[{{ attribute_name }}]" id="{{ attribute_name }}">
    <option value="red">Red</option>
    <option value="green">Green</option>
    <option value="blue">Blue</option>
  </select>
```








{% endraw %}
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Liquid</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle之程序控制结构</title>
    <url>/2014/04/oracle-case/</url>
    <content><![CDATA[<p>Oracle程序控制结构简介</p>
<span id="more"></span>
<h2 id="1-条件控制"><a href="#1-条件控制" class="headerlink" title="1.条件控制"></a>1.条件控制</h2><h3 id="1-1-IF语句"><a href="#1-1-IF语句" class="headerlink" title="1.1 IF语句"></a>1.1 IF语句</h3><p>if语句由于根据条件，执行两个代码块之一。其语法形式如下：</p>
<p><code>IF 条件1 THEN...ELSEIF 条件2 THEN...ELSE...END IF; </code></p>
<p>这里，elseif和else块时可选的。当使用条件分支语句时，不仅可以使用if语句进行简单条件判断，而且还可以使用if语句进行二重分支和多重分支判断。</p>
<h3 id="1-2-CASE语句和CASE表达式"><a href="#1-2-CASE语句和CASE表达式" class="headerlink" title="1.2 CASE语句和CASE表达式"></a>1.2 CASE语句和CASE表达式</h3><p>使用CASE语句处理多重条件分支有两种方法：使用单一选择符进行等值比较；使用多种条件进行非等值比较。</p>
<h4 id="1-在CASE语句中使用单一选择符进行等值比较"><a href="#1-在CASE语句中使用单一选择符进行等值比较" class="headerlink" title="1) 在CASE语句中使用单一选择符进行等值比较"></a>1) 在CASE语句中使用单一选择符进行等值比较</h4><p>当使用CASE语句进行多重条件分支时，如果条件选择符完全相同，并且条件表达式为相同条件选择，那么可以选择使用单一选择符进行等值比较。</p>
<p><code>CASE selector  WHEN exp1  THEN state1;   WHEN exp2  THEN state2; .... [else stateN;] END CASE; </code></p>
<p>这里，selector用于指定条件选择符，exp用于指定条件值的表达式，state用于指定要执行的条件操作。如果设置的所有条件都不满足，就会执行else语句，为避免CASE_NOT_FOUND异常，在编写CASE语句时应该带有else子句。</p>
<h4 id="2-在CASE语句中使用多种条件比较"><a href="#2-在CASE语句中使用多种条件比较" class="headerlink" title="2) 在CASE语句中使用多种条件比较"></a>2) 在CASE语句中使用多种条件比较</h4><p>如果包含有多种条件进行不等比较，那么必须在WHEN子句中指定比较条件。<br><code>CASEWHEN condition1 THEN state1; WHEN condition2 THEN state2;....[else stateN;] END CASE; </code></p>
<p>condition用于指定不同的比较条件。</p>
<h3 id="3-CASE表达式"><a href="#3-CASE表达式" class="headerlink" title="3) CASE表达式"></a>3) CASE表达式</h3><p>CASE表达式也可以采用上面两种形式。</p>
<p>case_experssion ：= CASE exp WHEN。。。</p>
<p>或者</p>
<p>case_experssion ：= CASE WHEN。。。</p>
<h2 id="2-循环控制"><a href="#2-循环控制" class="headerlink" title="2.循环控制"></a>2.循环控制</h2><h3 id="2-1-基本循环"><a href="#2-1-基本循环" class="headerlink" title="2.1 基本循环"></a>2.1 基本循环</h3><p>基本循环语句以LOOP开始，END LOOP 结束。</p>
<p><code>LOOP statement; ... EXIT [WHEN condition]; END LOOP; </code></p>
<p>当使用基本循环时，无论是否满足条件，语句至少会执行一次。当条件为true时，会退出循环，并执行end LOOP后的相应操作。注意，当编写基本循环时，一定要包含exit语句，否则PL/SQL块会陷入死循环；另外还应该定义循环控制变量，并且在循环体内修改循环控制的值。</p>
<h3 id="2-2-WHILE循环"><a href="#2-2-WHILE循环" class="headerlink" title="2.2 WHILE循环"></a>2.2 WHILE循环</h3><p>只有条件为true时，才执行循环体内的内容，while循环以while…LOOP 开始，以end LOOP结束。</p>
<h3 id="2-3-FOR循环"><a href="#2-3-FOR循环" class="headerlink" title="2.3 FOR循环"></a>2.3 FOR循环</h3><p>当使用基本循环或者while循环时，需要定义循环控制变量，并且循环控制变量不仅可以是NUMBER类型，也可以使用其他数据类型；而当使用for循环时，会隐含定义循环控制变量</p>
<p><code>FOR counter IN [REVERSE] lower_bound ..upper_bound LOOP statement; ... end loop; </code></p>
<p>counter是循环控制变量，该变量由Oracle隐含定义，不需要显式定义；lower_bound和upper_bound分别对应于循环控制变量的上下界值。默认情况下，当使用FOR循环时，每次循环时循环控制变量会自动加1，如果指定了reverse选项，则每次循环控制变量自动减1.</p>
<h3 id="2-4嵌套循环和标号"><a href="#2-4嵌套循环和标号" class="headerlink" title="2.4嵌套循环和标号"></a>2.4嵌套循环和标号</h3><p>嵌套循环是指在一个循环语句中嵌入另一个循环语句，而标号（Lable）则用于标记嵌套块或者嵌套循环。通过在嵌套循环中使用标号，可以区分内层和外层循环，并且可以在内层循环中直接退出外层循环。可以使用&lt;&gt;定义标号。</p>
<h2 id="3-顺序控制"><a href="#3-顺序控制" class="headerlink" title="3.顺序控制"></a>3.顺序控制</h2><p>PL/SQL不仅提供了条件分支语句和循环控制语句，还提供了顺序控制语句GOTO和NULL。但是，在一般情况下尽量不要使用goto和null语句。</p>
<h3 id="3-1-GOTO语句"><a href="#3-1-GOTO语句" class="headerlink" title="3.1 GOTO语句"></a>3.1 GOTO语句</h3><p>GOTO语句用于跳转到指定标号处去执行语句。注意，因为使用GOTO语句会增加程序的复杂性，并且使得应用程序可读性变差，所以开发应用程序时，一般不建议使用GOTO语句。</p>
<p>其语法形式为：</p>
<p><code>GOTO label_name; </code></p>
<p>其中，label_name是已经定义的标号名，需要注意的是，标号后至少要包含一条可执行语句。</p>
<h3 id="3-2-NULL语句"><a href="#3-2-NULL语句" class="headerlink" title="3.2 NULL语句"></a>3.2 NULL语句</h3><p>NULL语句不会执行任何操作，并且会直接将控制传递到下一条语句。使用NULL语句的好处时可以提高程序的可读性。</p>
<h2 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4.异常处理"></a>4.异常处理</h2><p>PL/SQL语言中，任何类型的错误将被看作为不应该在程序中发生的异常情况。异常可以是以下之一：</p>
<p>☆ 由系统产生的错误（例如内存不足，重复索引值）</p>
<p>☆ 由用户行为导致的错误</p>
<p>☆ 由应用程序发出给用户的警告</p>
<p>PL/SQL使用一种异常处理器来捕获和响应这些错误。当发生错误时，不管是系统错误还是应用程序错误都会抛出一个异常。此时，当前PL/SQL块执行部分的处理就会中止，程序流程就会转到当前块的异常处理部分来处理异常。在完成异常处理后，程序不能返回到执行部分。</p>
<p>通常，异常分为两种类型：系统异常和程序员自定义的异常。</p>
<h4 id="1）-系统异常"><a href="#1）-系统异常" class="headerlink" title="1） 系统异常"></a>1） 系统异常</h4><p>系统异常时由Oracle自己定义的，通常时由PL/SQL运行时引擎在检测了错误时抛出的。</p>
<p>系统异常不需要我们定义，在应用程序运行时会自动抛出，然后交给我们编写异常处理部分进行异常处理。</p>
<p>表4-1 Oracle预定义异常</p>
<table>
<thead>
<tr>
<th align="left">异常名</th>
<th>错误号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ACCESS_INTO_NULL</td>
<td>ORA-06530</td>
<td>当开发对象类型应用时，在引用对象属性之前，必须先初始化对象。如果没有初始化，直接为对象属性赋值则会抛出异常。</td>
</tr>
<tr>
<td align="left">CASE_NOT_FOUND</td>
<td>ORA-06592</td>
<td>在CASE语句中，WHEN子句中没有包含必须的条件分支，且没有ELSE语句。</td>
</tr>
<tr>
<td align="left">COLLECTION_IS_NULL</td>
<td>ORA-06531</td>
<td>在给集合元素赋值前，必须首先初始化集合元素。</td>
</tr>
<tr>
<td align="left">CURSOR_ALREADY_OPEN</td>
<td>ORA-06511</td>
<td>当重新打开已经打开的游标时抛出异常</td>
</tr>
<tr>
<td align="left">DUP_VAL_INDEX</td>
<td>ORA-00001</td>
<td>在唯一索引对应的列上键入重复值时抛出异常</td>
</tr>
<tr>
<td align="left">INVALID_CURSOR</td>
<td>ORA-01001</td>
<td>当试图在不合法的游标上执行操作时抛出</td>
</tr>
<tr>
<td align="left">INVALID_NULBER</td>
<td>ORA-01722</td>
<td>当内嵌sql语句不能呢个有效地将字符转换为数字时抛出</td>
</tr>
<tr>
<td align="left">NO_DATA_FOUND</td>
<td>ORA-01403</td>
<td>当执行select into 未返回行，或者引用了索引表未初始化元素时抛出</td>
</tr>
<tr>
<td align="left">TOO_MANY_ROWS</td>
<td>ORA-01422</td>
<td>当执行select into 语句时，如果返回超过一行抛出</td>
</tr>
<tr>
<td align="left">ZERO_DIVIDE</td>
<td>ORA-01476</td>
<td>除数为0时抛出</td>
</tr>
<tr>
<td align="left">SUBSCRIPT-BEYOND-COUNT</td>
<td>ORA-06533</td>
<td>当使用嵌套表或者VARRAY元素时，如果元素下标超过了范围则抛出</td>
</tr>
<tr>
<td align="left">SUBSCRIPT_OUTSIDE_LIMIT</td>
<td>ORA-06532</td>
<td>当使用嵌套表或者VARRAY元素时，如果元素下标为负数抛出</td>
</tr>
<tr>
<td align="left">VALUE_ERROR</td>
<td>ORA-06502</td>
<td>执行赋值操作时，如果变量长度不足以容纳实际数据时抛出</td>
</tr>
<tr>
<td align="left">LOGIN_BENIED</td>
<td>ORA-01017</td>
<td>应用程序需要连接到Oracle数据库时，如果提供了错误的用户名或口令时抛出</td>
</tr>
<tr>
<td align="left">NOT_LOGGED_ON</td>
<td>ORA-01012</td>
<td>如果应用程序没有连接到Oracle数据库时抛出</td>
</tr>
<tr>
<td align="left">PROGRAM_ERROR</td>
<td>ORA-06501</td>
<td>如果出现该错误说明PL/SQL内部存在问题，可能需要重装数据字典</td>
</tr>
<tr>
<td align="left">ROWTYPE_MISMATCH</td>
<td>ORA-06504</td>
<td>当执行赋值操作时，如果宿主游标变量和PL/SQL游标变量的返回类型不兼容时抛出</td>
</tr>
<tr>
<td align="left">SELF_IS_NULL</td>
<td>ORA-30625</td>
<td>当使用对象类型时，如果在NULL实例上调用成员方法时抛出</td>
</tr>
<tr>
<td align="left">STORAGE_ERROR</td>
<td>ORA-06500</td>
<td>如果超出内存空间或者内存被损坏时抛出</td>
</tr>
<tr>
<td align="left">SYS_INVALID_ROWID</td>
<td>ORA-01410</td>
<td>将字符串转换为rowid时，必须使用有效的字符串，否则抛出异常</td>
</tr>
<tr>
<td align="left">TIMEOUT_ON_RESOURCE</td>
<td>ORA-00051</td>
<td>如果Oracle等待资源时出现超时错误时抛出</td>
</tr>
</tbody></table>
<h4 id="2）自定义异常"><a href="#2）自定义异常" class="headerlink" title="2）自定义异常"></a>2）自定义异常</h4><p>异常处理的流程包括定义异常、抛出异常和处理异常三个部分。</p>
<h3 id="4-1-定义异常"><a href="#4-1-定义异常" class="headerlink" title="4.1 定义异常"></a>4.1 定义异常</h3><p>在异常被抛出或处理之前，必须先定义。系统异常已经由Oracle本身定义了，因此我们在应用程序中不需要定义它们。我们可以使用两种不同的方式来自定义异常。</p>
<h4 id="①-定义命名的异常"><a href="#①-定义命名的异常" class="headerlink" title="① 定义命名的异常"></a>① 定义命名的异常</h4><p>为了处理异常，必须对有一个该异常的名称。通过在EXCEPTION关键字前列出我们想在程序中抛出的异常的名称，就可以定义一个异常。</p>
<p>异常的名称只能以两种方式被引用：</p>
<p>☆ 在要跑出异常的程序执行部分用RAISE语句引用</p>
<p>☆ 在要处理抛出的异常的异常处理部分的WHEN子句中引用。</p>
<h4 id="②将异常名称与错误号关联"><a href="#②将异常名称与错误号关联" class="headerlink" title="②将异常名称与错误号关联"></a>②将异常名称与错误号关联</h4><p>EXCEPTION_INIT命令用于将一个内部错误号与异常的名称关联。关联完成后，就可以通过名称抛出异常，并编写一个显式的WHEN处理器捕获异常。</p>
<p>EXCEPTION_INIT必须出现在块的定义部分，并且异常的名字必须在相同的块或者包规范中已经定义了。</p>
<p><code>DECLARE  异常名称  EXCEPTION; PRAGMA EXCEPTION_INIT(异常名称,错误号); </code></p>
<p>这里，错误号是一个整数，他有如下的限制：</p>
<p>☆ 不能是-1403 （这个错误号时给NO_DATA_FOUND的）</p>
<p>☆ 不能是0或者任何除100以外的正数。</p>
<p>☆ 不能时小于-10000000的负数。</p>
<h3 id="4-2-抛出异常"><a href="#4-2-抛出异常" class="headerlink" title="4.2 抛出异常"></a>4.2 抛出异常</h3><p>在应用程序中抛出异常的方式有三种：</p>
<p>☆ 当Oracle检测到错误时会自动抛出异常；</p>
<p>☆ 程序员可以使用RAISE语句抛出异常；</p>
<p>☆ 程序员可以使用RAISE_APPLICATION_ERROR内置函数抛出异常。</p>
<h4 id="1）RAISE语句抛出异常"><a href="#1）RAISE语句抛出异常" class="headerlink" title="1）RAISE语句抛出异常"></a>1）RAISE语句抛出异常</h4><p>使用RAISE语句可以抛出自定义异常或系统异常。</p>
<p><code>RAISE 异常名称;</code></p>
<h4 id="2）RAISE-APPLICATION-ERROR语句抛出异常"><a href="#2）RAISE-APPLICATION-ERROR语句抛出异常" class="headerlink" title="2）RAISE_APPLICATION_ERROR语句抛出异常"></a>2）RAISE_APPLICATION_ERROR语句抛出异常</h4><p>使用RAISE_APPLICATION_ERROR替代RAISE的优点在于，我们可以将错误消息与异常关联起来。注意，该过程只能在数据库端的子程序（过程、函数、包、触发器）中使用，而不能在匿名块和客户端的子程序中使用。</p>
<p><code>RAISE_APPLICATION_ERROR（错误号，错误描述 [,&#123;true|false&#125; ]）; </code></p>
<p>其中，错误号必须是-20000到-20999之间的负整数；错误描述长度不能超过2048字节；第三个参数为可选参数，如果设置为true，则该错误号被放在先前的错误堆栈中；如果设置为false（默认值），则会替代先前所有错误。</p>
<h3 id="4-3处理异常"><a href="#4-3处理异常" class="headerlink" title="4.3处理异常"></a>4.3处理异常</h3><p>一旦异常被抛出，当前PL/SQL块就会停止正常执行，将控制权交给异常处理部分。为了处理抛出的异常，必须在异常处理部分编写异常处理器。异常处理器必须出现在执行部分之后，在END语句之前。EXception关键字指示了异常处理部分和异常处理器的开始。</p>
<p>异常只有在抛出的异常匹配WHEN子句中的异常名时才会被处理。这里WHEN子句之后只能跟异常名，不能跟错误号。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>控制</tag>
        <tag>if</tag>
        <tag>case</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL大全</title>
    <url>/2014/04/sql-all/</url>
    <content><![CDATA[<p>常见的sql语句集合</p>
<p>SQL分类：</p>
<p>DDL-数据定义语言(CREATE，ALTER，DROP，DECLARE)</p>
<p>DML-数据操纵语言(SELECT，DELETE，UPDATE，INSERT)</p>
<p>DCL-数据控制语言(GRANT，REVOKE，COMMIT，ROLLBACK)</p>
<span id="more"></span>
<p>首先,简要介绍基础语句：</p>
<p>1、说明：创建数据库</p>
<p>CREATE DATABASE database-name</p>
<p>2、说明：删除数据库</p>
<p>drop database dbname</p>
<p>3、说明：备份sql server</p>
<p>— 创建 备份数据的 device</p>
<p>USE master</p>
<p>EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c: mssql7backup MyNwind_1.dat’</p>
<p>— 开始 备份</p>
<p>BACKUP DATABASE pubs TO testBack</p>
<p>4、说明：创建新表</p>
<p>create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)</p>
<p>根据已有的表创建新表：</p>
<p>A：create table tab_new like tab_old (使用旧表创建新表)</p>
<p>B：create table tab_new as select col1,col2.. from tab_old definition only</p>
<p>5、说明：删除新表drop table tabname</p>
<p>6、说明：增加一个列</p>
<p>Alter table tabname add column col type</p>
<p>注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。</p>
<p>7、说明：添加主键： Alter table tabname add primary key(col)</p>
<p>说明：删除主键： Alter table tabname drop primary key(col)</p>
<p>8、说明：创建索引：create [unique] index idxname on tabname(col…)</p>
<p>删除索引：drop index idxname</p>
<p>注：索引是不可更改的，想更改必须删除重新建。</p>
<p>9、说明：创建视图：create view viewname as select statement</p>
<p>删除视图：drop view viewname</p>
<p>10、说明：几个简单的基本的sql语句</p>
<p>选择：select * from table1 where 范围</p>
<p>插入：insert into table1(field1,field2) values(value1,value2)</p>
<p>删除：delete from table1 where 范围</p>
<p>更新：update table1 set field1=value1 where 范围</p>
<p>查找：select * from table1 where field1 like ‘%value1%’ —like的语法很精妙，查资料!</p>
<p>排序：select * from table1 order by field1,field2 [desc]</p>
<p>总数：select count*as totalcount from table1</p>
<p>求和：select sum(field1) as sumvalue from table1</p>
<p>平均：select avg(field1) as avgvalue from table1</p>
<p>最大：select max(field1) as maxvalue from table1</p>
<p>最小：select min(field1) as minvalue from table1</p>
<p>11、说明：几个高级查询运算词</p>
<p>A： UNION 运算符</p>
<p>UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。</p>
<p>B： EXCEPT 运算符</p>
<p>EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。</p>
<p>C： INTERSECT 运算符</p>
<p>INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。</p>
<p>注：使用运算词的几个查询结果行必须是一致的。</p>
<p>12、说明：使用外连接</p>
<p>A、left outer join：</p>
<p>左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。</p>
<p>SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</p>
<p>B：right outer join:</p>
<p>右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。</p>
<p>C：full outer join：</p>
<p>全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。</p>
<p>其次，大家来看一些不错的sql语句</p>
<p>1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)</p>
<p>法一：select * into b from a where 1&lt;&gt;1</p>
<p>法二：select top 0 * into b from a</p>
<p>2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)</p>
<p>insert into b(a, b, c) select d,e,f from b;</p>
<p>3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)</p>
<p>insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件</p>
<p>例子：..from b in ‘“&amp;Server.MapPath(“.”)&amp;” data.mdb” &amp;”‘ where..</p>
<p>4、说明：子查询(表名1：a 表名2：b)</p>
<p>select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)</p>
<p>5、说明：显示文章、提交人和最后回复时间</p>
<p>select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b</p>
<p>6、说明：外连接查询(表名1：a 表名2：b)</p>
<p>select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</p>
<p>7、说明：在线视图查询(表名1：a )</p>
<p>select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;</p>
<p>8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括</p>
<p>select * from table1 where time between time1 and time2</p>
<p>select a,b,c, from table1 where a not between 数值1 and 数值2</p>
<p>9、说明：in 的使用方法</p>
<p>select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)</p>
<p>10、说明：两张关联表，删除主表中已经在副表中没有的信息</p>
<p>delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )</p>
<p>11、说明：四表联查问题：</p>
<p>select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where …..</p>
<p>12、说明：日程安排提前五分钟提醒</p>
<p>SQL: select * from 日程安排 where datediff(‘minute’,f开始时间,getdate())&gt;5</p>
<p>13、说明：一条sql 语句搞定数据库分页</p>
<p>select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段</p>
<p>14、说明：前10条记录</p>
<p>select top 10 * form table1 where 范围</p>
<p>15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)</p>
<p>select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)</p>
<p>16、说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表</p>
<p>(select a from tableA ) except (select a from tableB) except (select a from tableC)</p>
<p>17、说明：随机取出10条数据</p>
<p>select top 10 * from tablename order by newid()</p>
<p>18、说明：随机选择记录</p>
<p>select newid()</p>
<p>19、说明：删除重复记录</p>
<p>Delete from tablename where id not in (select max(id) from tablename group by col1,col2,…)</p>
<p>20、说明：列出数据库里所有的表名</p>
<p>select name from sysobjects where type=’U’</p>
<p>21、说明：列出表里的所有的</p>
<p>select name from syscolumns where TableName’)</p>
<p>22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。</p>
<p>select type,sum(case vender when ‘A’ then pcs else 0 end),sum(case vender when ‘C’ then pcs else 0 end),sum(case vender when ‘B’ then pcs else 0 end) FROM tablename group by type</p>
<p>显示结果：</p>
<p>type vender pcs</p>
<p>电脑 A 1</p>
<p>电脑 A 1</p>
<p>光盘 B 2</p>
<p>光盘 A 2</p>
<p>手机 B 3</p>
<p>手机 C 3</p>
<p>23、说明：初始化表table1</p>
<p>TRUNCATE TABLE table1</p>
<p>24、说明：选择从10到15的记录</p>
<p>select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc</p>
<p>随机选择数据库记录的方法（使用Randomize函数，通过SQL语句实现）</p>
<p>对存储在数据库中的数据来说，随机数特性能给出上面的效果，但它们可能太慢了些。你不能要求ASP’找个随机数’然后打印出来。实际上常见的解决方案是建立如下所示的循环：</p>
<p>Randomize</p>
<p>RNumber = Int(Rnd*499) +1</p>
<p>While Not objRec.EOF</p>
<p>If objRec(“ID”) = RNumber THEN</p>
<p>… 这里是执行脚本 …</p>
<p>end if</p>
<p>objRec.MoveNext</p>
<p>Wend</p>
<p>这很容易理解。首先，你取出1到500范围之内的一个随机数（假设500就是数据库内记录的总数）。然后，你遍历每一记录来测试ID 的值、检查其是否匹配RNumber。满足条件的话就执行由THEN 关键字开始的那一块代码。假如你的RNumber 等于495，那么要循环一遍数据库花的时间可就长了。虽然500这个数字看起来大了些，但相比更为稳固的企业解决方案这还是个小型数据库了，后者通常在一 个数据库内就包含了成千上万条记录。这时候不就死定了？</p>
<p>采用SQL，你就可以很快地找出准确的记录并且打开一个只包含该记录的recordset，如下所示：</p>
<p>Randomize</p>
<p>RNumber = Int(Rnd*499) + 1</p>
<p>SQL = “SELECT * FROM Customers WHERE &amp; RNumber</p>
<p>set objRec = ObjConn.Execute(SQL)</p>
<p>Response.WriteRNumber &amp; “ = “ &amp; objRec(“ID”) &amp; “ “ &amp; objRec(“c_email”)</p>
<p>不必写出RNumber 和ID，你只需要检查匹配情况即可。只要你对以上代码的工作满意，你自可按需操作’随机’记录。Recordset没有包含其他内容，因此你很快就能找到你需要的记录这样就大大降低了处理时间。</p>
<p>再谈随机数</p>
<p>现在你下定决心要榨干Random 函数的最后一滴油，那么你可能会一次取出多条随机记录或者想采用一定随机范围内的记录。把上面的标准Random 示例扩展一下就可以用SQL应对上面两种情况了。</p>
<p>为了取出几条随机选择的记录并存放在同一recordset内，你可以存储三个随机数，然后查询数据库获得匹配这些数字的记录：</p>
<p>SQL = “SELECT * FROM Customers WHERE &amp; RNumber &amp; “ OR &amp; RNumber2 &amp; “ OR &amp; RNumber3</p>
<p>假如你想选出10条记录（也许是每次页面装载时的10条链接的列表），你可以用BETWEEN 或者数学等式选出第一条记录和适当数量的递增记录。这一操作可以通过好几种方式来完成，但是 SELECT 语句只显示一种可能（这里的ID 是自动生成的号码）：</p>
<p>SQL = “SELECT * FROM Customers WHERE ID BETWEEN “ &amp; RNumber &amp; “ AND “ &amp; RNumber &amp; “+ 9”</p>
<p>注意：以上代码的执行目的不是检查数据库内是否有9条并发记录。</p>
<p>随机读取若干条记录，测试过</p>
<p>Access语法：SELECT top 10 * From 表名 ORDER BY Rnd(id)</p>
<p>Sql server:select top n * from 表名 order by newid()</p>
<p>mysql</p>
<p>Access左连接语法(最近开发要用左连接,Access帮助什么都没有,网上没有Access的SQL说明,只有自己测试, 现在记下以备后查)</p>
<p>语法</p>
<p>使用SQL语句 用…代替过长的字符串显示</p>
<p>语法：</p>
<p>SQL数据库：select case when len(field)&gt;10 then left(field,10)+’…’ else field end as news_name,news_id from tablename</p>
<p>Access数据库：SELECT iif(len(field)&gt;2,left(field,2)+’…’,field) FROM tablename;</p>
<p>Conn.Execute说明</p>
<p>Execute方法</p>
<p>该方法用于执行SQL语句。根据SQL语句执行后是否返回记录集，该方法的使用格式分为以下两种：</p>
<p>1．执行SQL查询语句时，将返回查询得到的记录集。用法为：</p>
<p>Set 对象变量名=连接对象.Execute(“SQL 查询语言”)</p>
<p>Execute方法调用后，会自动创建记录集对象，并将查询结果存储在该记录对象中，通过Set方法，将记录集赋给指定的对象保存，以后对象变量就代表了该记录集对象。</p>
<p>2．执行SQL的操作性语言时，没有记录集的返回。此时用法为：</p>
<p>连接对象.Execute “SQL 操作性语句” [, RecordAffected][, Option]</p>
<p>RecordAffected 为可选项，此出可放置一个变量，SQL语句执行后，所生效的记录数会自动保存到该变量中。通过访问该变量，就可知道SQL语句队多少条记录进行了操作。</p>
<p>Option 可选项，该参数的取值通常为adCMDText，它用于告诉ADO，应该将Execute方法之后的第一个字符解释为命令文本。通过指定该参数，可使执行更高效。</p>
<p>BeginTrans、RollbackTrans、CommitTrans方法</p>
<p>这三个方法是连接对象提供的用于事务处理的方法。BeginTrans用于开始一个事物；RollbackTrans用于回滚事务；CommitTrans用于提交所有的事务处理结果，即确认事务的处理。</p>
<p>事务处理可以将一组操作视为一个整体，只有全部语句都成功执行后，事务处理才算成功；若其中有一个语句执行失败，则整个处理就算失败，并恢复到处里前的状态。</p>
<p>BeginTrans和CommitTrans用于标记事务的开始和结束，在这两个之间的语句，就是作为事务处理的语句。判断事务处理是否成功，可通过 连接对象的Error集合来实现，若Error集合的成员个数不为0，则说明有错误发生，事务处理失败。Error集合中的每一个Error对象，代表一 个错误信息。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>statement</tag>
      </tags>
  </entry>
  <entry>
    <title>通过MD5排除重复文件</title>
    <url>/2014/08/eliminate_repetitive/</url>
    <content><![CDATA[<p>今天下载了好多美女图片壁纸，可是看了一下发现好多图片重复了，有强迫症的我必须把重复的都给剔除掉，首先想到的当然是百度了，问问度娘有没有什么图片去重的工具，搜了一下还真有。奈何本人智商捉急用不来这高级的软件，无奈之下只好准备一张一张的挑出来了，CTRL+A一看2000+的图片，好吧一晚上不用干别的事了。。</p>
<span id="more"></span>
<p>辛亏脑袋还比较好使，既然作为一个程序员，为什么不能写个代码处理一下呢？想到点子说干咱就干，最重要的问题就是怎么判断图片是不是重复的呢？通过文件名？还是比较大小？好像都不怎么靠谱啊。。突然又是灵光一闪，每个文件不都是有个DNA信息嘛，相同的文件MD5值肯定是一样的嘛。</p>
<p>废话说了这么多，下面说正经的了，首先要怎么获得文件的MD5值呢？这回度娘倒没让我失望了，直接上代码：</p>
<pre><code class="java">String p = &quot;E:\\123.jpg&quot;;
FileInputStream fis = new FileInputStream(p);
String md5 = DigestUtils.md5Hex(IOUtils.toByteArray(fis));
IOUtils.closeQuietly(fis);
System.out.println(&quot;md5: &quot;+md5);
</code></pre>
<p>得到所有文件的md5之后进行比较，相同的md5就是重复的文件了。md5已经得到了剩下的就很简单了，通过File取到所有的文件，然后再获取文件的MD5，再写个双重for循环排除掉相同的md5，写完收工搞定。运行起来就等结果了，这一等就是两个小时。。好在结果倒是挺不错。但是这个时间有点让人接受不了啊，这个代码还是有问题啊，得优化。又一想，集合去重复这不可以用Set嘛，赶紧把代码稍作改造，分分钟搞定。。差距也恁大了，看来这java基础还是不够牢固啊。又要从头看一遍书了。。附上最终代码：</p>
<pre><code class="java">String path = &quot;E:\\123&quot;;
File dir = new File(path);
String[] files = dir.list();
Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;();
for (int i = 0; i &lt; files.length; i++)
&#123;
    String p = path + &quot;\\&quot; + files[i];
    FileInputStream fis = new FileInputStream(p);
    String md5 = DigestUtils.md5Hex(IOUtils.toByteArray(fis));
    IOUtils.closeQuietly(fis);
    map.put(md5,files[i]);
&#125;
Iterator&lt;String&gt; it = map.keySet().iterator();
while (it.hasNext())
&#123;
    String md5=it.next();
    String filename=map.get(md5);
    System.out.println(&quot;不重复的文件:&quot;+filename);
&#125;
</code></pre>
<p>各位看官们要是有什么更好的方法可以给我提出来啊。最后还是不管遇到什么问题还是要先仔细的分析研究一下，不要急着动手敲代码，思路清晰了敲出来的代码才会更有效。</p>
<p>明天再准备做一个简单的客户端程序，这样以后就不用每次来运行代码了。回头会把源代码附上。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MD5</tag>
        <tag>重复</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>沉淀生命，沉淀自己</title>
    <url>/2015/06/stockpile-life/</url>
    <content><![CDATA[<p>生活，品味过方知其中滋味，纠结，解决了才明白什么叫豁然开朗，行走在生命的路上，就当每一种感觉都是上天恩赐，其实每一种感觉都是生命中不可缺少的组成部分，学会坦然接受，用心承载，每一段经历都将会是一次成长的洗礼，逐步在洗礼中了悟与成熟，以坚强为支点，阳光为半径，走好一个自己满意的人生。</p>
<span id="more"></span>

<p>生活不会是一帆风顺，它本身就是苦辣酸甜的交响曲，点滴丰盈都是成熟的积淀，人生因经历而斑斓，而经历是对人格一种考验，能够做到荣宠不惊是一种心智的提升，也是一种让人仰慕的品德，是人格魅力的具体表现，所以应该感谢一切生活的给予。</p>
<p>万念皆由心生，心若计较处处都是阴蔼，不要庸人自扰，掬一捧经年的水，洗去浮世苍凉，让心在豁然开朗中行走，做一个坦荡、简单而且开心的自己，与时光同行无须太多理由，只要，一路向暖，足矣！</p>
<p>阳光着是一种积极的心态，在尘世间行走，有谁不曾碰壁？要懂得随机应变才不会让自身纠结，条条大路通罗马，何必拘泥，外界固然可以动摇浮躁的心，只要守住心内的风景，沿着光明继续，只要你愿意，就能绘出自己喜欢的缤纷！</p>
<p>心是承载万物之首，心态决定生活的质量。人一旦奢望太多，人和事物就是失去原有的美好，人之所以痛苦是因为奢望，那种奢望达不到自己的理想，如果想要拥有快乐，就要卸载背负的压力！春天是芳香的季节，是轮回的起点，秋冬的阴霭阻止不了阳光的呈现，掸去沾染的灰尘，放下一楼烟雨的烦忧，让眼前一切澄明，纵使排山倒海的挤压终阻止不了心的向往，人生仍会在风雨中开出色彩斑斓的花。无须让自己走的太匆忙，留下一些闲暇细品流年，学会用不同的角度看问题，错过的当作回忆，不要纠缠，美好在前方，路在脚下，用最坦然的姿态，走出一个无法复制的绝版！</p>
<p>理想很丰满，现实很骨感，幼稚在理智的眼里显得那么卑微，幻影的世界终是浮华虚幻，镜中水月终会是一纸流沙，挽不住刹那芳华，留不住过眼云烟，烟花只是瞬间美，舞尽阑珊不必留恋。放下，是一个痛苦的过程，因为不适合所以纠结，努力的勉强始终是留不住的指间沙，有时候快刀斩乱麻是最理智的选择，别等不该等的人，别伤不该伤的心，徘徊在十字路口 “一念愚即若绝，一念智即若生”，关键看你自己如何抉择。</p>
<p>每个人都不是完美的，错误在所难免，大可不必活在别人的眼光里，或许在别人眼里你分文不值，但请相信你自己，你依旧是独一无二的风景，一味的讨好不一定换来别人尊重，那么请让不愿意留下的离开，做个潇脱而且有尊严的自己！因为路只可以向前走，一些事注定会被遗忘，一些人注定会成为过客，当珍惜的己经流逝，放开手，让它随风远去。在四季交替中，在人情冷暖中，逐渐学会了坚强，没有人会是你一辈子的依靠，只有选择理智的面对一切，从容走过每一个坑坑坎坎，相信，风雨后阳光更明媚！</p>
<p>行行色色中行走，无须给自己灌输太多压力，就当所有的一切是对自身成熟的一种考验，人无完人，原谅别人的过错也等于原谅自己，阳光的心态最重要，学会给自己减压，学会及时清扫隐藏于黑白交替之间产生垃圾，积极面对，做到无愧于心，让谬论止于智者，走自己的路，轻装前行，你将会收获更多美丽！</p>
<p>经历依旧是未完的故事，每一天继续演驿着悲欢，在长长的沉思中品悟况味，只想依着文字，把清清浅浅的心事悉数写进记忆的书卷，不求华丽，只要一份简约，让恬淡驻扎在心里，掬一杯流年的茶，细品百般滋味，让心在静怡中享受温润时光，轻轻搁浅记忆的尘烟，让心澄明清透，在时光静好中梳理沾染风尘的心情，轻握一份洒脱，放下一个释然，在风轻云淡中过随遇而安的生活。</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>一些免费的WebService的服务网站</title>
    <url>/2015/06/free-webservice/</url>
    <content><![CDATA[<p>记录了一些免费的WebService的服务网站,包括翻译,天气,股票,基金,航班,外汇,电视节目,QQ,火车时刻表,简繁体转换,Email,验证码,邮政编码,IP地址等接口</p>
<span id="more"></span>
<p>Endpoint: <a href="http://fy.webxml.com.cn/webservices/EnglishChinese.asmx">http://fy.webxml.com.cn/webservices/EnglishChinese.asmx</a><br>Disco: <a href="http://fy.webxml.com.cn/webservices/EnglishChinese.asmx?disco">http://fy.webxml.com.cn/webservices/EnglishChinese.asmx?disco</a><br>WSDL: <a href="http://fy.webxml.com.cn/webservices/EnglishChinese.asmx?wsdl">http://fy.webxml.com.cn/webservices/EnglishChinese.asmx?wsdl</a></p>
<p>新中文&lt;-&gt;英文双向翻译WEB服务，永久免费。提供翻译、音标（拼音）、解释、相关词条、例句、读音MP3支持（英文Only）、候选词等功能。比原来的中英文双向翻译WEB服务提供更多更强大的功能。帮助文档</p>
<p>国内手机号码归属地查询WEB服务 通讯和通信<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx">http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx?disco">http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl</a></p>
<p>国内手机号码归属地查询WEB服务，提供最新的国内手机号码段归属地数据，每月更新。包括最新的电信天翼189号段和最新移动152号段、TD-SCDMA188号段。数据更全更准确，是目前国内最新最全的手机号码段数据库！</p>
<p>2400多个城市天气预报 WEB服务 公用事业<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/WeatherWS.asmx">http://webservice.webxml.com.cn/WebServices/WeatherWS.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/WeatherWS.asmx?disco">http://webservice.webxml.com.cn/WebServices/WeatherWS.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/WeatherWS.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/WeatherWS.asmx?wsdl</a></p>
<p>2400多个城市天气预报Web服务，包含2300个以上中国城市和100个以上国外城市天气预报数据。数据每2.5小时左右自动更新一次，准确可靠。为让更多的开发人员学习WEB服务开发，此服务支持免费用户使用。为支持多种平台开发，此WEB服务接口提供了多种返回类型可选择。</p>
<p>股票行情数据 WEB 服务（支持香港、深圳、上海基金、债券和股票；支持多股票同时查询） 商业和贸易<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/StockInfoWS.asmx">http://webservice.webxml.com.cn/WebServices/StockInfoWS.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/StockInfoWS.asmx?disco">http://webservice.webxml.com.cn/WebServices/StockInfoWS.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/StockInfoWS.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/StockInfoWS.asmx?wsdl</a></p>
<p>支持香港股票、深圳、上海封闭式基金、债券和股票；支持多股票同时查询。数据即时更新。此中国股票行情数据 WEB 服务仅作为用户获取信息之目的，并不构成投资建议。支持使用 | 符号分割的多股票查询。</p>
<p>中国开放式基金数据 WEB 服务 商业和贸易<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/ChinaOpenFundWS.asmx">http://webservice.webxml.com.cn/WebServices/ChinaOpenFundWS.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/ChinaOpenFundWS.asmx?disco">http://webservice.webxml.com.cn/WebServices/ChinaOpenFundWS.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/ChinaOpenFundWS.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/ChinaOpenFundWS.asmx?wsdl</a></p>
<p>中国开放式基金数据 WEB 服务，数据每天15：30以后及时更新。输出数据包括：证券代码、证券简称、单位净值、累计单位净值、前单位净值、净值涨跌额、净值增长率(%)、净值日期。</p>
<p>国内飞机航班时刻表 WEB 服务 公用事业<br>Endpoint: <a href="http://webservice.webxml.com.cn/webservices/DomesticAirline.asmx">http://webservice.webxml.com.cn/webservices/DomesticAirline.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/webservices/DomesticAirline.asmx?disco">http://webservice.webxml.com.cn/webservices/DomesticAirline.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/webservices/DomesticAirline.asmx?wsdl">http://webservice.webxml.com.cn/webservices/DomesticAirline.asmx?wsdl</a></p>
<p>国内飞机航班时刻表 Web Service 提供：通过出发城市和到达城市查询飞机航班、出发机场、到达机场、出发和到达时间、飞行周期、航空公司、机型等信息。</p>
<p>中国股票行情分时走势预览缩略图 WEB 服务 商业和贸易<br>Endpoint: <a href="http://webservice.webxml.com.cn/webservices/ChinaStockSmallImageWS.asmx">http://webservice.webxml.com.cn/webservices/ChinaStockSmallImageWS.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/webservices/ChinaStockSmallImageWS.asmx?disco">http://webservice.webxml.com.cn/webservices/ChinaStockSmallImageWS.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/webservices/ChinaStockSmallImageWS.asmx?wsdl">http://webservice.webxml.com.cn/webservices/ChinaStockSmallImageWS.asmx?wsdl</a></p>
<p>中国股票行情分时走势预览缩略图 WEB 服务（支持深圳和上海股市的全部基金、债券和股票），数据即时更新。返回数据：2种大小可选择的股票GIF分时走势预览缩略图字节数组和直接输出该预览缩略图。</p>
<p>外汇-人民币即时报价 WEB 服务 商业和贸易<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/ForexRmbRateWebService.asmx">http://webservice.webxml.com.cn/WebServices/ForexRmbRateWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/ForexRmbRateWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/ForexRmbRateWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/ForexRmbRateWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/ForexRmbRateWebService.asmx?wsdl</a></p>
<p>外汇-人民币即时报价 WEB 服务， 报价数据即时更新。外汇-人民币即时报价 WEB 服务仅作为用户获取信息之目的，并不构成投资建议。支持人民币对：美元、欧元、英镑、日元、港币、加拿大元、新西兰元、新加坡元、瑞士法郎、瑞典克朗、泰国铢、挪威克朗、澳门元、澳大利亚元、丹麦克朗、菲律宾比索、清算瑞士法郎等的兑换即时报价。</p>
<p>中国电视节目预告（电视节目表） WEB 服务 公用事业<br>Endpoint: <a href="http://webservice.webxml.com.cn/webservices/ChinaTVprogramWebService.asmx">http://webservice.webxml.com.cn/webservices/ChinaTVprogramWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/webservices/ChinaTVprogramWebService.asmx?disco">http://webservice.webxml.com.cn/webservices/ChinaTVprogramWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/webservices/ChinaTVprogramWebService.asmx?wsdl">http://webservice.webxml.com.cn/webservices/ChinaTVprogramWebService.asmx?wsdl</a></p>
<p>中国电视节目预告 Web 服务，数据准确可靠，提供全国近800个电视拼道一个星期以上的节目预告数据。一、获得支持的省市（地区）和分类电视列表；二、通过省市ID或分类电视ID获得电视台列表；三、通过电视台ID获得该电视台频道名称；四、通过频道ID获得该频道节目列表。</p>
<p>腾讯QQ在线状态 WEB 服务 通讯和通信<br>Endpoint: <a href="http://webservice.webxml.com.cn/webservices/qqOnlineWebService.asmx">http://webservice.webxml.com.cn/webservices/qqOnlineWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/webservices/qqOnlineWebService.asmx?disco">http://webservice.webxml.com.cn/webservices/qqOnlineWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/webservices/qqOnlineWebService.asmx?wsdl">http://webservice.webxml.com.cn/webservices/qqOnlineWebService.asmx?wsdl</a></p>
<p>通过输入QQ号码（String）检测QQ在线状态。返回数据（String）Y = 在线；N = 离线 ；E = QQ号码错误</p>
<p>即时外汇汇率数据 WEB 服务 商业和贸易<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/ExchangeRateWebService.asmx">http://webservice.webxml.com.cn/WebServices/ExchangeRateWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/ExchangeRateWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/ExchangeRateWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/ExchangeRateWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/ExchangeRateWebService.asmx?wsdl</a></p>
<p>即时外汇汇率数据 WEB 服务，数据即时更新。此外汇汇率数据 WEB 服务支持29种以上基本汇率和交叉汇率即时外汇汇率数据，返回包括：代码、货币名称、最新价、涨跌%、涨跌金额、开盘价、最高价、最低价、震幅%、买入价、卖出价、涨跌颜色和数据时间。实例</p>
<p>中国股票行情数据 WEB 服务（支持深圳和上海股市的基金、债券和股票） 商业和贸易<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/ChinaStockWebService.asmx">http://webservice.webxml.com.cn/WebServices/ChinaStockWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/ChinaStockWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/ChinaStockWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/ChinaStockWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/ChinaStockWebService.asmx?wsdl</a></p>
<p>中国股票行情数据 WEB 服务，数据即时更新。输出GIF分时走势图、日/周/月K线图、及时行情（股票名称、行情时间、最新价、昨收盘、今开盘、涨跌额、最低、最高、涨跌幅、成交量、成交额、竞买价、竞卖价、委比、买一 - 买五、卖一 - 卖五）。</p>
<p>火车时刻表 WEB 服务 （第六次提速最新列车时刻表） 公用事业<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/TrainTimeWebService.asmx">http://webservice.webxml.com.cn/WebServices/TrainTimeWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/TrainTimeWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/TrainTimeWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/TrainTimeWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/TrainTimeWebService.asmx?wsdl</a></p>
<p>火车时刻表 WEB 服务提供：站站查询；车次查询；车站所有车次查询。数据来源时间：2008-04-15 第六次提速最新列车时刻表。本火车时刻表 WEB 服务提供的列车时刻表数据仅供参考，如有异议以当地铁路部门颁布为准。</p>
<p>中文 &lt;-&gt; 英文双向翻译 WEB 服务 获得标准数据<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/TranslatorWebService.asmx">http://webservice.webxml.com.cn/WebServices/TranslatorWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/TranslatorWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/TranslatorWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/TranslatorWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/TranslatorWebService.asmx?wsdl</a></p>
<p>中文 &lt;-&gt; 英文双向翻译 WEB 服务，本词典库中大部分单词是由程序根据词频和英&lt;-&gt;中单词间相互关联程度自动生成，难免存在有解释错误和牵强的地方请大家谅解。</p>
<p>中文简体字&lt;-&gt;繁体字转换 WEB 服务 计算和单位换算<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/TraditionalSimplifiedWebService.asmx">http://webservice.webxml.com.cn/WebServices/TraditionalSimplifiedWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/TraditionalSimplifiedWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/TraditionalSimplifiedWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/TraditionalSimplifiedWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/TraditionalSimplifiedWebService.asmx?wsdl</a></p>
<p>中文简体字&lt;-&gt;繁体字转换 WEB 服务！</p>
<p>Email 电子邮件地址验证 WEB 服务 通讯和通信<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/ValidateEmailWebService.asmx">http://webservice.webxml.com.cn/WebServices/ValidateEmailWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/ValidateEmailWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/ValidateEmailWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/ValidateEmailWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/ValidateEmailWebService.asmx?wsdl</a></p>
<p>Email 电子邮件地址验证 Web Service，通过查找给定的电子邮件域的邮件服务器和通过向邮件服务器发送数据来判断电子邮件地址正确与否。</p>
<p>验证码图片 WEB 服务 支持中文、字母、数字 图像和多媒体<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/ValidateCodeWebService.asmx">http://webservice.webxml.com.cn/WebServices/ValidateCodeWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/ValidateCodeWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/ValidateCodeWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/ValidateCodeWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/ValidateCodeWebService.asmx?wsdl</a></p>
<p>验证码图片 WEB 服务，输出PNG高品质格式的验证码图片和字节流，字符和字符之间的间距和高度随机产生，提高了验证码的安全性。支持中文、字母、数字验证码图片。</p>
<p>中国邮政编码 &lt;-&gt; 地址信息双向查询/搜索 WEB 服务获得标准数据<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/ChinaZipSearchWebService.asmx">http://webservice.webxml.com.cn/WebServices/ChinaZipSearchWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/ChinaZipSearchWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/ChinaZipSearchWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/ChinaZipSearchWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/ChinaZipSearchWebService.asmx?wsdl</a></p>
<p>中国邮政编码搜索 WEB 服务包含中国全部邮政编码共计187285条记录，是目前最完整的邮政编码数据，精确到乡镇级、城市精确到街道，支持邮政编码&lt;-&gt;城市、乡镇、街道的双向查询。此邮政编码查询仅供参考。</p>
<p>随机英文、数字和中文简体字 WEB 服务 其他 Web Services<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/RandomFontsWebService.asmx">http://webservice.webxml.com.cn/WebServices/RandomFontsWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/RandomFontsWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/RandomFontsWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/RandomFontsWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/RandomFontsWebService.asmx?wsdl</a></p>
<p>随机英文、数字和中文简体字 WEB 服务，可用于验证码及其他方面，这里支持最多不超过8个随机中文简体字，10个随机英文、数字输出。</p>
<p>IP地址来源搜索 WEB 服务（是目前最完整的IP地址数据） 获得标准数据<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/IpAddressSearchWebService.asmx">http://webservice.webxml.com.cn/WebServices/IpAddressSearchWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/IpAddressSearchWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/IpAddressSearchWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/IpAddressSearchWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/IpAddressSearchWebService.asmx?wsdl</a></p>
<p>IP地址搜索 WEB 服务包含中国和国外已知的IP地址数据，是目前最完整的IP地址数据，记录数量现已超过30万条并还在不断更新和增加中，感谢纯真网络提供IP地址数据来源。因IP地址在不断变化，此IP地址数据查询仅供参考，如发现IP地址查询错误请向纯真网络报告。</p>
<p>400个国内外主要城市天气预报Web服务 公用事业<br>Endpoint: <a href="http://webservice.webxml.com.cn/WebServices/WeatherWebService.asmx">http://webservice.webxml.com.cn/WebServices/WeatherWebService.asmx</a><br>Disco: <a href="http://webservice.webxml.com.cn/WebServices/WeatherWebService.asmx?disco">http://webservice.webxml.com.cn/WebServices/WeatherWebService.asmx?disco</a><br>WSDL: <a href="http://webservice.webxml.com.cn/WebServices/WeatherWebService.asmx?wsdl">http://webservice.webxml.com.cn/WebServices/WeatherWebService.asmx?wsdl</a></p>
<p>400个国内外主要城市天气预报Web服务，每个城市天气预报数据每0.5小时左右自动更新一次，（原来为每个城市2.5小时更新，为了保证已经引用此服务的部分用户不再重新更新已编写的程序，所以 Endpoint 上的说明没有更改），数据准确可靠。包括 340 多个中国主要城市和 60 多个国外主要城市三日内的天气预报数据。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>WebService</tag>
        <tag>接口</tag>
        <tag>服务</tag>
      </tags>
  </entry>
  <entry>
    <title>22 种代码的坏味道</title>
    <url>/2014/09/code-stink-22/</url>
    <content><![CDATA[<p>22 种代码的坏味道</p>
<span id="more"></span>
<h2 id="1-Duplicated-Code-重复的代码"><a href="#1-Duplicated-Code-重复的代码" class="headerlink" title="1.Duplicated Code(重复的代码)"></a>1.Duplicated Code(重复的代码)</h2><p>臭味行列中首当其冲的就是Duplicated Code。如果你在一个以上的地点看到相同的程序结构，那么当可肯定：设法将它们合而为一，程序会变得更好。</p>
<p>最单纯的Duplicated Code就是［同一个class内的两个方法含有相同表达式(expression)］。这时候你需要做的就是采用Extract Method提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。</p>
<p>另一种常见情况就是[两个互为兄弟(sibling)的subclasses内含有相同表达式]。要避免这种情况，只需要对两个classes都使用 Extract Method，然后再对被提炼出的代码使用Pull Up Method，将它推入superclass内。如果代码之间只是类似，并非完全相同，那么就得运用Extract Method将相似部分和差异部分割开，构成单独一个方法。然后你可能发现或许可以运用Form Template Method获得一个Template Method设计模式。如果有些方法以不同的算法做相同的事，你可以择定其中较清晰的一个，并使用Substitute Algorithm将其它方法的算法替换掉。</p>
<p>如果两个毫不相关的classes内出现Duplicated Code，你应该考虑对其中一个使用Extract Class，将重复代码提炼到一个独立class中，然后在另一个class内使用这个新class。但是，重复代码所在的方法也可能的确只应该属于某个 class，另一个class只能调用它，抑或这个方法可能属于第三个class，而另两个classes应该引用这第三个class。你必须决定这个方法放在哪儿最合适，并确保它被安置后就不会再在其它任何地方出现。</p>
<h2 id="2-Long-Method-过长方法"><a href="#2-Long-Method-过长方法" class="headerlink" title="2.Long Method(过长方法)"></a>2.Long Method(过长方法)</h2><p>拥有[短方法]（short methods）的对象会活得比较好、比较长。不熟悉面向对象技术的人，常常觉得对象程序中只有无穷无尽的delegation(委托)，根本没有进行任何计算。和此类程序共同生活数年之后，你才会知道，这些小小方法有多大价值。［间接层］所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型方法支持的。</p>
<p>很久以前程序员就已认识到：程序愈长愈难理解。早期的编程语言中，［子程序调用动作］需要额外开销，这使得做你们不太乐意使用small method，现代OO语言几乎已经完全免除了进程内的[方法调用动作额外开销]。不过代码阅读者还是得多费力气，因为他必须经常转换上下文去看看子程序做了什么。某些开发环境允许用户同时看到两个方法，这可以帮助你省去部分麻烦，但是让small method容易理解的真正关键在于一个好名字。如果你能给方法起个好名字，读者就可以通过名字了解方法的作用，根本不必去看其中写了些什么。</p>
<p>最终的效果是：你应该更积极进取地分解方法。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的方法中，并以其用途(而非实现手法)命名。我们可以对一组或甚至短短一行代码做这件事。哪怕替换后的方法调用动作比方法自身还长，只要方法名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于方法的长度，而在于方法[做什么]和[如何做]之间的语义距离。</p>
<p>百分之九十九的场合里，要把方法变小，只需使用Extract Method。找到方法中适合集在一起的部分，将它们提炼出来形成一个新方法。</p>
<p>如果方法内有大量的参数和临时变量，它们会对你的方法提炼形成阻碍。如果你尝试运用Extract Method，最终就会把许多这些参数和临时变量当作参数，传递给被提炼出来的新方法，导致可读性几乎没有任何提升。啊是的，你可以经常运用 Replace Temp with Query则可以将过长的参数列变得更简洁一些。</p>
<p>如果你已经这么做，仍然有太多临时变量和参数，那就应该拿出我们的杀手锏：Replace Method with Method Object。</p>
<p>如何确定该提炼哪一段代码呢？一个很好的技巧是：寻找注释。它们通常是指出[代码用途和实现手法间的语义距离]的信号。如果代码前言有一行注释，就是在提醒你：可以将这段代码替换成一个方法，而且可以在注释的基础上给这个方法命名。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立的方法去。</p>
<p>条件式和循环常常也是提炼的信号。你可以使用Decompose Conditional处理条件式。至于循环，你应该将循环和其内的代码提炼到一例独立方法中。</p>
<h2 id="3-Large-Class-过大类"><a href="#3-Large-Class-过大类" class="headerlink" title="3.Large Class(过大类)"></a>3.Large Class(过大类)</h2><p>如果想利用单一class做太多事情，其内往往就会出现太多instance变量。一旦如此，Duplicated Code也就接踵而至了。</p>
<p>你可以运用Extract Class将数个变量一直提炼到新class内。提炼时应该选择class内彼此相关的变量，将它们放在一直。例如”depositAmount” 和”depositCurrency”可能应该隶属同一个class。通常如果class内的数个变量有着相同的前缀或字尾，这就意味有机会把它们提炼到某个组件内。如果这个组件适合作为一个subclass，你会发现Extract Subclass往往比较简单。</p>
<p>有时候class并非在所有时刻都使用所有instance变量。果真如此，你或许可以多次使用Extract Class或Extract Subclass。</p>
<p>和[太多instance变量]一样，class内如果有太多代码，也是[]代码重复、混乱、死亡]的绝佳滋生地点。最简单的解决方案是把赘余的东西消弭于class内部。如果有五个[百行方法]，它们之中很多代码都相同，那么或许你可以把它们变成五个［十行方法］和十个提炼出来的［双行方法］。</p>
<p>和[拥有太多instance变量]一样，一个class如果拥有太多代码，往往也适合使用Extract Class和Extract Subclass。这里有个有用技巧：先确定客户端如何使用它们，然后运用Extract Interface为每一种使用一个接口。这或许可以帮助你看清楚如何分解这个class。</p>
<p>如果你的Large Class是个GUI class，你可能需要把数据和行为移到一个独立的领域对象去。你可能需要两边各保留一些重复数据，并令这些数据同步。Duplicate Observed Data告诉你该怎么做。这种情况下，特别是如果你使用旧式AWT组件，你可以采用这种方式去掉GUI class并代以Swing组件。</p>
<h2 id="4-Long-Parameter-List-过长参数列"><a href="#4-Long-Parameter-List-过长参数列" class="headerlink" title="4.Long Parameter List(过长参数列)"></a>4.Long Parameter List(过长参数列)</h2><p>刚开始学习编程的时候，老师教我们：把方法所需的所有东西都以参数传递进去。这可以理解，因为除此之外就只能选择全局数据，而全局数据是邪恶的东西。对象技术改变了这一情况，因为如果你手上没有你所需要的东西，总可以叫另一个对象给你。因此，有了对象，你就不必把方法需要的所有东西都以参数传递给它了，你只需给它足够的东西、让方法能从中获得自己需要的所有东西就行了。方法需要的东西多半可以在方法的宿主类(host class)中找到。面向对象程序中的方法，其参数列通常比在传统程序中短得多。</p>
<p>这是好现象，因为太长的参数列难以理解，太多参数会造成前后不一致、不易使用，而且一旦你需要更多数据，就不得不修改它。如果将对象传递给方法，大多数修改都将没有必要，因为你很可能只需(在方法内)增加一两条请求，就能得到更多数据。</p>
<p>如果[向既有对象发出一条请求]就可以取得原本位于参数列上的一份数据，那么你应该激活重构准则Replace Parameter with Method。上述的既有对象可能是方法所属class内的一个字段，也可能是另一个参数。你还可以运用Preserve Whole Object将来自同一对象的一堆数据收集起来，并以该对象替换它们。如果某些数据缺乏合理的对象归属，可使用Introduce Parameter Object为它们制造出一个[参数对象]。</p>
<p>此间存在一个重要的例外。有时候你明显不希望造成[被调用之对象]与[较大对象]间的某种依存关系。这时候将数据从对象中拆解出来单独作为参数，也很合情合理。但是请注意其所引发的代价。如果参数列太长或变化太频繁，你就需要重新考虑自己的依存结构了。</p>
<h2 id="5-Divergent-Change-发散式变化"><a href="#5-Divergent-Change-发散式变化" class="headerlink" title="5.Divergent Change(发散式变化)"></a>5.Divergent Change(发散式变化)</h2><p>我们希望软件能够更容易被修改——毕竟软件再怎么说本来就该是[软]的。一旦需要修改，我们希望能够跌到系统的某一点，只在该处做修改。如果不能做到这点，你就嗅出两种紧密相关的刺鼻味道中的一种了。</p>
<p>如果某个class经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了。当你看着一个class说：“ 呃，如果新加入一个数据库，我必须修改这三个方法；如果新出现一种金融工具，我必须修改这四个方法”，那么此时也许将这个对象分成两个会更好，这么一来每个对象就可以只因一种变化而需要修改。当然，往往只有在加入新数据库或新金融工具后，你才能发现这一点。针对某一外界变化的所有相应修改，都只应该发生在单一class中，而这个新class内的所有内容都应该反应该外界变化。为此，你应该找出因着某特定原因而造成的所有变化，然后运用Extract Class将它们提炼到另一个class中。</p>
<h2 id="6-Shotgun-Surgery-霰弹式修改"><a href="#6-Shotgun-Surgery-霰弹式修改" class="headerlink" title="6.Shotgun Surgery(霰弹式修改)"></a>6.Shotgun Surgery(霰弹式修改)</h2><p>Shotgun Surgery类似Divergent Change，但恰恰相反。如果每遇到某种变化，你都必须在许多不同的class内做出许多小修改以响应之，你所面临的坏味道就是Shotgun Surgery。如果需要修改的代码散布四处，你不但很难找到它们，也很容易忘记某个重要的修改。</p>
<p>这种情况下你应该使用Move Method和Move Field把所有需要修改的代码放进同一个class。如果眼下没有合适的class可以安置这些代码，就创造一个。通常你可以运用Inline Class把一系列相关行为放进同一个class。这可能会造成少量Divergent Change，但你可以轻易处理它。</p>
<p>Divergent Change是指[一个class受多种变化的影响]，Shotgun Surgery则是指[一种变化引发多个classes相应修改]。这两种情况下你都会希望整理代码，取得[外界变化]与[待改类]呈现一对一关系的理想境地。</p>
<h2 id="7-Feature-Envy-依恋情结"><a href="#7-Feature-Envy-依恋情结" class="headerlink" title="7.Feature Envy(依恋情结)"></a>7.Feature Envy(依恋情结)</h2><p>对象技术的全部要点在于：这是一种[将数据和加诸其上的操作行为包装在一起]的技术。有一种经典气味是：方法对某个class的兴趣高过对自己所处之 host class的兴趣。这种孺慕之情最通常的焦点便是数据。无数次经验里，我们看到某个方法为了计算某值，从另一个对象那儿调用几乎半打的取值方法。疗法显而易见：把这个方法移到另一个地点。你应该使用Move Method把它移到它该去的地方。有时候方法中只有一部分受这种依恋之苦，这时候你应该使用Extract Method把这一部分提炼到独立方法中，再使用Move Method带它去它的梦中家园。</p>
<p>当然，并非所有情况都这么简单。一个方法往往会用上数个classes特性，那么它究竟该被置于何处呢？我们的原则是：判断哪个class拥有最多[被此方法使用]的数据，然后就把这个方法和那些数据摆在一起。如果先以Extract Method将这个方法分解为整个较小方法并分别置放于不同地点，上述步骤也就比较容易完成了。</p>
<p>有数个复杂精巧的模式破坏了这个规则。说起这个话题，［四巨头］的Streategy和Visitor立刻跳入我的脑海，Kent Beck的Self Delegation也丰此列。使用这些模式是为了对抗坏味道Divergent Change。最根本的原则是：将总是一起变化的东西放在一块儿。［数据］和[引用这些数据]的行为总是一起变化的，但也有例外。如果例外出现，我们就搬移那些行为，保持[变化只在一起发生]。Strategy和Visitor使你得以轻松修改方法行为，因为它们将少量需要被覆写的行为隔离开来——当然也付出了[多一层间接性]的代价。</p>
<h2 id="8-Data-Clumps-数据泥团"><a href="#8-Data-Clumps-数据泥团" class="headerlink" title="8.Data Clumps(数据泥团)"></a>8.Data Clumps(数据泥团)</h2><p>数据项就像小孩子：喜欢成群结队地待在一块儿。你常常可以在很多地方看到相同的三或四笔数据项：两个classes内的相同字段、许多方法签名式中的相同参数。这些[总是绑在一起出现的数据]真应该放进属于它们自己的对象中。首先请找出这些数据的字段形式出现点，运用Extract Class将它们提炼到一个独立对象中。然后将注意力转移到方法签名式上头，运用Introduce Parameter Object或Preserve Whole Object为它减肥。这么做的直接好处是可以将很多参数列缩短，简化方法调用动作。是的，不必因为Data Clumps只用上新对象的一部分字段而在意，只要你以新对象取代两个(或更多)字段，你就值回票价了。</p>
<p>一个好的评断办法是：删掉众多数据中的一笔。其它数据有没有因而失去意义？如果它们不再有问询，这就是个明确信号：你应该为它们产生一个新对象。</p>
<p>缩短字段个数和参数个数，当然可以支队一些坏味道，但更重要的是：一旦拥有新对象，你就有机会让程序散发出一种芳香。得到新对象后，你就可以着手寻找 Feature Envy，这可以帮你指出[可移到新class]中的种种程序行为。不必太久，所有classes都将在它们的小小社会中充分发挥自己的生产力。</p>
<h2 id="9-Primitive-Obsession-基本型别偏执"><a href="#9-Primitive-Obsession-基本型别偏执" class="headerlink" title="9.Primitive Obsession(基本型别偏执)"></a>9.Primitive Obsession(基本型别偏执)</h2><p>大多数编程环境都有两种数据：结构型别允许你将数据组织成有意义的形式；基本型别则是构成结构型别的积木块。结构总是会带来一定的额外开销。它们有点像数据库中的表格，或是那些得不偿失的东西。</p>
<p>对象的一个极具价值的东西早到：它们模糊了横亘于基本数据和体积较大的classes之间的界限。你可以轻松编写出一些与语言内置型别无异的小型 classes。例如Java就以基本型别表示数值，而心class表示字符串和日期——这两个型别在其它许多编程环境中都以基本型别表现。</p>
<p>对象技术的新手通常在小任务上运用小对象——像是结合数值和币别的money class、含一个起始值和一个结束值的range class、电话号码或邮政编码等等的特殊strings。你可以运用Replace Data Value with Object将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。如果欲替换之数据值是type code，而它并不影响行为，你可以运用Replace Type Code with Class将它换掉。如果你有相依于此type code的条件式，可运用Replace Type Code with Subclass或Replace Type Code with State/Strategy加以处理。</p>
<p>如果你有一组应该总是被放在一起的字段，可运用Extract Class。如果你在参数列中看到基本型数据，不妨试试Introduce Parameter Object。如果你发现自己正从array中挑选数据，可运用Replace Array with Object。</p>
<h2 id="10-Switch-Statements-switch惊悚现身"><a href="#10-Switch-Statements-switch惊悚现身" class="headerlink" title="10.Switch Statements(switch惊悚现身)"></a>10.Switch Statements(switch惊悚现身)</h2><p>面向对象程序的一个最明显特征就是：少用switch(或case)语句。从本质上说，switch语句的问题在于重复。你常会发现同样的switch语句散布于不同的地点。如果要为它添加一个新的case子句，你必须找到所有switch语句并修改它们。面向的多态概念可为此带来优雅的解决办法。</p>
<p>大多数时候，一看到switch语句你就应该考虑以多态来替换它。问题是多态该出现在哪儿？switch语句常常根据type code进行选择，你要的是[与该type code相关的方法或class]。所以你应该使用Extract Method将switch语句提炼到一个独立方法中，再以Move Method将它搬移到需要多态性的那个class里头。此时你必须决定是否使用Replace Type Code with Subclasses或Replace Type Code with State/Strategy。一旦这样完成继承结构之后，你就可以运用Replace Conditional with Polymorphism了。</p>
<p>如果你只是在单一方法中髭选择事例，而你并不想改动它们，那么[多态]就有点杀鸡用牛刀了。这种情况下Replace Parameter with Explicit Methods是个不错的选择。如果你的选择条件之一是null，可以试试Introduce Null Object。</p>
<h2 id="11-Parallel-Inheritance-Hierarchies-平等继承体系"><a href="#11-Parallel-Inheritance-Hierarchies-平等继承体系" class="headerlink" title="11.Parallel Inheritance Hierarchies(平等继承体系)"></a>11.Parallel Inheritance Hierarchies(平等继承体系)</h2><p>Parallel Inheritance Hierarchies其实是Shotgun Surgery的特殊情况。在这种情况下，每当你为某个class增加一个subclass，必须也为另一个class相应增加一个subclass。如果你发现某个继承体系的class名称前缀和另一个继承体系的class名称前缀完全相同，便是闻到了这种坏味道。</p>
<p>消除这种重复性的一般策略是：让一个继承体系的实体指涉另一个继承体系的实体。如果再接再厉运用Move Method和Move Field，就可以将指涉端的继承体系消弭于无形。</p>
<h2 id="12-Lazy-Class-冗赘类"><a href="#12-Lazy-Class-冗赘类" class="headerlink" title="12.Lazy Class(冗赘类)"></a>12.Lazy Class(冗赘类)</h2><p>你所创建的每一个class，都得有人去理解它、维护它，这些工作都是要花钱的。如果一个class的所得不值其身份，它就应该消失。项目中经常会出现这样的情况：某个class原本对得起自己的身份，但重檐使它身形缩水，不再做那么多工作；或开发者事前规划了某些变化，并添加一个class来就会这些变化，但变化实际上没有发生。不论上述哪一种原因，请让这个class庄严赴义吧。如果某些subclass没有做满足够工作，试试Collapse Hierarchy[合并继承]。对于几乎没用的组件，你应该以Inline Class对付它们。</p>
<h2 id="13-Speculative-Generality-夸夸其谈未来性"><a href="#13-Speculative-Generality-夸夸其谈未来性" class="headerlink" title="13.Speculative Generality(夸夸其谈未来性)"></a>13.Speculative Generality(夸夸其谈未来性)</h2><p>这个令我们十分敏感的坏味道，命名者是Brian Foote。当有人说“噢，我想我们总有一天需要做这事”并因而企图以各式各样的挂勾和特殊情况来处理一些非必要的事情，这种坏味道就出现了。那么做的结果往往造成系统更难理解和维护。如果所有装置都会被用到，那就值得那么做；如果用不到，就不值得。用不上的装置只会挡你的路，所以，把它搬弄吧。</p>
<p>如果你的某个abstract class其实没有太大作用，请运用Collapse Hierarchy。非必要之delegation可运用Inline Class除掉。如果方法的某些参数示被用上，可对它实施Rename Method让它现实一些。</p>
<p>如果方法或class的惟一用户是test cases，这就飘出了坏味道Speculative Generality。如果你发现这样的方法或class，请把它们连同其test cases都删掉。但如果它们的用途是帮助test cases检测正当功能，当然必须刀下留人。</p>
<h2 id="14-Temporary-Field-令人迷惑的暂时字段"><a href="#14-Temporary-Field-令人迷惑的暂时字段" class="headerlink" title="14.Temporary Field(令人迷惑的暂时字段)"></a>14.Temporary Field(令人迷惑的暂时字段)</h2><p>有时你会看到这样的对象：其内某个instance 变量仅为某种特定情势而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。在变量未被使用的情况下猜测当初其设置目的，会让你发疯。</p>
<p>请使用Extract Class给这个可怜的孤独创造一个家，然后把所有和这个变量相关的代码都放进这个新家。也许你还可以使用Introduce Null Object在[变量不合法]的情况下创建一个Null对象，从而避免写出[条件式代码]。</p>
<p>如果class中有一个复杂算法，需要好几个变量，往往就可能导致坏味道Temporary Field的出现。由于实现者不希望传递一长串参数，所以他把这些参数都放进字段中。但是这些字段只在使用该算法时才有效，其它情况下只会让人迷惑。这时候你可以利用Extract Class把这些变量和其相关方法提炼到一个独立class中。提炼后的新对象将是一个method object。</p>
<h2 id="15-Message-Chains-过度耦合的消息链"><a href="#15-Message-Chains-过度耦合的消息链" class="headerlink" title="15.Message Chains(过度耦合的消息链)"></a>15.Message Chains(过度耦合的消息链)</h2><p>如果你看到用户向一个对象索求另一个对象，然后再向后者索求另一个对象，然后再索求另一个对象……这就是Message Chain。实际代码中你看到的可能是一长串getThis()或一长串临时变量。采取这种方式，意味客户将与查找过程中的航行结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。</p>
<p>这时候你应该使用Hide Delegate。你可以在Message Chain的不同位置进行这种重构手法。理论上你可以重构Message Chain上的任何一个对象，但这么做往往会把所有中介对象都变成Middle Man。通常更好的选择是：先观察Message Chain最终得到的对象是用来干什么的，看看能否以Extract Method把使用该对象的代码提炼到一个独立方法中，再运用Move Method把这个方法推入Message Chain。如果这条链上的某个对象有多位客户打算航行此航线的剩余部分，就加一个方法来做这件事。</p>
<p>有些人把任何方法链都视为坏东西，我们不这样想。呵呵，我们的总代表镇定是出了名的，起码在这件事情上是这样。</p>
<h2 id="16-Middle-Man-中间转手人"><a href="#16-Middle-Man-中间转手人" class="headerlink" title="16.Middle Man(中间转手人)"></a>16.Middle Man(中间转手人)</h2><p>对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随delegation。比如说你问主管是否有时间参加一个会议，他就把这个消息委托给他的记事簿，然后才能回答你。很好，你没必要知道这位主管到底使用传统记事簿或电子记事簿抑或秘书来记录自己的约会。</p>
<p>但是人们可能过度运用delegation。你也许会看到某个class接口有一半的方法都委托给其它class，这样就是过度运用。这里你应该使用 Remove Middle Man，直接和负责对象打交道。如果这样[不干实事]的方法只有少数几个，可以运用Inline Method把它们”inlining”，放进调用端。如果这些Middle Man还有其它行为内销可以运用Replace Delegation with Inheritance把它变成负责对象的subclass，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。</p>
<h2 id="17-Inappropriate-Intimacy-狎昵关系"><a href="#17-Inappropriate-Intimacy-狎昵关系" class="headerlink" title="17.Inappropriate Intimacy(狎昵关系)"></a>17.Inappropriate Intimacy(狎昵关系)</h2><p>有时候你会看到两个classes过于亲密，花费太多时间去探究彼此的private成分。如果这发生在两个[人]之间，我们不必做卫道之士；但对于 classes，我们希望它们严守清规。</p>
<p>就像古代恋人一样，过份狎昵的classes必须拆散。你可以采用Move Method和Move Field帮它们划清界线，从而减少狎昵行径。你也可以看看是否运用Change Bidirectional Association to Unidirectional[将双向关联改为单向]让其中一个class对另一个斩断情丝。如果两个classes实在情投意合，可以运用Extract Class把两者共同点提炼到一个安全地点，让它们坦荡地使用这个新class。或者也可以尝试运用Hide Delegate让另一个class来为它们传递相思情。</p>
<p>继承往往造成过度亲密，因为subclass对superclass的了解总是超过superclass的主观愿望。如果你觉得该让这个孩子独自生活了，请运用Replace Inheritance with Delegation让它离开继承体系。</p>
<h2 id="18-Alternative-Classes-with-Different-Interfaces-异曲同工的类"><a href="#18-Alternative-Classes-with-Different-Interfaces-异曲同工的类" class="headerlink" title="18.Alternative Classes with Different Interfaces(异曲同工的类)"></a>18.Alternative Classes with Different Interfaces(异曲同工的类)</h2><p>如果两个方法做同一件事，却有着不同的签名式，请运用Rename Method根据它们的用途重新命名。但这往往不够，请反复运用Move Method将某些行为移入classes，直到两者的协议一致为止。如果你必须重复而赘余地移入代码才能完成这些，或许可运用Extract Superclass为自己赎点罪。</p>
<h2 id="19-Incomplete-Library-Class-不完美的程序库类"><a href="#19-Incomplete-Library-Class-不完美的程序库类" class="headerlink" title="19.Incomplete Library Class(不完美的程序库类)"></a>19.Incomplete Library Class(不完美的程序库类)</h2><p>复用常被视为对象的终极目的。我们认为这实在是过度估计了。但是无可否认，许多编程技术都建立在library classes的基础上，没人敢说是不是我们都把排序算法忘得一干二净了。</p>
<p>Library classes构筑者没有未卜先知的能力，我们不能因此责怪他们。毕竟我们自己也几乎总是在系统快要构筑完成的时候才能弄清楚它的设计，所以 library构筑者的任务真的很艰巨。麻烦的是library的形式往往不够好，往往不可能让我们修改其中的classes使它完成我们希望完成的工作。这是否意味那些经过实践检验的战术如Move Method等等，如今都派不上用场了？</p>
<p>幸好我们有两个专门就会这种情况的工具。如果你只想修改library classes内的一两个方法，可以运用Introduce Foreign Method；如果想要添加一大堆额外行为，就得运用Introduce Local Extension。</p>
<h2 id="20-Data-Class-纯稚的数据类"><a href="#20-Data-Class-纯稚的数据类" class="headerlink" title="20.Data Class(纯稚的数据类)"></a>20.Data Class(纯稚的数据类)</h2><p>所谓Data Class是指：它们拥有一些字段，以及用于访问这些字段的方法，除此之外一无长物。这样的classes只是一种[不会说话的数据容器]，它们几乎一定被其它classes过份细琐地操控着。这些classes早期可能拥有public字段，果真如此你应该在别人注意到它们之前，立刻运用 Encapsulate Field将它们封装起来。如果这些classes内含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用Encapsulate Collection把它们封装起来。对于那些不该被其它classes修改的字段，请运用Remove Setting Method。</p>
<p>然后，找出这些[取值/设值]方法被其它classes运用的地点。尝试以Move Method把那些调用行为搬移到Data Class来。如果无法搬移整个方法，就运用Extract Method产生一个可被搬移的方法。不久之后你就可以运用Hide Method把这些[取值/设值]方法隐藏起来了。</p>
<p>Data Class就像小孩子。作为一个起点很好，但若要让它们像[成年]的对象那样参与整个系统的工作，它们就必须承担一定责任。</p>
<h2 id="21-Refused-Bequest-被拒绝的遗赠"><a href="#21-Refused-Bequest-被拒绝的遗赠" class="headerlink" title="21.Refused Bequest(被拒绝的遗赠)"></a>21.Refused Bequest(被拒绝的遗赠)</h2><p>Subclasses应该继承superclass的方法和数据。但如果它们不想或不需要继承，又该怎么办呢？它们得到所有礼物，却只从中挑选几样来玩！</p>
<p>按传统说法，这就意味继承体系设计错误。你需要为这个subclass新建一个兄弟，再运用Push Down Method和Push Down Field把所有用不到的方法下推给那兄弟。这样一来superclass就只持有所有subclasses共享的东西。常常你会听到这样的建议：所有 superclasses都应该是抽象的。</p>
<p>既然使用[传统说法]这个略带贬义的词，你就可以猜到，我们不建议你这么做，起码不建议你每次都这么做。我们经常利用subclassing手法来复用一些行为，并发现这可以很好地应用于日常工作。这也是一种坏味道，我们不否认，但气味通常并不强烈。所以我们说：如果Refused Bequest引起困惑和问题，请遵循传统忠告。但不必认为你每次都得那么做。十有八九这种坏味道很淡，不值得理睬。</p>
<p>如果subclass复用了superclass的行为(实现)，却又不愿意支持superclass的接口，Refused Bequest的坏味道就会变得浓烈。拒绝继承superclass的实现，这一点我们不介意；但如果拒绝继承superclass的接口，我们不以为然。不过即使你不愿意继承接口，也不要胡乱修改继承系，你应该运用Replace Inheritance with Delegation来达到目的。</p>
<h2 id="22-Comments-过多的注释"><a href="#22-Comments-过多的注释" class="headerlink" title="22.Comments(过多的注释)"></a>22.Comments(过多的注释)</h2><p>别担心，我们并不是说你不该写注释。从嗅觉上说，Comments不是一种坏味道；事实上它们还是一种香味呢。我们之所以要在这里提到Comments，因为人们常把它当作除臭剂来使用。常常会有这样的情况：你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。这种情况的发生次数之多，实在令人吃惊。</p>
<p>Comments可以带我们找到本章先前提到的各种坏味道。找到坏味道后，我们首先应该以各种重构手法把坏味道去除。完成之后我们常常会发现：注释已经变得多余了，因为代码已经清楚说明了一切。</p>
<p>如果你需要注释来解释一块代码做了什么，试试Extract Method;如果你需要注释说明某些系统的需求规格，试试Introduce Assertion。</p>
<p>如果你不知道该做什么，这才是注释的良好运用时机。除了用来记述将来的打算之外，注释还可以用来标记你并无十足把握的区域。你可以在注释里写下自己[为什么做某某事]。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>一抹安然，淡淡的美丽</title>
    <url>/2015/01/bolg-upgrade/</url>
    <content><![CDATA[<p>徜徉在冬季的阳光下，捻一朵月季的芬芳，素雅情怀，淡淡流淌。让美丽的人生拥有一份牵念，一份淡雅，一份喜悦，一份铭记，成为心灵深处一道最美的靓丽景观。</p>
<p>人生一世，草木一秋。世间万物都有这它自身的定律和轮回，就如冉冉升起的太阳，东边升西边落，在每一个晨曦盎然的清风中冉冉升起，也会在每一个夕阳余晖下，默默的降落。宛如一首浪漫的情诗，总有读不尽的韵味；又像是一杯醇香的美酒，总有品不完的回味。</p>
<span id="more"></span>
<p>宛如一季的花朵一般，开的再艳丽也会有凋谢的那一天，不为一世繁华，只因红尘邂逅的美丽。就像我们的人生一样，一路走来，坎坎坷坷，没有一帆风顺，一路上有美丽如画的风景，也走高山险阻的阻碍，只要心中的信念在，我们就会坚强不屈，任由风吹雨打，雨后的彩虹才会真正的炫彩夺目。</p>
<p>朴实，简单，清淡无华，平凡中显珍贵，平淡中见真情。无论已逝的时光，还是已老的容颜，只要心中有爱，感恩做人，那么，我们的每一天都会在阳光的沐浴下心暖向阳，腾腾日上。其实，我们生活本就如此，有悲欢就有离合，有欢笑就会有悲伤，柴米油盐，酸甜苦辣，少了一样，那道饭菜都失去了鲜泽和清香。</p>
<p>时光安然，静好馨香。我们总是在患得患失中度过，俗语说：水至清则无鱼，人至察则无徒” 现实社会里，人太精明而过分苛察，就不能容人，就没有伙伴没有朋友。因为精明者往往容不得他的过错或性格上的差异。无论亲人，还是朋友，我们都要真诚相待，宽容带人，尊重他人，才能尊己。</p>
<p>知足才有乐，才有安定幸福的生活。幸福往往在别人的眼中，我们总是羡慕别人的微笑，而忽略了自己，家家都有本难念的经，别人的微笑中也许掩藏了许多酸辛。我们不应该陶醉在别人的风景里，自己的一亩三分地才是最好的家园，那里有亲情，友情，爱情。</p>
<p>人生的斑斓都在那一抹眷书中，每一个页张中都铭记着我们过往和记忆。无论过往和记忆是苦涩还是甜蜜，都铭刻着我们诗一般的篇章，每一个足迹都在温婉的诗行中清浅沉淀。季节的凋谢，不能掩饰来年的盛开，每一朵鲜花，都会在四季轮回中嫣然开放，芬芳依旧。</p>
<p>徜徉在冬季的阳光下，捻一朵月季的芬芳，素雅情怀，淡淡流淌。让美丽的人生拥有一份牵念，一份淡雅，一份喜悦，一份铭记，成为心灵深处一道最美的靓丽景观。</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>细说 CSS margin</title>
    <url>/2016/03/css-margin/</url>
    <content><![CDATA[<p>本文着重描述关于 margin，我们日常不太容易发现的“坑”。</p>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>接触过 CSS 的人应该都知道 CSS 的盒模型：</p>
<p><img data-src="//img.leense.site/post/2016/03/201603100930-1.png"></p>
<p>由内容边缘（Content edge）包围形成的是内容盒（Content Box），类推还有内边距盒（Padding Box）、边框盒（Border Box）、外边距盒（Margin Box）。</p>
<p>其中内容盒、内边距盒、边框盒的背景由 background 属性决定，而外边距盒的背景是透明的。</p>
<span id="more"></span>

<h2 id="CSS-margin-属性"><a href="#CSS-margin-属性" class="headerlink" title="CSS margin 属性"></a>CSS margin 属性</h2><p>关于 margin 属性，有几点可能跟我们的直觉不相符：</p>
<ul>
<li>如果 margin 的值是百分比，则是相对于父元素的内容盒宽度来计算的，即使 margin-top 和 margin-bottom 也是如此。因此即使父元素的高宽不相等，子元素的 margin 元素指定了相同的百分比值，则子元素各个方向的 margin 计算值都是相等的。</li>
<li>margin-top 和 margin-bottom 值对行内非替换元素（non-replaced inline element）是无效的。因此我们可以指定 img 元素的 margin-top 和 margin-bottom，而非替换行内元素（如 i，span 等）设置 margin-top 和 margin-bottom 却不会产生效果。</li>
</ul>
<h2 id="相邻的-margin（Adjoining-margin）"><a href="#相邻的-margin（Adjoining-margin）" class="headerlink" title="相邻的 margin（Adjoining margin）"></a>相邻的 margin（Adjoining margin）</h2><p>如果两个垂直方向上的 margin，它们中间没有其他垂直 margin，但它们之间不一定相接触，我们就说这两个 margin 是垂直毗连（vertical-adjacent）的，包括以下四种情况，满足其中之一即可：</p>
<ul>
<li>父元素的 top margin 和第一个子元素的 top margin</li>
<li>父元素的 bottom margin 和最后一个子元素的 bottom margin</li>
<li>元素的 bottom margin 和与这个元素相邻的兄弟元素的 top margin</li>
<li>如果一个元素，它没有生成 BFC、没有包含正常流的子元素、min-height 是 0、height 是 0 或者 auto，则它的 top margin 和 bottom margin 也是垂直毗连的</li>
</ul>
<p>如果两个 margin 满足以下三个条件，我们就说这两个 margin 是相邻（adjoining）的：</p>
<ul>
<li>这两个 margin 是垂直毗连的，即满足上面四种情况之一</li>
<li>margin 的两个元素都是正常流的块级元素，并且在同一个 BFC 中</li>
<li>两个 margin 之间没有行盒（line box）、清除浮动后的空隙（clearance）、padding 和 border</li>
</ul>
<h2 id="margin-折叠（Collapsing-margins）"><a href="#margin-折叠（Collapsing-margins）" class="headerlink" title="margin 折叠（Collapsing margins）"></a>margin 折叠（Collapsing margins）</h2><p>margin 折叠，即相邻的 margin 有可能会被折叠成一个。</p>
<p>比如元素 #a 指定了 margin-bottom 为 10px，而它下方的元素 #b 指定了 margin-top 为 20px，如这样：</p>
<p><img data-src="//img.leense.site/post/2016/03/201603100930-2.png"></p>
<p>元素 #a 的 margin-bottom 和元素 #b 的 margin-top 在位置上重叠了，它们之间的距离是 20px，即元素 #b 的 bottom margin 长度，这就是 margin 折叠现象。关于这个现象，可以这么理解：</p>
<p>margin 定义的是它与其他盒子之间的最小间距。其中元素 #a 指定了 margin-bottom 为 10px，就表明它下方的元素 #b 与它至少要有 10px 的距离，它指定的是一个最小值，因此实际的距离可以比这个大。</p>
<p>元素 #a 下方的元素 #b 也设置了 margin-top 为 20px，如果不折叠，则他们之间就有 30px 的距离。如果折叠成了一个 20px 的距离，则对元素 #a 来说，它的 margin-bottom 要求至少要有 10px 的距离，是满足的，而对于元素 #b 来说，它的 margin-top 要求至少要有 20px 的距离，也是满足的。</p>
<p>而 margin 折叠的存在，其实是为了可以在视觉上显得更美观，也更贴近设计师的预期。</p>
<h2 id="margin-折叠规则"><a href="#margin-折叠规则" class="headerlink" title="margin 折叠规则"></a>margin 折叠规则</h2><p>并不是所有的 margin 都可以折叠，需要满足以下条件：</p>
<ul>
<li>垂直相邻的 margin 才有可能折叠，水平 margin 永远不折叠</li>
<li>根元素（即 html 元素）的 margin 永远不折叠</li>
<li>如果一个元素，它的 top margin 和 bottom margin 是相邻的，并且有清除浮动后的空隙（clearance），这个元素的 margin 可以跟兄弟元素的 margin 折叠，但是折叠后的 margin 不能跟父元素的 bottom margin 折叠。<br>需要注意的是，margin 并不是只能折叠一次，多个满足要求的 margin 都可以进行折叠形成一个折叠后的 margin（collapsed margin）。<br>并且假如这个折叠后的 margin 是由 margin A 等折叠而来的，如果有 margin X 跟 margin A 是相邻的，则我们也认为 margin X 跟这个折叠后的 margin 相邻。</li>
</ul>
<h2 id="折叠后的-margin-大小"><a href="#折叠后的-margin-大小" class="headerlink" title="折叠后的 margin 大小"></a>折叠后的 margin 大小</h2><p>当两个或者两个以上的 margin 折叠后，margin 的值计算如下：</p>
<ul>
<li>如果 margin 都是正数，则取他们当中的最大值</li>
<li>如果 margin 中有正有负，则取最大的正数加上最小的负数（如最大的 margin 是 20px，最小的 margin 是 -20px，则他们计算后的值是 0）</li>
<li>如果 margin 中都是负数，则取他们当中的最小值</li>
</ul>
<h2 id="几道思考题"><a href="#几道思考题" class="headerlink" title="几道思考题"></a>几道思考题</h2><blockquote>
<p>浮动、定位元素的 margin 不会和其他任何元素的 margin 发生重叠，包括它的子元素。</p>
</blockquote>
<p>这是因为浮动元素脱离了正常流，所以它和其他相邻元素就不处与同一个流中，自然不相邻；又因为浮动元素的内容盒会形成一个新的 BFC，所以浮动元素跟子元素不处与同一个 BFC 中，因此它们的 margin 也不能折叠。定位元素同理可得。</p>
<blockquote>
<p>inline-block 的元素不会和其他元素的 margin 发生折叠，包括它的子元素。</p>
</blockquote>
<p>因为 margin 折叠只会发生在块级元素上，因此 inline-block 元素的 margin 不会和兄弟元素折叠，又因为 inline-block 的内容盒会形成一个新的 BFC，所以 inline-block 元素本身也不会和子元素的 margin 发生折叠</p>
<h2 id="margin-折叠的几个栗子"><a href="#margin-折叠的几个栗子" class="headerlink" title="margin 折叠的几个栗子"></a>margin 折叠的几个栗子</h2><h3 id="栗子-1"><a href="#栗子-1" class="headerlink" title="栗子 1"></a>栗子 1</h3><blockquote>
<p>如果两个 margin 满足以下三个条件，我们就说这两个 margin 是相邻（adjoining）的：<br>两个 margin 之间没有行盒（line box）、清除浮动后的空隙（clearance）、padding 和边框</p>
</blockquote>
<p>针对这个条件，我们通过增加 padding 的方式来阻止 margin 的折叠：</p>
<p><img data-src="//img.leense.site/post/2016/03/201603100930-3.png"></p>
<p>如果 #container 没有下边框，则 #container 的 bottom margin 和 #inner 的 bottom margin 是相邻的，因此它们折叠了，并且 #inner 撑开了 #container 元素，所以可以看到 #container 元素的高度变成了 10px，且显示的是 #inner 的红色背景</p>
<p><img data-src="//img.leense.site/post/2016/03/201603100930-4.png"></p>
<p>当给 #container 添加一个下边框，两个 margin 之间就边框的阻隔，他们就不相邻了，因此不能折叠。所以可以看到 #container 被撑开成了 20px，其中 10px 是 #inner 的高度，还有 10px 是 #inner 的 bottom margin，并且由于 margin 是透明的，因此 #container 露出了部分蓝色的背景。</p>
<h3 id="栗子-2："><a href="#栗子-2：" class="headerlink" title="栗子 2："></a>栗子 2：</h3><blockquote>
<p>如果两个 margin 满足以下三个条件，我们就说这两个 margin 是相邻（adjoining）的：<br>margin 的两个元素都是正常流的块级元素，并且在同一个 BFC 中</p>
</blockquote>
<p>我们通过创建新的 BFC 来阻止 margin 的折叠：</p>
<p><img data-src="//img.leense.site/post/2016/03/201603100930-5.png"><br><img data-src="//img.leense.site/post/2016/03/201603100930-6.png"></p>
<p>如上图 #container 元素和 #inner 元素同属于一个 BFC 中，#container 的 top margin 和 #inner 的 top margin 折叠，bottom margin 同理。<br>但如果让 #container 跟 #innter 处在不同的 BFC 中，则 top margin 和 bottom margin 都不会折叠，如：</p>
<p><img data-src="//img.leense.site/post/2016/03/201603100930-7.png"></p>
<p>给 #container 元素增加一个 overflow: hidden 属性，让它的内容盒生成一个独立的 BFC，而 #inner 处于这个独立的 BFC 中，因此 #container 和 #inner 就处于两个不同的 BFC 中了，所以他们的 margin 不能折叠。</p>
<h3 id="栗子-3："><a href="#栗子-3：" class="headerlink" title="栗子 3："></a>栗子 3：</h3><blockquote>
<p>如果一个元素，它本身的 top margin 和 bottom margin 是相邻的，并且有清除浮动后的空隙（clearance），这个元素的 margin 可以跟兄弟元素的 margin 折叠，但是折叠后的 margin 不能跟父元素的 bottom margin 折叠。</p>
</blockquote>
<p><img data-src="//img.leense.site/post/2016/03/201603100930-8.png"></p>
<p>给父元素 #container 设置了一个灰色背景，并且没有设置高度，因此高度会随着内容而扩展，margin 设置为 50px。<br>其中有一个红色的浮动元素 #floated，高宽都设置为 40px。<br>给 #cleared 设置了 15px 的 margin，并且元素的高度、padding、margin 都为 0，因此 #cleared 元素的 top margin 和 bottom margin 是相邻的。这个元素的位置如下图所示：</p>
<p><img data-src="//img.leense.site/post/2016/03/201603100930-9.png"></p>
<p>因为 #cleared 元素清除了左浮动，所以 #cleared 元素下移。<br>而 #cleared 元素和 #slibling 元素的 margin 折叠了，因此可以看到他们的位置是重叠的。</p>
<p><img data-src="//img.leense.site/post/2016/03/201603100930-10.png"></p>
<p>由于这条规则的存在，导致他们折叠后的 margin 不能跟 #container 的 bottom margin 进行折叠，因此 #container 的高度被撑开。</p>
<p>如果没有这条规则，他们还应该跟 #container 的 bottom margin 进行折叠，如：</p>
<p><img data-src="//img.leense.site/post/2016/03/201603100930-11.png"></p>
<p>以上这张图，在去掉了 #cleared 元素的 clear 属性之后，就不满足这条规则了，所以可以看到 #container 的高度就只有 40px，即红色的浮动元素的高度，而 #cleared 元素、#sibling 元素、#container 元素的 margin 都折叠成了一个。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章的绝大多数内容都是从官方规范翻译而来，同时也参考也网上一些写的比较好的文章而写的一个介绍性文章，其中有部分内容并没有展开，如 BFC、clearance 等，因为这部分内容不是三言两语就可以解释清楚，我本人也需要进行更深入的学习理解，所以请读者自行查阅相关文章</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.w3.org/TR/CSS2/box.html">https://www.w3.org/TR/CSS2/box.html</a></p>
<p><a href="https://www.w3.org/TR/CSS2/visuren.html">https://www.w3.org/TR/CSS2/visuren.html</a></p>
<p><a href="http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html">http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html</a></p>
<p><a href="https://segmentfault.com/a/1190000003099116">https://segmentfault.com/a/1190000003099116</a></p>
<p><a href="https://segmentfault.com/a/1190000003096320">https://segmentfault.com/a/1190000003096320</a></p>
<p><a href="http://melonh.com/css/2015/04/28/understand-margin-collapse.html">http://melonh.com/css/2015/04/28/understand-margin-collapse.html</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web</tag>
        <tag>margin</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 开发的45个经典技巧</title>
    <url>/2016/04/javascript-45-tips/</url>
    <content><![CDATA[<p>JavaScript是一个绝冠全球的编程语言，可用于Web开发、移动应用开发（PhoneGap、Appcelerator）、服务器端开发（Node.js和Wakanda）等等。JavaScript还是很多新手踏入编程世界的第一个语言。既可以用来显示浏览器中的简单提示框，也可以通过nodebot或nodruino来控制机器人。能够编写结构清晰、性能高效的JavaScript代码的开发人员，现如今已成了招聘市场最受追捧的人。</p>
<span id="more"></span>

<p>在这篇文章里，我将分享一些JavaScript的技巧、秘诀和最佳实践，除了少数几个外，不管是浏览器的JavaScript引擎，还是服务器端JavaScript解释器，均适用。</p>
<h2 id="1、首次为变量赋值时务必使用var关键字"><a href="#1、首次为变量赋值时务必使用var关键字" class="headerlink" title="1、首次为变量赋值时务必使用var关键字"></a>1、首次为变量赋值时务必使用<code>var</code>关键字</h2><p>变量没有声明而直接赋值得话，默认会作为一个新的全局变量，要尽量避免使用全局变量。</p>
<h2 id="2、使用-取代"><a href="#2、使用-取代" class="headerlink" title="2、使用===取代=="></a>2、使用<code>===</code>取代<code>==</code></h2><p><code>==</code>和<code>!=</code>操作符会在需要的情况下自动转换数据类型。但<code>===</code>和<code>!==</code>不会，它们会同时比较值和数据类型，这也使得它们要比<code>==</code>和<code>!=</code>快。</p>
<pre><code>[10] === 10    // is false
[10]  == 10    // is true
&#39;10&#39; == 10     // is true
&#39;10&#39; === 10    // is false
 []   == 0     // is true
 [] ===  0     // is false
 &#39;&#39; == false   // is true but true == &quot;a&quot; is false
 &#39;&#39; === false  // is false
</code></pre>
<h2 id="3、underfined、null、0、false、NaN、空字符串的逻辑结果均为false"><a href="#3、underfined、null、0、false、NaN、空字符串的逻辑结果均为false" class="headerlink" title="3、underfined、null、0、false、NaN、空字符串的逻辑结果均为false"></a>3、<code>underfined</code>、<code>null</code>、0、false、NaN、空字符串的逻辑结果均为false</h2><h2 id="4、行尾使用分号"><a href="#4、行尾使用分号" class="headerlink" title="4、行尾使用分号"></a>4、行尾使用分号</h2><p>实践中最好还是使用分号，忘了写也没事，大部分情况下JavaScript解释器都会自动添加。对于为何要使用分号，可参考文章<a href="http://davidwalsh.name/javascript-semicolons">JavaScript中关于分号的真相</a>。</p>
<h2 id="5、使用对象构造器"><a href="#5、使用对象构造器" class="headerlink" title="5、使用对象构造器"></a>5、使用对象构造器</h2><pre><code>function Person(firstName, lastName)&#123;
    this.firstName =  firstName;
    this.lastName = lastName;
&#125;
var Saad = new Person(&quot;Saad&quot;, &quot;Mousliki&quot;);
</code></pre>
<h2 id="6、小心使用typeof、instanceof和contructor"><a href="#6、小心使用typeof、instanceof和contructor" class="headerlink" title="6、小心使用typeof、instanceof和contructor"></a>6、小心使用<code>typeof</code>、<code>instanceof</code>和<code>contructor</code></h2><ul>
<li>  <code>typeof</code>：JavaScript一元操作符，用于以字符串的形式返回变量的原始类型，注意，<code>typeof null</code>也会返回<code>object</code>，大多数的对象类型（数组Array、时间Date等）也会返回<code>object</code></li>
<li>  <code>contructor</code>：内部原型属性，可以通过代码重写</li>
<li>  <code>instanceof</code>：JavaScript操作符，会在原型链中的构造器中搜索，找到则返回<code>true</code>，否则返回<code>false</code><pre><code>var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
typeof arr;   // 返回 &quot;object&quot;
arr instanceof Array // true
arr.constructor();  //[]
</code></pre>
</li>
</ul>
<h2 id="7、使用自调用函数"><a href="#7、使用自调用函数" class="headerlink" title="7、使用自调用函数"></a>7、使用自调用函数</h2><p>函数在创建之后直接自动执行，通常称之为自调用匿名函数（Self-Invoked Anonymous Function）或直接调用函数表达式（Immediately Invoked Function Expression ）。格式如下：</p>
<pre><code>(function()&#123;
    // 置于此处的代码将自动执行
&#125;)();  
(function(a,b)&#123;
    var result = a+b;
    return result;
&#125;)(10,20)
</code></pre>
<h2 id="8、从数组中随机获取成员"><a href="#8、从数组中随机获取成员" class="headerlink" title="8、从数组中随机获取成员"></a>8、从数组中随机获取成员</h2><pre><code>var items = [12, 548 , &#39;a&#39; , 2 , 5478 , &#39;foo&#39; , 8852, , &#39;Doe&#39; , 2145 , 119];
var  randomItem = items[Math.floor(Math.random() * items.length)];
</code></pre>
<h2 id="9、获取指定范围内的随机数"><a href="#9、获取指定范围内的随机数" class="headerlink" title="9、获取指定范围内的随机数"></a>9、获取指定范围内的随机数</h2><p>这个功能在生成测试用的假数据时特别有数，比如介与指定范围内的工资数。</p>
<pre><code>var x = Math.floor(Math.random() * (max - min + 1)) + min;
</code></pre>
<h2 id="10、生成从0到指定值的数字数组"><a href="#10、生成从0到指定值的数字数组" class="headerlink" title="10、生成从0到指定值的数字数组"></a>10、生成从0到指定值的数字数组</h2><pre><code>var numbersArray = [] , max = 100;
for( var i=1; numbersArray.push(i++) &amp;lt; max;);  // numbers = [1,2,3 ... 100]
</code></pre>
<h2 id="11、生成随机的字母数字字符串"><a href="#11、生成随机的字母数字字符串" class="headerlink" title="11、生成随机的字母数字字符串"></a>11、生成随机的字母数字字符串</h2><pre><code>function generateRandomAlphaNum(len) &#123;
    var rdmString = &quot;&quot;;
    for( ; rdmString.length &amp;lt; len; rdmString  += Math.random().toString(36).substr(2));
    return  rdmString.substr(0, len);
&#125;
</code></pre>
<h2 id="12、打乱数字数组的顺序"><a href="#12、打乱数字数组的顺序" class="headerlink" title="12、打乱数字数组的顺序"></a>12、打乱数字数组的顺序</h2><pre><code>var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];
numbers = numbers.sort(function()&#123; return Math.random() - 0.5&#125;);
/* numbers 数组将类似于 [120, 5, 228, -215, 400, 458, -85411, 122205]  */
</code></pre>
<p>这里使用了JavaScript内置的数组排序函数，更好的办法是用专门的代码来实现（如Fisher-Yates算法），可以参见StackOverFlow上的<a href="http://stackoverflow.com/questions/962802/is-it-correct-to-use-javascript-array-sort-method-for-shuffling/962890#962890">这个讨论</a>。</p>
<h2 id="13、字符串去空格"><a href="#13、字符串去空格" class="headerlink" title="13、字符串去空格"></a>13、字符串去空格</h2><p>Java、C#和PHP等语言都实现了专门的字符串去空格函数，但JavaScript中是没有的，可以通过下面的代码来为<code>String</code>对象函数一个<code>trim</code>函数：</p>
<pre><code>String.prototype.trim = function()&#123;return this.replace(/^\s+|\s+$/g, &quot;&quot;);&#125;;
</code></pre>
<p>新的JavaScript引擎已经有了<code>trim()</code>的原生实现。</p>
<h2 id="14、数组之间追加"><a href="#14、数组之间追加" class="headerlink" title="14、数组之间追加"></a>14、数组之间追加</h2><pre><code>var array1 = [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458];
var array2 = [&quot;Doe&quot; , 555 , 100];
Array.prototype.push.apply(array1, array2);
/* array1 值为  [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] */
</code></pre>
<h2 id="15、对象转换为数组"><a href="#15、对象转换为数组" class="headerlink" title="15、对象转换为数组"></a>15、对象转换为数组</h2><pre><code>var argArray = Array.prototype.slice.call(arguments);
</code></pre>
<h2 id="16、验证是否是数字"><a href="#16、验证是否是数字" class="headerlink" title="16、验证是否是数字"></a>16、验证是否是数字</h2><pre><code>function isNumber(n)&#123;
    return !isNaN(parseFloat(n)) &amp;amp;&amp;amp; isFinite(n);
&#125;
</code></pre>
<h2 id="17、验证是否是数组"><a href="#17、验证是否是数组" class="headerlink" title="17、验证是否是数组"></a>17、验证是否是数组</h2><pre><code>function isArray(obj)&#123;
    return Object.prototype.toString.call(obj) === &#39;[object Array]&#39; ;
&#125;
</code></pre>
<p>但如果<code>toString()</code>方法被重写过得话，就行不通了。也可以使用下面的方法：</p>
<pre><code>Array.isArray(obj); // its a new Array method
</code></pre>
<p>如果在浏览器中没有使用frame，还可以用<code>instanceof</code>，但如果上下文太复杂，也有可能出错。</p>
<pre><code>var myFrame = document.createElement(&#39;iframe&#39;);
document.body.appendChild(myFrame);
var myArray = window.frames[window.frames.length-1].Array;
var arr = new myArray(a,b,10); // [a,b,10]  
// myArray 的构造器已经丢失，instanceof 的结果将不正常
// 构造器是不能跨 frame 共享的
arr instanceof Array; // false
</code></pre>
<h2 id="18、获取数组中的最大值和最小值"><a href="#18、获取数组中的最大值和最小值" class="headerlink" title="18、获取数组中的最大值和最小值"></a>18、获取数组中的最大值和最小值</h2><pre><code>var  numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];
var maxInNumbers = Math.max.apply(Math, numbers);
var minInNumbers = Math.min.apply(Math, numbers);
</code></pre>
<h2 id="19、清空数组"><a href="#19、清空数组" class="headerlink" title="19、清空数组"></a>19、清空数组</h2><pre><code>var myArray = [12 , 222 , 1000 ];  
myArray.length = 0; // myArray will be equal to [].
</code></pre>
<h2 id="20、不要直接从数组中delete或remove元素"><a href="#20、不要直接从数组中delete或remove元素" class="headerlink" title="20、不要直接从数组中delete或remove元素"></a>20、不要直接从数组中<code>delete</code>或<code>remove</code>元素</h2><p>如果对数组元素直接使用<code>delete</code>，其实并没有删除，只是将元素置为了<code>undefined</code>。数组元素删除应使用<code>splice</code>。</p>
<p>切忌：</p>
<pre><code>var items = [12, 548 ,&#39;a&#39; , 2 , 5478 , &#39;foo&#39; , 8852, , &#39;Doe&#39; ,2154 , 119 ];
items.length; // return 11
delete items[3]; // return true
items.length; // return 11
/* items 结果为 [12, 548, &quot;a&quot;, undefined × 1, 5478, &quot;foo&quot;, 8852, undefined × 1, &quot;Doe&quot;, 2154, 119] */
</code></pre>
<p>而应：</p>
<pre><code>var items = [12, 548 ,&#39;a&#39; , 2 , 5478 , &#39;foo&#39; , 8852, , &#39;Doe&#39; ,2154 , 119 ];
items.length; // return 11
items.splice(3,1) ;
items.length; // return 10
/* items 结果为 [12, 548, &quot;a&quot;, 5478, &quot;foo&quot;, 8852, undefined × 1, &quot;Doe&quot;, 2154, 119]
</code></pre>
<p>删除对象的属性时可以使用<code>delete</code>。</p>
<h2 id="21、使用length属性截断数组"><a href="#21、使用length属性截断数组" class="headerlink" title="21、使用length属性截断数组"></a>21、使用<code>length</code>属性截断数组</h2><p>前面的例子中用<code>length</code>属性清空数组，同样还可用它来截断数组：</p>
<pre><code>var myArray = [12 , 222 , 1000 , 124 , 98 , 10 ];  
myArray.length = 4; // myArray will be equal to [12 , 222 , 1000 , 124].
</code></pre>
<p>与此同时，如果把<code>length</code>属性变大，数组的长度值变会增加，会使用<code>undefined</code>来作为新的元素填充。<code>length</code>是一个可写的属性。</p>
<pre><code>myArray.length = 10; // the new array length is 10
myArray[myArray.length - 1] ; // undefined
</code></pre>
<h2 id="22、在条件中使用逻辑与或"><a href="#22、在条件中使用逻辑与或" class="headerlink" title="22、在条件中使用逻辑与或"></a>22、在条件中使用逻辑与或</h2><pre><code>var foo = 10;  
foo == 10 &amp;amp;&amp;amp; doSomething(); // is the same thing as if (foo == 10) doSomething();
foo == 5 || doSomething(); // is the same thing as if (foo != 5) doSomething();
</code></pre>
<p>逻辑或还可用来设置默认值，比如函数参数的默认值。</p>
<pre><code>function doSomething(arg1)&#123;
    arg1 = arg1 || 10; // arg1 will have 10 as a default value if it’s not already set
&#125;
</code></pre>
<h2 id="23、使得map-函数方法对数据循环"><a href="#23、使得map-函数方法对数据循环" class="headerlink" title="23、使得map()函数方法对数据循环"></a>23、使得<code>map()</code>函数方法对数据循环</h2><pre><code>var squares = [1,2,3,4].map(function (val) &#123;  
    return val * val;  
&#125;);
// squares will be equal to [1, 4, 9, 16]
</code></pre>
<h2 id="24、保留指定小数位数"><a href="#24、保留指定小数位数" class="headerlink" title="24、保留指定小数位数"></a>24、保留指定小数位数</h2><pre><code>var num =2.443242342;
num = num.toFixed(4);  // num will be equal to 2.4432
</code></pre>
<p>注意，<code>toFixec()</code>返回的是字符串，不是数字。</p>
<h2 id="25、浮点计算的问题"><a href="#25、浮点计算的问题" class="headerlink" title="25、浮点计算的问题"></a>25、浮点计算的问题</h2><pre><code>0.1 + 0.2 === 0.3 // is false
9007199254740992 + 1 // is equal to 9007199254740992
9007199254740992 + 2 // is equal to 9007199254740994
</code></pre>
<p>为什么呢？因为0.1+0.2等于0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，在内部都是64位浮点小数表示，具体可以参见<a href="http://www.2ality.com/2012/04/number-encoding.html">JavaScript中的数字是如何编码的</a>.</p>
<p>可以通过使用<code>toFixed()</code>和<code>toPrecision()</code>来解决这个问题。</p>
<h2 id="26、通过for-in循环检查对象的属性"><a href="#26、通过for-in循环检查对象的属性" class="headerlink" title="26、通过for-in循环检查对象的属性"></a>26、通过for-in循环检查对象的属性</h2><p>下面这样的用法，可以防止迭代的时候进入到对象的原型属性中。</p>
<pre><code>for (var name in object) &#123;  
    if (object.hasOwnProperty(name)) &#123;
        // do something with name
    &#125;  
&#125;
</code></pre>
<h2 id="27、逗号操作符"><a href="#27、逗号操作符" class="headerlink" title="27、逗号操作符"></a>27、逗号操作符</h2><pre><code>var a = 0;
var b = ( a++, 99 );
console.log(a);  // a will be equal to 1
console.log(b);  // b is equal to 99
</code></pre>
<h2 id="28、临时存储用于计算和查询的变量"><a href="#28、临时存储用于计算和查询的变量" class="headerlink" title="28、临时存储用于计算和查询的变量"></a>28、临时存储用于计算和查询的变量</h2><p>在jQuery选择器中，可以临时存储整个DOM元素。</p>
<pre><code>var navright = document.querySelector(&#39;#right&#39;);
var navleft = document.querySelector(&#39;#left&#39;);
var navup = document.querySelector(&#39;#up&#39;);
var navdown = document.querySelector(&#39;#down&#39;);
</code></pre>
<h2 id="29、提前检查传入isFinite-的参数"><a href="#29、提前检查传入isFinite-的参数" class="headerlink" title="29、提前检查传入isFinite()的参数"></a>29、提前检查传入<code>isFinite()</code>的参数</h2><pre><code>isFinite(0/0) ; // false
isFinite(&quot;foo&quot;); // false
isFinite(&quot;10&quot;); // true
isFinite(10);   // true
isFinite(undefined);  // false
isFinite();   // false
isFinite(null);  // true，这点当特别注意
</code></pre>
<h2 id="30、避免在数组中使用负数做索引"><a href="#30、避免在数组中使用负数做索引" class="headerlink" title="30、避免在数组中使用负数做索引"></a>30、避免在数组中使用负数做索引</h2><pre><code>var numbersArray = [1,2,3,4,5];
 var from = numbersArray.indexOf(&quot;foo&quot;) ; // from is equal to -1
 numbersArray.splice(from,2); // will return [5]
</code></pre>
<p>注意传给<code>splice</code>的索引参数不要是负数，当是负数时，会从数组结尾处删除元素。</p>
<h2 id="31、用JSON来序列化与反序列化"><a href="#31、用JSON来序列化与反序列化" class="headerlink" title="31、用JSON来序列化与反序列化"></a>31、用JSON来序列化与反序列化</h2><pre><code>var person = &#123;name :&#39;Saad&#39;, age : 26, department : &#123;ID : 15, name : &quot;R&amp;amp;D&quot;&#125; &#125;;
var stringFromPerson = JSON.stringify(person);
/* stringFromPerson 结果为 &quot;&#123;&quot;name&quot;:&quot;Saad&quot;,&quot;age&quot;:26,&quot;department&quot;:&#123;&quot;ID&quot;:15,&quot;name&quot;:&quot;R&amp;amp;D&quot;&#125;&#125;&quot;   */
var personFromString = JSON.parse(stringFromPerson);
/* personFromString 的值与 person 对象相同  */
</code></pre>
<h2 id="32、不要使用eval-或者函数构造器"><a href="#32、不要使用eval-或者函数构造器" class="headerlink" title="32、不要使用eval()或者函数构造器"></a>32、不要使用<code>eval()</code>或者函数构造器</h2><p><code>eval()</code>和函数构造器（<code>Function</code> consturctor）的开销较大，每次调用，JavaScript引擎都要将源代码转换为可执行的代码。</p>
<pre><code>var func1 = new Function(functionCode);
var func2 = eval(functionCode);
</code></pre>
<h2 id="32、不要使用eval-或者函数构造器-1"><a href="#32、不要使用eval-或者函数构造器-1" class="headerlink" title="32、不要使用eval()或者函数构造器"></a>32、不要使用<code>eval()</code>或者函数构造器</h2><p><code>eval()</code>和函数构造器（<code>Function</code> consturctor）的开销较大，每次调用，JavaScript引擎都要将源代码转换为可执行的代码。</p>
<pre><code>var func1 = new Function(functionCode);
var func2 = eval(functionCode);
</code></pre>
<h2 id="33、避免使用with"><a href="#33、避免使用with" class="headerlink" title="33、避免使用with()"></a>33、避免使用<code>with()</code></h2><p>使用<code>with()</code>可以把变量加入到全局作用域中，因此，如果有其它的同名变量，一来容易混淆，二来值也会被覆盖。</p>
<h2 id="34、不要对数组使用for-in"><a href="#34、不要对数组使用for-in" class="headerlink" title="34、不要对数组使用for-in"></a>34、不要对数组使用for-in</h2><p>避免：</p>
<pre><code>var sum = 0;  
for (var i in arrayNumbers) &#123;  
    sum += arrayNumbers[i];  
&#125;
</code></pre>
<p>而是：</p>
<pre><code>var sum = 0;  
for (var i = 0, len = arrayNumbers.length; i &amp;lt; len; i++) &#123;  
    sum += arrayNumbers[i];  
&#125;
</code></pre>
<p>另外一个好处是，<code>i</code>和<code>len</code>两个变量是在<code>for</code>循环的第一个声明中，二者只会初始化一次，这要比下面这种写法快：</p>
<pre><code>for (var i = 0; i &amp;lt; arrayNumbers.length; i++)
</code></pre>
<h2 id="35、传给setInterval-和setTimeout-时使用函数而不是字符串"><a href="#35、传给setInterval-和setTimeout-时使用函数而不是字符串" class="headerlink" title="35、传给setInterval()和setTimeout()时使用函数而不是字符串"></a>35、传给<code>setInterval()</code>和<code>setTimeout()</code>时使用函数而不是字符串</h2><p>如果传给<code>setTimeout()</code>和<code>setInterval()</code>一个字符串，他们将会用类似于<code>eval</code>方式进行转换，这肯定会要慢些，因此不要使用：</p>
<pre><code>setInterval(&#39;doSomethingPeriodically()&#39;, 1000);  
setTimeout(&#39;doSomethingAfterFiveSeconds()&#39;, 5000);
</code></pre>
<p>而是用：</p>
<pre><code>setInterval(doSomethingPeriodically, 1000);  
setTimeout(doSomethingAfterFiveSeconds, 5000);
</code></pre>
<h2 id="36、使用switch-case代替一大叠的if-else"><a href="#36、使用switch-case代替一大叠的if-else" class="headerlink" title="36、使用switch/case代替一大叠的if/else"></a>36、使用<code>switch/case</code>代替一大叠的<code>if/else</code></h2><p>当判断有超过两个分支的时候使用<code>switch/case</code>要更快一些，而且也更优雅，更利于代码的组织，当然，如果有超过10个分支，就不要使用<code>switch/case</code>了。</p>
<h2 id="37、在switch-case中使用数字区间"><a href="#37、在switch-case中使用数字区间" class="headerlink" title="37、在switch/case中使用数字区间"></a>37、在<code>switch/case</code>中使用数字区间</h2><p>其实，<code>switch/case</code>中的<code>case</code>条件，还可以这样写：</p>
<pre><code>function getCategory(age) &#123;  
    var category = &quot;&quot;;  
    switch (true) &#123;  
        case isNaN(age):  
            category = &quot;not an age&quot;;  
            break;  
        case (age &amp;gt;= 50):  
            category = &quot;Old&quot;;  
            break;  
        case (age &amp;lt;= 20):  
            category = &quot;Baby&quot;;  
            break;  
        default:  
            category = &quot;Young&quot;;  
            break;  
    &#125;;  
    return category;  
&#125;  
getCategory(5);  // 将返回 &quot;Baby&quot;
</code></pre>
<h2 id="38、使用对象作为对象的原型"><a href="#38、使用对象作为对象的原型" class="headerlink" title="38、使用对象作为对象的原型"></a>38、使用对象作为对象的原型</h2><p>下面这样，便可以给定对象作为参数，来创建以此为原型的新对象：</p>
<pre><code>function clone(object) &#123;  
    function OneShotConstructor()&#123;&#125;;
    OneShotConstructor.prototype = object;  
    return new OneShotConstructor();
&#125;
clone(Array).prototype ;  // []
</code></pre>
<h2 id="39、HTML字段转换函数"><a href="#39、HTML字段转换函数" class="headerlink" title="39、HTML字段转换函数"></a>39、HTML字段转换函数</h2><pre><code>function escapeHTML(text) &#123;  
    var replacements= &#123;&quot;&amp;lt;&quot;: &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;: &quot;&amp;gt;&quot;,&quot;&amp;amp;&quot;: &quot;&amp;amp;&quot;, &quot;\&quot;&quot;: &quot;&quot;&quot;&#125;;                      
    return text.replace(/[&amp;lt;&amp;gt;&amp;amp;&quot;]/g, function(character) &#123;  
        return replacements[character];  
    &#125;);
&#125;
</code></pre>
<h2 id="40、不要在循环内部使用try-catch-finally"><a href="#40、不要在循环内部使用try-catch-finally" class="headerlink" title="40、不要在循环内部使用try-catch-finally"></a>40、不要在循环内部使用try-catch-finally</h2><p>try-catch-finally中catch部分在执行时会将异常赋给一个变量，这个变量会被构建成一个运行时作用域内的新的变量。</p>
<p>切忌：</p>
<pre><code>var object = [&#39;foo&#39;, &#39;bar&#39;], i;  
for (i = 0, len = object.length; i &amp;lt;len; i++) &#123;  
    try &#123;  
        // do something that throws an exception
    &#125;  
    catch (e) &#123;   
        // handle exception  
    &#125;
&#125;
</code></pre>
<p>而应该：</p>
<pre><code>var object = [&#39;foo&#39;, &#39;bar&#39;], i;  
try &#123;
    for (i = 0, len = object.length; i &amp;lt;len; i++) &#123;  
        // do something that throws an exception
    &#125;
&#125;
catch (e) &#123;   
    // handle exception  
&#125;
</code></pre>
<h2 id="41、使用XMLHttpRequests时注意设置超时"><a href="#41、使用XMLHttpRequests时注意设置超时" class="headerlink" title="41、使用XMLHttpRequests时注意设置超时"></a>41、使用XMLHttpRequests时注意设置超时</h2><p>XMLHttpRequests在执行时，当长时间没有响应（如出现网络问题等）时，应该中止掉连接，可以通过<code>setTimeout()</code>来完成这个工作：</p>
<pre><code>var xhr = new XMLHttpRequest ();
xhr.onreadystatechange = function () &#123;  
    if (this.readyState == 4) &#123;  
        clearTimeout(timeout);  
        // do something with response data
    &#125;  
&#125;  
var timeout = setTimeout( function () &#123;  
    xhr.abort(); // call error callback  
&#125;, 60*1000 /* timeout after a minute */ );
xhr.open(&#39;GET&#39;, url, true);  
xhr.send();
</code></pre>
<p>同时需要注意的是，不要同时发起多个XMLHttpRequests请求。</p>
<h2 id="42、处理WebSocket的超时"><a href="#42、处理WebSocket的超时" class="headerlink" title="42、处理WebSocket的超时"></a>42、处理WebSocket的超时</h2><p>通常情况下，WebSocket连接创建后，如果30秒内没有任何活动，服务器端会对连接进行超时处理，防火墙也可以对单位周期没有活动的连接进行超时处理。</p>
<p>为了防止这种情况的发生，可以每隔一定时间，往服务器发送一条空的消息。可以通过下面这两个函数来实现这个需求，一个用于使连接保持活动状态，另一个专门用于结束这个状态。</p>
<pre><code>var timerID = 0;
function keepAlive() &#123;
    var timeout = 15000;  
    if (webSocket.readyState == webSocket.OPEN) &#123;  
        webSocket.send(&#39;&#39;);  
    &#125;  
    timerId = setTimeout(keepAlive, timeout);  
&#125;  
function cancelKeepAlive() &#123;  
    if (timerId) &#123;  
        cancelTimeout(timerId);  
    &#125;  
&#125;
</code></pre>
<p><code>keepAlive()</code>函数可以放在WebSocket连接的<code>onOpen()</code>方法的最后面，<code>cancelKeepAlive()</code>放在<code>onClose()</code>方法的最末尾。</p>
<h2 id="43、时间注意原始操作符比函数调用快，使用VanillaJS"><a href="#43、时间注意原始操作符比函数调用快，使用VanillaJS" class="headerlink" title="43、时间注意原始操作符比函数调用快，使用VanillaJS"></a>43、时间注意原始操作符比函数调用快，使用VanillaJS</h2><p>比如，一般不要这样：</p>
<pre><code>var min = Math.min(a,b);
A.push(v);
</code></pre>
<p>可以这样来代替：</p>
<pre><code>var min = a &amp;lt; b ? a : b;
A[A.length] = v;
</code></pre>
<h2 id="44、开发时注意代码结构，上线前检查并压缩JavaScript代码"><a href="#44、开发时注意代码结构，上线前检查并压缩JavaScript代码" class="headerlink" title="44、开发时注意代码结构，上线前检查并压缩JavaScript代码"></a>44、开发时注意代码结构，上线前检查并压缩JavaScript代码</h2><p>别忘了在写代码时使用一个代码美化工具。使用JSLint(一个语法检查工具)并且在上线前压缩代码（比如使用JSMin）。注：现在代码压缩一般推荐 UglifyJS (<a href="https://github.com/mishoo/UglifyJS2">https://github.com/mishoo/UglifyJS2</a>)</p>
<h2 id="45、JavaScript博大精深，这里有些不错的学习资源"><a href="#45、JavaScript博大精深，这里有些不错的学习资源" class="headerlink" title="45、JavaScript博大精深，这里有些不错的学习资源"></a>45、JavaScript博大精深，这里有些不错的学习资源</h2><ul>
<li>  Code Academy资源：<a href="http://www.codecademy.com/tracks/javascript">http://www.codecademy.com/tracks/javascript</a></li>
<li>  Marjin Haverbekex编写的_Eloquent JavaScript_：<a href="http://eloquentjavascript.net/">http://eloquentjavascript.net/</a></li>
<li>  John Resig编写的_Advanced JavaScript_：<a href="http://ejohn.org/apps/learn/">http://ejohn.org/apps/learn/</a></li>
</ul>
<p>原文连接: <a href="http://www.codeceo.com/article/javascript-45-tips.html">http://www.codeceo.com/article/javascript-45-tips.html</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JQuery</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>［转］再谈如何学习 Linux，一线 Linux 专家学习经验谈</title>
    <url>/2016/03/learn-linux/</url>
    <content><![CDATA[<p>记得最早接触 linux 是在 2000 年，那个时候，还在上大学，一个同学从荷兰回来，带回来了一个 Linux 的拷贝版，记得版本还是 Redhat6.2。曾经为安装一个系统让我们忘记疲劳，挑灯夜战，不亦乐乎。那时 Linux 的学习资料还很少，能够学习的书籍也不多，网上 Linux 技术社区也很少，就凭着 Redhat6.2 自带的几页使用说明开始了学习 linux 的生涯。</p>
<p>转眼间，10 几年过去了，我也与 Linux 相伴了 10 多年，10 年间，随着虚拟化、云计算时代的来临，Linux 迅猛发展，在服务器领域已经占据半壁江山，而基于 Linux 的运维也面临新的挑战：面对越来越复杂的业务，面对越来越多样化的用户需求，不断扩展的应用需要越来越合理的模式来保障 Linux 灵活便捷、安全稳定地持续提供服务，这种模式中的保障因素就是 Linux 运维。从初期的几台服务器发展到庞大的云计算数据中心，单靠人工已经无法满足在技术、业务、管理等方面的要求，那么标准化、自动化、稳定性、可靠性等业务需求越来越被人们所重视。因此，对 Linux 的高性能、可靠性提出了更高的要求。</p>
<p>2009 年我完成了基于 Linux 操作系统的作品《循序渐进 Linux——基础知识、服务器搭建、系统管理、性能调优、集群应用》，此书出版后，得到了很多同行的认可，但是，此书出版已近 6 年，书中介绍的部分知识点和操作系统版本已经变得陈旧，已不能满足 Linux 以及开源技术迅速发展的需求，抱着对读者和本书负责的态度，我决定修订此书，因此也就有了这本《循序渐进 Linux（第 2 版）——基础知识、服务器搭建、系统管理、性能调优、虚拟化与集群应用》这本新书。</p>
<span id="more"></span>

<p>今天不讲深入的东西，只想将自己多年来学习 Linux 的心得与感受与大家一起分享下，希望能给爱好 Linux 的朋友们或者 Linux 的同行们一点意见和建议，一点经验心得与大家共勉！</p>
<p>一、Linux 在各领域发展的现状与趋势</p>
<p>很多新手都有一个很疑惑的问题：“Linux 我听过，但是学习 linux 系统，能在上面干什么呢，或者说 linux 系统具体能做什么”，带着这个疑问，在本书的开篇，我们先来了解下 Linux 与开源软件的关系以及 Linux 的应用领域和未来的发展趋势。</p>
<p>1.1 Linux 与开源软件</p>
<p>Linux 是一种自由和开放源代码的类 UNIX 操作系统，该操作系统的内核由林纳斯托瓦兹在 1991 年首次发布，之后，在加上用户空间的应用程序之后，就成为了 Linux 操作系统。严格来讲，Linux 只是操作系统内核本身，但通常采用“Linux 内核”来表达该意思。而 Linux 则常用来指基于 Linux 内核的完整操作系统，它包括 GUI 组件和许多其他实用工具。</p>
<p>GNU 通用公共许可协议（GNU General Public License，简称 GNU GPL 或 GPL），是一个广泛被使用的自由软件许可协议条款，最初由理查德斯托曼为 GNU 计划而撰写，GPL 给予了计算机程序自由软件的定义， 任何基于 GPL 软件开发衍生的产品在发布时必须采用 GPL 许可证方式，且必须公开源代码，</p>
<p>Linux 是自由软件和开放源代码软件发展中最著名的例子。只要遵循 GNU 通用公共许可证，任何个人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。随着 Linux 操作系统飞速发展，各种集成在 Linux 上的开源软件和实用工具也得到了应用和普及，因此，Linux 也成为了开源软件的代名词。</p>
<p>1.2 Linux 在服务器领域的发展</p>
<p>随着开源软件在世界范围内影响力日益增强，Linux 服务器操作系统在整个服务器操作系统市场格局中占据了越来越多的市场份额，已经形成了大规模市场应用的局面。并且保持着快速的增长率。尤其在政府、金融、农业、交通、电信等国家关键领域。此外，考虑到 Linux 的快速成长性以及国家相关政策的扶持力度，Linux 服务器产品一定能够冲击更大的服务器市场。</p>
<p>据权威部门统计，目前 Linux 在服务器领域已经占据 75%的市场份额，同时，Linux 在服务器市场的迅速崛起，已经引起全球 IT 产业的高度关注，并以强劲的势头成为服务器操作系统领域中的中坚力量。</p>
<p>1.3 Linux 在桌面领域的发展</p>
<p>近年来，特别在国内市场，Linux 桌面操作系统的发展趋势非常迅猛。国内如中标麒麟 Linux、红旗 Linux、深度 Linux 等系统软件厂商都推出的 Linux 桌面操作系统，目前已经在政府、企业、OEM 等领域得到了广泛应用。另外 SUSE、Ubuntu 也相继推出了基于 Linux 的桌面系统，特别是 Ubuntu Linux，已经积累了大量社区用户。但是，从系统的整体功能、性能来看，Linux 桌面系统与 Windows 系列相比还有一定的差距，主要表现在系统易用性、系统管理、软硬件兼容性、软件的丰富程度等方面。</p>
<p>1.4 Linux 在移动嵌入式领域的发展</p>
<p>Linux 的低成本、强大的定制功能以及良好的移植性能，使得 Linux 在嵌入式系统方面也得到广泛应用，目前 Linux 以广泛应用于手机、平板电脑、路由器、电视和电子游戏机等领域。在移动设备上广泛使用的 Android 操作系统就是创建在 Linux 内核之上的。目前，Android 已经成为全球最流行的智能手机操作系统，据 2015 年权威部门最新统计，Android 操作系统的全球市场份额已达 84.6%。</p>
<p>此外，思科在网络防火墙和路由器也使用了定制的 Linux，阿里云也开发了一套基于 Linux 的操作系统“YunOS”，可用于智能手机、平板电脑和网络电视；常见的数字视频录像机、舞台灯光控制系统等都在逐渐采用定制版本的 Linux 来实现，而这一切均归功与 Linux 与开源的力量。</p>
<p>1.5 Linux 在云计算/大数据领域的发展</p>
<p>互联网产业的迅猛发展，促使云计算、大数据产业的形成并快速发展，云计算、大数据作为一个基于开源软件的平台，Linux 占据了核心优势；据 Linux 基金会的研究，86%的企业已经使用 Linux 操作系统进行云计算、大数据平台的构建，目前，Linux 已开始取代 Unix 成为最受青睐的云计算、大数据平台操作系统。</p>
<p>二、选择适合自己的 Linux 发行版</p>
<p>谈到 Linux 的发行版本，太多了，可能谁也不能给出一个准确的数字，但是有一点是可以肯定的，Linux 正在变得越来越流行。面对这么多的 Linux 发行版，打算从其他系统转到 Linux 系统来的初学者可能会感到困惑，即便是忠实的 Linux 用户也没有时间和精力去挨个尝试，因此初学者在学习 Linux 之前，需要有一个明确的方向，选择一个适合自己的 Linux 系统至关重要。下面我们就分类介绍。</p>
<p>2.1 常见的 Linux 发行版</p>
<p>1．Red Hat Linux</p>
<p>Red Hat Linux 是 Red Hat 最早发行的个人版本的 Linux，其 1.0 版本于 1994 年 11 月 3 日发行。虽然其历史不及其他 Linux 发行版本悠久，但比起很多的 Linux 发行套件，Red Hat 的历史要悠久得多。自从 Red Hat 9.0 版本发布后，Red Hat 公司就不再开发桌面版的 Linux 发行套件，Red Hat Linux 停止了开发，而将全部力量集中在服务器版的开发上，也就是 Red Hat Enterprise Linux 版。2004 年 4 月 30 日，Red Hat 公司正式停止对 Red Hat 9.0 版本的支援，标志着 Red Hat Linux 的正式完结。原本的桌面版 Red Hat Linux 发行套件则与来自开源社区的 Fedora 进行合并，成为 Fedora Core 发行版本。</p>
<p>目前 Red Hat 分为两个系列：由 Red Hat 公司提供收费技术支持和更新的 Red Hat Enterprise Linux，以及由社区开发的免费的 Fedora Core。</p>
<p>2．Fedora Core</p>
<p>Fedora Core（缩写为 FC）被 Red Hat 公司定位为新技术的测试平台，许多新的技术都会在 FC 中检验。如果稳定的话 Red Hat 公司则会考虑加入到 Red Hat Enterprise Linux 中。</p>
<p>Fedora Core 1 发布于 2003 年年末，而 FC 的定位便是桌面用户。FC 提供了最新的软件包，同时它的版本更新周期也非常短，仅有 6 个月。由于版本更新频繁，性能和稳定性得不到保证，因此一般在服务器上不推荐采用 Fedora Core。</p>
<p>Fedora 对于用户而言，是一套功能完备、更新迅速的免费操作系统，因此，个人领域的应用，例如开发、体验新功能等可选择此发行版本。</p>
<p>3．Red Hat Enterprise Linux</p>
<p>Red Hat Enterprise Linux（缩写为 RHEL，Red Hat 的企业版 Linux）。Red Hat 现在主要做服务器版的 Linux 开发，在版本上注重了性能和稳定性，以及对硬件的支持。由于企业版操作系统的开发周期较长，注重性能、稳定性和服务端软件支持，因此版本更新相对较缓慢。</p>
<p>RHEL 的版本都是基于 Fedora。大约每六个版本的 Fedora 会有一个新版本的 RHEL 发布，因此，RHEL 大约 3 年发布一个新版本。其最新版本是 2015 年 3 月 6 日发布的 RHEL 7.1。本书就是以此版本展开讲述的。</p>
<p>4．Centos</p>
<p>CentOS 全名为“社区企业操作系统”（Community Enterprise Operating System）。它是来自于 RHEL 依照开放源代码规定发布的源代码所编译而成，由于 RHEL 是商业产品，因此必须将所有 Red Hat 的 Logo 标识改成自己的 CentOS 标识，这就产生了 CentOS 操作系统，两者的不同在于，CentOS 并不包含封闭源代码软件。因此，CentOS 不但可以自由使用，而且还能享受 CentOS 提供的免费长期升级和更新服务。这是 CentOS 的一个很大优势。</p>
<p>CentOS 采取从 RHEL 的源代码包来构建，它的版本号有两个部分：一个主要版本和一个次要版本，主要和次要版本号分别对应于 RHEL 的主要版本与更新包，例如 CentOS6.5 构建在 RHEL6.0 更新的第 5 版。但是从 RHEL7.0 版本以后，CentOS 版本命名格式又稍有变化：主要版本仍然对应于 RHEL 的主要版本，次要版本以 RHEL 更新包发布日期为准，例如 RHEL7.1 对应的 CentOS 版本为 CentOS 7.1.1503，这表示 RHEL7.1 版本是 2015 年 3 月份发布的。</p>
<p>在 2014 年 CentOS 宣布与 Red Hat 合作，但 CentOS 将会在新的委员会下继续运作，并不受 RHEL 的影响。这个策略表明 CentOS 后续发展将有 Red Hat 作为强有力的支持。</p>
<p>5、SuSE Linux</p>
<p>SUSE 是德国最著名的 Linux 发行版，也享有很高的声誉，不过命运相当坎坷；2003 年 11 月 4 日，Novell 公司对外宣布将收购 SUSE。2004 年 1 月该收购顺利完成，Novell 同时将 SUSE 正式命名为 SUSE Linux。Novell 公司收购 SUSE，加速了 SUSE Linux 的发展，将免费 SUSE Linux 改为 openSUSE 社区项目，但在 2010 年，Attachmate 公司收购了 Novell，在被收购后，SUSE Linux 发展受阻，而就在 3 年后，SUSE 再次易主，2014 年 9 月 Attachmate 公司被上市公司 Micro Focus 收购，但幸运的是：SUSE 官方宣布开源作为 SUSE 的发展之本，仍将持续贡献开源，SUSE 仍将全力投入对 openSUSE 的支持。</p>
<p>虽然 SUSE 多次易主，但并不影响它的专业性，据不完全统计，SUSE Linux 现在欧洲 Linux 市场占有将近 80%的份额，大部分关键性应用都是建立在 SUSE Linux 下的。而由于 SUSE 多次易主，再加上 SUSE 在中国的营销模式问题，现在 SUSE 在中国的 Linux 市场份额并不大，但是这些并不影响 SUSE Linux 高可靠性与稳定性的事实。随着 SUSE 的发展，相信 SUSE Linux 在中国的应用会越来越多。</p>
<p>6、Ubuntu Linux</p>
<p>Ubuntu（中文谐音为友帮拓、优般图、乌班图）是一个以桌面应用为主的 Linux 操作系统，基于 Debian GNU/Linux，Ubuntu 的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由自由软件构建而成的操作系统。Ubuntu 具有庞大的社区力量，用户可以方便地从社区获得帮助。</p>
<p>7、发行版总结</p>
<p>上面主要介绍了几种最常见的 Linux 发行版本，其实 Linux 的发行版本还有很多，比较常见的还有 Debian GNU/Linux、Mandriva、Gentoo、Slackware、Knoppix、MEPIS 和 Xandros，以及国产的红旗 Redflag、深度 deepin Linux 和中标麒麟 Linux 等，这里不再一一介绍。其实纵观 Linux 的各个发行版，Linux 发行版本无非是朝着这两个方面而来，一是服务器市场，二是桌面市场。</p>
<p>以 Ubuntu Linux 为代表的 Linux 发行版走的是桌面市场路线，虽然它们给用户带来很多惊喜，更新也很快，但是由于桌面市场有着 Windows 这样强劲的对手，因此 Linux 桌面发展不容乐观，目前 Ubuntu Linux 也开始向企业级服务器市场发力。</p>
<p>以 Red Hat 系列版本为代表的 Linux 发行版现在主要面向企业级 Linux 的服务器市场，重点开发 Linux 的企业版本，其他的（例如国产 Redflag、中标麒麟 Linux 等）都重点投入在了 Linux 服务器市场。Linux 两大发布厂商现在都走了 Linux 服务器市场的路线，可见 Linux 作为企业级服务器有着巨大的发展前途。据权威部门统计，Linux 在服务器市场的占有率每年都在持续上升。</p>
<p>其实很多 Linux 的应用都是针对 Linux 服务器的，本书的讲述也是主要针对 Linux 在服务器下的各种应用展开的。</p>
<p>2.2 初学者入门首选——Centos 系列</p>
<p>在了解了 Linux 几个主要发行版本后，我们就找到了为何选择 CentOS 作为初学者入门学习的理由了。</p>
<p>CentOS 现在拥有庞大的网络用户群体，网络 Linux 资源基本 80%都是基于 CentOS 发行版的，如果在学习过程中遇到任何问题，在网络中可以较容易地搜索到解决方案。</p>
<p>CentOS 系列版本可以轻松获得。可以从 CentOS 官网或者 163 开源、sohu 开源、阿里云开源站下载 CentOS 各个版本的安装介质，如果是第一次接触 Linux，那么建议先安装 Fedora Core。Fedora Core 的安装简单，对硬件支持很好，界面也很华丽，同时也可以体验 Linux 的最新功能。如果对 Linux 有一定的了解，需要深入学习，建议使用 CentOS 发行版系统。</p>
<p>CentOS 应用范围广，具有典型性和代表性，现在基本所有的互联网公司后台服务器都采用 CentOS 作为操作系统，可以说学会了 CentOS，不但能迅速融入企业的工作环境，还能触类旁通，其它类似的 Linux 发行版也能很快掌握。同时，现在周围学习 Linux 的用户一般也都是以 CentOS 为主的，这样交流方便，学习中出现问题，更容易得到解决。最主要的是 CentOS 的安装和使用上也是最简单的，因此基本上不会在“装系统”上浪费过多时间。</p>
<p>2.3 桌面平台首选——Ubuntu Linux</p>
<p>说到 Linux 桌面市场，Ubuntu Linux 几乎占据了桌面 Linux 的半壁江山，Ubuntu Linux 主打 Linux 桌面之最，界面美观，简洁而不失华丽，如果想在 Linux 下进行娱乐休闲，Ubuntu Linux 绝对是首选。</p>
<p>Ubuntu 的安装非常人性化，只需按照提示一步一步进行。Ubuntu 被誉为对硬件支持最好最全面的 Linux 发行版之一，许多在其他发行版上无法使用的，或者在默认配置时无法使用的硬件，在 Ubuntu 上都能轻松安装使用。因此用户可以像安装 Windows 一样轻松地安装 Ubuntu，尽情体验 Ubuntu Linux 带来的乐趣。</p>
<p>2.4 企业级应用首选——RHEL/Centos 系列</p>
<p>企业级的应用追求的是可靠性和稳定性，这就要求构建企业级应用的系统平台具有高可靠性和高稳定性。企业级 Linux 的发行版本就是解决的这个问题。</p>
<p>RHEL 与 Centos 两个 Linux 发现版本，并没有太大差别，所不同的是 RHEL 属于商业 Linux 发行版本，如果要使用 RHEL 版本，则需要购买商业授权和咨询服务，Red Hat 提供系统的技术支持并提供系统的免费升级。目前 Red Hat 官网已经不再提供可免费下载的光盘介质，如果需要试用，可通过官网下载有试用时间的评估版 Linux。而 CentOS 属于非商业发行版，可以从网上免费下载 CentOS 各个版本的安装介质，但 CentOS 并不提供商业支持，当然使用者也不用负上任何商业责任。</p>
<p>那么，到底是选择 CentOS 还是 RHEL 呢，这取决于你所在公司是否拥有相应的技术力量，如果是单纯的业务型企业，那么建议选购 RHEL 发行版并购买相应服务，这样可以节省企业的 IT 管理费用，并可得到专业的技术支持服务。相反，如果企业技术力量比较强大，并且有多年 Linux 使用经验的话，那么 CentOS 发行版将是最好的选择。</p>
<p>三、 养成良好的 Linux 操作习惯</p>
<p>开始 Linux 的学习之后，请不要用 Windows 的工作方式来思考问题，因为它们之间确实有很大的不同，比如它们之间的内存管理机制、进程运行机制等都有很大不同，因此抛开 Windows 的那种思维，用全新的理念尝试去挖掘 Linux 身上特有的潜质，对初学者是至关重要的。</p>
<p>3.1 一定要习惯命令行方式</p>
<p>Linux 是由命令行组成的操作系统，精髓在命令行，无论图形界面发展到什么水平，命令行方式的操作永远是不会变的。Linux 命令有许多强大的功能：从简单的磁盘操作、文件存取，到进行复杂的多媒体图像和流媒体文件的制作，都离不开命令行。虽然 Linux 也有桌面系统，但是 X-window 也只是运行在命令行模式下的一个应用程序。</p>
<p>因此，可以说命令是学习 Linux 系统的基础，在很大程度上学习 Linux 就是学习命令，很多 Linux 高手其实都是玩儿命令很熟练的人。</p>
<p>也许对于刚刚从 Windows 系统进入 Linux 学习的初学者来说，立刻进入枯燥的命令学习实在太难，但是一旦学会就爱不释手。因为它的功能实在太强大了。</p>
<p>3.2 理论结合实践</p>
<p>有很多初学者都会遇到这么一个问题，自己对系统的每个命令都很熟悉，但是在系统出现故障的时候，就无从下手了，甚至不知道在什么时候用什么命令去检查系统，这是很多 Linux 新手最无奈的事情了。说到底，就是学习的理论知识没有很好地与系统实际操作相结合。</p>
<p>很多 Linux 知识，例如每个命令的参数含义，在书本上说得很清楚，看起来也很容易理解，但是一旦组合起来使用，却并不那么容易，没有多次的动手练习，其中的技巧是无法完全掌握的。</p>
<p>人类大脑不像计算机的硬盘，除非硬盘坏掉或者硬盘被格式化，否则储存的资料将永远记忆在硬盘中，而且时刻可以调用。而在人类记忆的曲线中，必须要不断地重复练习才会将一件事情记得比较牢。学习 Linux 也一样，如果无法坚持学习的话，就会学了后面的，忘记了前面的。还有些 Linux 初学者也学了很多 Linux 知识，但是由于长期不用，导致学过的东西在很短的时间内又忘记了，久而久之，失去了学习的信心。</p>
<p>可见，要培养自己的实战技能，只有勤于动手，肯于实践，这也是学好 Linux 的根本。</p>
<p>3.3 学会使用 Linux 联机帮助</p>
<p>各个 Linux 的发行版本的技术支持时间都较短，这对于 Linux 初学者来说往往是不够的，其实当安装了完整的 Linux 系统后其中已经包含了一个强大的帮助，只是可能你还没有发现它，或者还没有掌握使用它的技巧。例如，对于 tar 命令的使用不是很熟悉，那么只要在命令行输入“man tar”，就会得到 tar 的详细说明和用法。</p>
<p>主流的 Linux 发行版都自带了非常详细的帮助文档，包括使用说明和 FAQ，从系统的安装到系统的维护，再到系统安全，针对不同层次用户的详尽文档。仔细阅读文档后，60%的问题都可在这里得到解决。</p>
<p>3.4 学会独立思考问题，独立解决问题</p>
<p>遇到问题，首先想到的应该是如何自己去解决这个问题，解决方式有很多，比如看书查资料、网络搜索引擎搜索和浏览技术论坛等，通过这几种方式，90%的问题都能得到解决</p>
<p>独立思考并解决问题，不但锻炼了自己独立解决问题的能力，在技术上也能得到快速提高。如果通过以上方式实在解决不了的话，可以向人询问，得到答案后要思考为何这么做，然后做笔记记录解决过程。最忌讳的方式是只要遇到问题，就去问人，虽然这样可能会很快解决问题，但是长久下去遇到问题就会依赖别人，技术上也不会进步。</p>
<p>3.5 学习专业英语</p>
<p>如果想深入学习 Linux，一定要尝试去看英文文档。因为，技术性的东西写的最好的，最全面的文档都是英语写的，最先发布的高新技术也都是用英语写的。即便是非英语国家的人发布技术文档，也都首先翻译成英语在国际学术杂志和网络上发表。安装一个新的软件时先看 Readme 文档，再看 Install 文档，然后看 FAQ 文档，最后才动手安装，这样遇到问题就知道原因了。因此，学习一点专业的英语是很有必要的。</p>
<p>四、Linux 学习路线图</p>
<p>Linux 运维或管理人才是企业目前急需的技术人才之一，笔者根据 10 多年 Linux 相关工作经验，总结出了一套学习 Linux 的线路图，大家可以此线路图为依据，抓住重点，分清主次，相信一定能达到事半功倍的效果。如果读者能认真学习完并掌握本线路图所涉及的技术要点，那么也就基本掌握了企业对 Linux 运维或管理人才的基本应用需求。</p>
<p>Linux 学习线路图如下图所示，本线路图分为初级、中级和高级三个阶段：初级阶段主要是对 Linux 基础知识以及系统基本应用的介绍，要掌握的内容较多，如果初次接触 Linux，那么入门还是有一定难度的，Linux 注重的是命令操作，因此初级阶段以学习基础命令为主，多看书、多实践是学好命令的根本；中级阶段以服务器常见配置为主，涉及各种应用服务器的配置、网络配置、系统安全配置等几个方面。此阶段的难点在于各种服务器的搭建，对综合知识要求较高；高级阶段的重点是编程语言、集群架构两个方面，此阶段的发展方向是高级运维工程师或系统架构师，要成为系统架构师，熟练掌握一门编程语言是必须的，而 Linux 下常见的各种集群架构、分布式架构也是高级运维工程师必须要掌握的。</p>
<p><img data-src="//img.leense.site/post/2016/03/201603090930-1.png"></p>
<p>本文出自 “南非蚂蚁 Linux” 博客，请务必保留此出处<a href="http://ixdba.blog.51cto.com/2895551/1739514">http://ixdba.blog.51cto.com/2895551/1739514</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JQuery插件开发</title>
    <url>/2016/04/jquery-plugin/</url>
    <content><![CDATA[<p>如果你看到这篇文章，我确信你毫无疑问会认为jQuery是一个使用简便的库。jQuery可能使用起来很简单，但是它仍然有一些奇怪的地方，对它基本功能和概念不熟悉的人可能会难以掌握。但是不用担心，我下面已经把代码划分成小部分，做了一个简单的指导。那些语法看起来可能过于复杂，但是如果进入到它的思想和模式中，它是非常简单易懂的。</p>
<span id="more"></span>

<p>下面，我们有了一个插件的基本层次：</p>
<pre><code class="js">// Shawn Khameneh
// ExtraordinaryThoughts.com

(function($) &#123;
    var privateFunction = function() &#123;

// 代码在这里运行
    &#125;

    var methods = &#123;
        init: function(options) &#123;
            return this.each(function() &#123;
                var $this = $(this);
                var settings = $this.data(&#39;pluginName&#39;);

                if(typeof(settings) == &#39;undefined&#39;) &#123;

                    var defaults = &#123;
                        propertyName: &#39;value&#39;,
                        onSomeEvent: function() &#123;&#125;
                    &#125;

                    settings = $.extend(&#123;&#125;, defaults, options);

                    $this.data(&#39;pluginName&#39;, settings);
                &#125; else &#123;
                    settings = $.extend(&#123;&#125;, settings, options);
                &#125;


// 代码在这里运行

            &#125;);
        &#125;,
        destroy: function(options) &#123;
            return $(this).each(function() &#123;
                var $this = $(this);

                $this.removeData(&#39;pluginName&#39;);
            &#125;);
        &#125;,
        val: function(options) &#123;
            var someValue = this.eq(0).html();

            return someValue;
        &#125;
    &#125;;

    $.fn.pluginName = function() &#123;
        var method = arguments[0];

        if(methods[method]) &#123;
            method = methods[method];
            arguments = Array.prototype.slice.call(arguments, 1);
        &#125; else if( typeof(method) == &#39;object&#39; || !method ) &#123;
            method = methods.init;
        &#125; else &#123;
            $.error( &#39;Method &#39; +  method + &#39; does not exist on jQuery.pluginName&#39; );
            return this;
        &#125;

        return method.apply(this, arguments);

    &#125;

&#125;)(jQuery);
</code></pre>
<p>你可能会注意到，我所提到代码的结构和其他插件代码有很大的不同。根据你的使用和需求的不同，插件的开发方式也可能会呈现多样化。我的目的是澄清代码中的一些概念，足够让你找到适合自己的方法去理解和开发一个jQuery插件。</p>
<p>现在，来解剖我们的代码吧！</p>
<h3 id="容器：一个即时执行函数"><a href="#容器：一个即时执行函数" class="headerlink" title="容器：一个即时执行函数"></a>容器：一个即时执行函数</h3><p>根本上来说，每个插件的代码是被包含在一个即时执行的函数当中，如下：</p>
<pre><code class="js">(function(arg1, arg2) &#123;

// 代码
&#125;)(arg1, arg2);
</code></pre>
<p>即时执行函数，顾名思义，是一个函数。让它与众不同的是，它被包含在一对小括号里面，这让所有的代码都在匿名函数的局部作用域中运行。这并不是说DOM（全局变量）在函数内是被屏蔽的，而是外部无法访问到函数内部的公共变量和对象命名空间。这是一个很好的开始，这样你声明你的变量和对象的时候，就不用担心着变量名和已经存在的代码有冲突。</p>
<p>现在，因为函数内部所有的所有公共变量是无法访问的，这样要把jQuery本身作为一个内部的公共变量来使用就会成为问题。就像普通的函数一样，即时函数也根据引用传入对象参数。我们可以将jQuery对象传入函数，如下：</p>
<pre><code class="js">(function($) &#123;


// 局部作用域中使用$来引用jQuery
&#125;)(jQuery);
</code></pre>
<p>我们传入了一个把公共变量“jQuery”传入了一个即时执行的函数里面，在函数局部（容器）中我们可以通过<code>“$”</code>来引用它。也就是说，我们把容器当做一个函数来调用，而这个函数的参数就是jQuery。因为我们引用的“jQuery”作为公共变量传入，而不是它的简写“$”，这样我们就可以兼容Prototype库。如果你不用Prototype或者其它用<code>“$”</code>做简写的库的话，你不这样做也不会造成什么影响，但是知道这种用法仍是一件好事。</p>
<h3 id="插件：一个函数"><a href="#插件：一个函数" class="headerlink" title="插件：一个函数"></a>插件：一个函数</h3><p>一个jQuery插件本质上是我们塞进jQuery命名空间中一个庞大的函数，当然，我们可以很轻易地用“jQuery.pluginName=function”，来达到我们的目的，但是如果我们这样做的话我们的插件的代码是处于没有被保护的暴露状态的。“jQuery.fn”是“jQuery.prototype”的简写，意味当我们通过jQuery命名空间去获取我们的插件的时候，它仅可写（不可修改）。它事实上可以为你干点什么事呢？它让你恰当地组织自己的代码，和理解如何保护你的代码不受运行时候不需要的修改。最好的说法就是，这是一个很好的实践！</p>
<p>通过一个插件，我们获得一个基本的jQuery函数：</p>
<pre><code class="js">
(function($) &#123;

    $.fn.pluginName = function(options) &#123;


// 代码在此处运行

        return this;
    &#125;

&#125;)(jQuery);
</code></pre>
<p>上面的代码中的函数可以像其他的jQuery函数那样通过<br><code>$(&#39;#element’).pluginName()</code>来调用。注意，我是如何把“return this”语句加进去的；这小片的代码通过返回一个原来元素的集合（包含在this当中）的引用来产生链式调用的效果，而这些元素是被一个jQuery对象所包裹的。你也应该注意，“this”在这个特定的作用域中是一个jQuery对象，相当于<code>$(‘#element’)</code>。</p>
<p>根据返回的对象，我们可以总结出，在上面的代码中，使用<code>$(‘#element’).pluginName()</code>的效果和使用<code>$(‘#element’)</code>的效果是一样的。在你的即时执行函数作用域中，没必要用<code>$(this)</code>的方式来把this包裹到一个jQuery对象中，因为this本身已经是被包装好的jQuery对象。</p>
<h3 id="多个元素：理解Sizzle"><a href="#多个元素：理解Sizzle" class="headerlink" title="多个元素：理解Sizzle"></a>多个元素：理解Sizzle</h3><p>jQuery使用的选择器引擎叫Sizzle，Sizzle可以为你的函数提供多元素操作（例如对所有类名相同的元素）。这是jQuery几个优秀的特性之一，但这也是你在开发插件过程中需要考虑的事情。即使你不准备为你的插件提供多元素支持，但为这做准备仍然是一个很好的实践。</p>
<p>这里我添加了一小段代码，它让你的插件代码为多元素集合中每个元素单独地起作用：</p>
<pre><code class="js">function($) &#123;


// 向jQuery中被保护的“fn”命名空间中添加你的插件代码，用“pluginName”作为插件的函数名称
    $.fn.pluginName = function(options) &#123;


// 返回“this”（函数each（）的返回值也是this），以便进行链式调用。
        return this.each(function() &#123;


// 此处运行代码，可以通过“this”来获得每个单独的元素

// 例如： $(this).show()；
            var $this = $(this);

        &#125;);

    &#125;

&#125;)(jQuery);
</code></pre>
<p>在以上示例代码中，我并不是用 each（）在我的选择器中每个元素上运行代码。在那个被 each（）调用的函数的局部作用域中，你可以通过this来引用每个被单独处理的元素，也就是说你可以通过$(this)来引用它的jQuery对象。在局部作用域中，我用$this变量存储起jQuery对象，而不是每次调用函数的时候都使用$(this)，这会是个很好的实践。当然，这样做并不总是必要的；但我已经额外把它包含在我的代码中。还有要注意的是，我们将会对每个单独方法都使用 each（），这样到时我们就可以返回我们需要的值，而不是一个jQuery对象。</p>
<p>下面是一个例子，假如我们的插件支持一个 val 的方法，它可以返回我们需要的值：</p>
<pre><code class="js">$(&#39;#element&#39;).pluginName(&#39;val&#39;);
// 会返回我们需要的值，而不是一个jQuery对象
</code></pre>
<h3 id="功能：公有方法和私有方法"><a href="#功能：公有方法和私有方法" class="headerlink" title="功能：公有方法和私有方法"></a>功能：公有方法和私有方法</h3><p>一个基本的函数可能在某些情况下可以良好地工作，但是一个稍微复杂一点的插件就需要提供各种各样的方法和私有函数。你可能会使用不同的命名空间去为你的插件提供各种方法，但是最好不要让你的源代码因为多余的命名空间而变得混乱。</p>
<p>下面的代码定义了一个存储公有方法的JSON对象，以及展示了如何使用插件中的主函数中去判断哪些方法被调用，和如何在让方法作用到选择器每个元素上。</p>
<pre><code class="js">(function($) &#123;


// 在我们插件容器内，创造一个公共变量来构建一个私有方法
    var privateFunction = function() &#123;

// code here
    &#125;


// 通过字面量创造一个对象，存储我们需要的共有方法
    var methods = &#123;

// 在字面量对象中定义每个单独的方法
        init: function() &#123;


// 为了更好的灵活性，对来自主函数，并进入每个方法中的选择器其中的每个单独的元素都执行代码
            return this.each(function() &#123;

// 为每个独立的元素创建一个jQuery对象
                var $this = $(this);


// 执行代码

// 例如： privateFunction();
            &#125;);
        &#125;,
        destroy: function() &#123;

// 对选择器每个元素都执行方法
            return this.each(function() &#123;

// 执行代码
            &#125;);
        &#125;
    &#125;;

    $.fn.pluginName = function() &#123;

// 获取我们的方法，遗憾的是，如果我们用function(method)&#123;&#125;来实现，这样会毁掉一切的
        var method = arguments[0];


// 检验方法是否存在
        if(methods[method]) &#123;


// 如果方法存在，存储起来以便使用

// 注意：我这样做是为了等下更方便地使用each（）
            method = methods[method];


// 如果方法不存在，检验对象是否为一个对象（JSON对象）或者method方法没有被传入
        &#125; else if( typeof(method) == &#39;object&#39; || !method ) &#123;


// 如果我们传入的是一个对象参数，或者根本没有参数，init方法会被调用
            method = methods.init;
        &#125; else &#123;


// 如果方法不存在或者参数没传入，则报出错误。需要调用的方法没有被正确调用
            $.error( &#39;Method &#39; +  method + &#39; does not exist on jQuery.pluginName&#39; );
            return this;
        &#125;


// 调用我们选中的方法

// 再一次注意我们是如何将each（）从这里转移到每个单独的方法上的
        return method.call(this);

    &#125;

&#125;)(jQuery);
</code></pre>
<p>注意我把 privateFunction 当做了一个函数内部的全局变量。考虑到所有的代码的运行都是在插件容器内进行的，所以这种做法是可以被接受的，因为它只在插件的作用域中可用。在插件中的主函数中，我检验了传入参数所指向的方法是否存在。如果方法不存在或者传入的是参数为对象， init 方法会被运行。最后，如果传入的参数不是一个对象而是一个不存在的方法，我们会报出一个错误信息。</p>
<p>同样要注意的是，我是如何在每个方法中都使用<code> this.each()</code> 的。当我们在主函数中调用 <code>method.call(this)</code> 的时候，这里的 this 事实上就是一个jQuery对象，作为 this 传入每个方法中。所以在我们方法的即时作用域中，它已经是一个jQuery对象。只有在被 <code>each（）</code>所调用的函数中，我们才有必要将this包装在一个jQuery对象中。</p>
<p>下面是一些用法的例子：</p>
<pre><code class="js">/*

注意这些例子可以在目前的插件代码中正确运行，并不是所有的插件都使用同样的代码结构
*/
// 为每个类名为 &quot;.className&quot; 的元素执行init方法
$(&#39;.className&#39;).pluginName();
$(&#39;.className&#39;).pluginName(&#39;init&#39;);
$(&#39;.className&#39;).pluginName(&#39;init&#39;, &#123;&#125;);
// 向init方法传入“&#123;&#125;”对象作为函数参数
$(&#39;.className&#39;).pluginName(&#123;&#125;);
// 向init方法传入“&#123;&#125;”对象作为函数参数

// 为每个类名为 “.className” 的元素执行destroy方法
$(&#39;.className&#39;).pluginName(&#39;destroy&#39;);
$(&#39;.className&#39;).pluginName(&#39;destroy&#39;, &#123;&#125;);
// 向destroy方法传入“&#123;&#125;”对象作为函数参数

// 所有代码都可以正常运行
$(&#39;.className&#39;).pluginName(&#39;init&#39;, &#39;argument1&#39;, &#39;argument2&#39;);
// 把 &quot;argument 1&quot; 和 &quot;argument 2&quot; 传入 &quot;init&quot;

// 不正确的使用
$(&#39;.className&#39;).pluginName(&#39;nonexistantMethod&#39;);
$(&#39;.className&#39;).pluginName(&#39;nonexistantMethod&#39;, &#123;&#125;);
$(&#39;.className&#39;).pluginName(&#39;argument 1&#39;);
// 会尝试调用 &quot;argument 1&quot; 方法
$(&#39;.className&#39;).pluginName(&#39;argument 1&#39;, &#39;argument 2&#39;);
// 会尝试调用 &quot;argument 1&quot; ，“argument 2”方法
$(&#39;.className&#39;).pluginName(&#39;privateFunction&#39;);
// &#39;privateFunction&#39; 不是一个方法
</code></pre>
<p>在上面的例子中多次出现了 {} ，表示的是传入方法中的参数。在这小节中，上面代码可以可以正常运行，但是参数不会被传入方法中。继续阅读下一小节，你会知道如何向方法传入参数。</p>
<h3 id="设置插件：传入参数"><a href="#设置插件：传入参数" class="headerlink" title="设置插件：传入参数"></a>设置插件：传入参数</h3><p>许多插件都支持参数传入，如配置参数和回调函数。你可以通过传入JS键值对对象或者函数参数，为方法提供信息。如果你的方法支持多于一个或两个参数，那么没有比传入对象参数更恰当的方式。</p>
<pre><code class="js">(function($) &#123;
    var methods = &#123;
        init: function(options) &#123;


// 在每个元素上执行方法
            return this.each(function() &#123;
                var $this = $(this);


// 创建一个默认设置对象
                var defaults = &#123;
                    propertyName: &#39;value&#39;,
                    onSomeEvent: function() &#123;&#125;
                &#125;


// 使用extend方法从options和defaults对象中构造出一个settings对象
                var settings = $.extend(&#123;&#125;, defaults, options);


// 执行代码

            &#125;);
        &#125;
    &#125;;

    $.fn.pluginName = function() &#123;
        var method = arguments[0];

        if(methods[method]) &#123;
            method = methods[method];


// 我们的方法是作为参数传入的，把它从参数列表中删除，因为调用方法时并不需要它
            arguments = Array.prototype.slice.call(arguments, 1);
        &#125; else if( typeof(method) == &#39;object&#39; || !method ) &#123;
            method = methods.init;
        &#125; else &#123;
            $.error( &#39;Method &#39; +  method + &#39; does not exist on jQuery.pluginName&#39; );
            return this;
        &#125;


// 用apply方法来调用我们的方法并传入参数
        return method.apply(this, arguments);

    &#125;

&#125;)(jQuery);
</code></pre>
<p>正如上面所示，一个“options”参数被添加到方法当中，和“arguments”也被添加到了主函数中。如果一个方法已经被声明，在参数传入方法之前，调用那个方法的参数会从参数列表中删除掉。我用了“apply（）”来代替了“call（）”，“apply（）”本质上是和“call（）”做着同样的工作的，但不同的是它允许参数的传入。这种结构也允许多个参数的传入，如果你愿意这样做，你也可以为你的方法修改参数列表，例如：“init:function(arg1, arg2){}”。</p>
<p>如果你是使用JS对象作为参数传入，你可能需要定义一个默认对象。一旦默认对象被声明，你可以使用<code>“$.extend”</code>来合并参数对象和默认对象中的值，以形成一个新的参数对象来使用（在我们的例子中就是“settings”）；</p>
<p>这里有一些例子，用来演示以上的逻辑：</p>
<pre><code class="js">var options = &#123;
    customParameter: &#39;Test 1&#39;,
    propertyName: &#39;Test 2&#39;
&#125;

var defaults = &#123;
    propertyName: &#39;Test 3&#39;,
    onSomeEvent: &#39;Test 4&#39;
&#125;

var settings = $.extend(&#123;&#125;, defaults, options);
/*
settings == &#123;

propertyName: &#39;Test 2&#39;,

onSomeEvent: &#39;Test 4&#39;,

customParameter: &#39;Test 1&#39;
&#125;
*/
</code></pre>
<h3 id="保存设置：添加持久性数据"><a href="#保存设置：添加持久性数据" class="headerlink" title="保存设置：添加持久性数据"></a>保存设置：添加持久性数据</h3><p>有时你会想在你的插件中保存设置和信息，这时jQuery中的“data（）”函数就可以派上用场了。它在使用上是非常简单的，它会尝试获取和元素相关的数据，如果数据不存在，它就会创造相应的数据并添加到元素上。一旦你使用了“data（）”来为元素添加信息，请确认你已经记住，当不再需要数据的时候，用“removeData（）”来删除相应的数据。</p>
<pre><code class="js">// Shawn Khameneh
// ExtraordinaryThoughts.com

(function($) &#123;
    var privateFunction = function() &#123;

// 执行代码
    &#125;

    var methods = &#123;
        init: function(options) &#123;


// 在每个元素上执行方法
            return this.each(function() &#123;
                var $this = $(this);


// 尝试去获取settings，如果不存在，则返回“undefined”
                var settings = $this.data(&#39;pluginName&#39;);


// 如果获取settings失败，则根据options和default创建它
                if(typeof(settings) == &#39;undefined&#39;) &#123;

                    var defaults = &#123;
                        propertyName: &#39;value&#39;,
                        onSomeEvent: function() &#123;&#125;
                    &#125;

                    settings = $.extend(&#123;&#125;, defaults, options);


// 保存我们新创建的settings
                    $this.data(&#39;pluginName&#39;, settings);
                &#125; else &#123;
                    / 如果我们获取了settings，则将它和options进行合并（这不是必须的，你可以选择不这样做）
                    settings = $.extend(&#123;&#125;, settings, options);


// 如果你想每次都保存options，可以添加下面代码：

// $this.data(&#39;pluginName&#39;, settings);
                &#125;


// 执行代码

            &#125;);
        &#125;,
        destroy: function(options) &#123;

// 在每个元素中执行代码
            return $(this).each(function() &#123;
                var $this = $(this);


// 执行代码


// 删除元素对应的数据
                $this.removeData(&#39;pluginName&#39;);
            &#125;);
        &#125;,
        val: function(options) &#123;

// 这里的代码通过.eq(0)来获取选择器中的第一个元素的，我们或获取它的HTML内容作为我们的返回值
            var someValue = this.eq(0).html();


// 返回值
            return someValue;
        &#125;
    &#125;;

    $.fn.pluginName = function() &#123;
        var method = arguments[0];

        if(methods[method]) &#123;
            method = methods[method];
            arguments = Array.prototype.slice.call(arguments, 1);
        &#125; else if( typeof(method) == &#39;object&#39; || !method ) &#123;
            method = methods.init;
        &#125; else &#123;
            $.error( &#39;Method &#39; +  method + &#39; does not exist on jQuery.pluginName&#39; );
            return this;
        &#125;

        return method.apply(this, arguments);

    &#125;

&#125;)(jQuery);
</code></pre>
<p>在上面的代码中，我检验了元素的数据是否存在。如果数据不存在，“options”和“default”会被合并，构建成一个新的settings，然后用“data（）”保存在元素中。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>web</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>12个非常实用的JavaScript小技巧</title>
    <url>/2016/05/javascript-12-tips/</url>
    <content><![CDATA[<p>在这篇文章中将给大家分享12个有关于JavaScript的小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。</p>
<span id="more"></span>

<h2 id="使用-操作符转换布尔值"><a href="#使用-操作符转换布尔值" class="headerlink" title="使用!!操作符转换布尔值"></a>使用<code>!!</code>操作符转换布尔值</h2><p>有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回<code>true</code>值。为了做这样的验证，我们可以使用<code>!!</code>操作符来实现是非常的方便与简单。对于变量可以使用<code>!!variable</code>做检测，只要变量的值为:<code>0</code>、<code>null</code>、<code>&quot; &quot;</code>、<code>undefined</code>或者<code>NaN</code>都将返回的是<code>false</code>，反之返回的是<code>true</code>。比如下面的示例：</p>
<pre><code>function Account(cash) &#123;
    this.cash = cash;
    this.hasMoney = !!cash;
&#125;
var account = new Account(100.50);
console.log(account.cash); // 100.50
console.log(account.hasMoney); // true

var emptyAccount = new Account(0);
console.log(emptyAccount.cash); // 0
console.log(emptyAccount.hasMoney); // false
</code></pre>
<p>在这个示例中，只要<code>account.cash</code>的值大于<code>0</code>，那么<code>account.hasMoney</code>返回的值就是<code>true</code>。</p>
<h2 id="使用-将字符串转换成数字"><a href="#使用-将字符串转换成数字" class="headerlink" title="使用+将字符串转换成数字"></a>使用<code>+</code>将字符串转换成数字</h2><p>这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回<code>NaN</code>，比如下面的示例：</p>
<pre><code>function toNumber(strNumber) &#123;
    return +strNumber;
&#125;
console.log(toNumber(&quot;1234&quot;)); // 1234
console.log(toNumber(&quot;ACB&quot;)); // NaN
</code></pre>
<p>这个也适用于<code>Date</code>，在本例中，它将返回的是时间戳数字：</p>
<pre><code>console.log(+new Date()) // 1461288164385
</code></pre>
<h2 id="并条件符"><a href="#并条件符" class="headerlink" title="并条件符"></a>并条件符</h2><p>如果你有一段这样的代码：</p>
<pre><code>if (conected) &#123;
    login();
&#125;
</code></pre>
<p>你也可以将变量简写，并且使用<code>&amp;amp;&amp;amp;</code>和函数连接在一起，比如上面的示例，可以简写成这样：</p>
<pre><code>conected &amp;amp;&amp;amp; login();
</code></pre>
<p>如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：</p>
<pre><code>user &amp;amp;&amp;amp; user.login();
</code></pre>
<h2 id="使用-运算符"><a href="#使用-运算符" class="headerlink" title="使用||运算符"></a>使用<code>||</code>运算符</h2><p>在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用<code>||</code>操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为<code>false</code>，那么第二个值将会认为是一个默认值。如下面这个示例：</p>
<pre><code>function User(name, age) &#123;
    this.name = name || &quot;Oliver Queen&quot;;
    this.age = age || 27;
&#125;
var user1 = new User();
console.log(user1.name); // Oliver Queen
console.log(user1.age); // 27

var user2 = new User(&quot;Barry Allen&quot;, 25);
console.log(user2.name); // Barry Allen
console.log(user2.age); // 25
</code></pre>
<h2 id="在循环中缓存array-length"><a href="#在循环中缓存array-length" class="headerlink" title="在循环中缓存array.length"></a>在循环中缓存<code>array.length</code></h2><p>这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：</p>
<pre><code>for(var i = 0; i &amp;lt; array.length; i++) &#123;
    console.log(array[i]);
&#125;
</code></pre>
<p>如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将<code>array.length</code>做一个缓存：</p>
<pre><code>var length = array.length;
for(var i = 0; i &amp;lt; length; i++) &#123;
    console.log(array[i]);
&#125;
</code></pre>
<p>你也可以写在这样：</p>
<pre><code>for(var i = 0, length = array.length; i &amp;lt; length; i++) &#123;
    console.log(array[i]);
&#125;
</code></pre>
<h2 id="检测对象中属性"><a href="#检测对象中属性" class="headerlink" title="检测对象中属性"></a>检测对象中属性</h2><p>当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用<code>document.querySelector()</code>来选择一个<code>id</code>，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：</p>
<pre><code>if (&#39;querySelector&#39; in document) &#123;
    document.querySelector(&quot;#id&quot;);
&#125; else &#123;
    document.getElementById(&quot;id&quot;);
&#125;
</code></pre>
<p>在这个示例中，如果<code>document</code>不存在<code>querySelector</code>函数，那么就会调用<code>docuemnt.getElementById(&quot;id&quot;)</code>。</p>
<h2 id="获取数组中最后一个元素"><a href="#获取数组中最后一个元素" class="headerlink" title="获取数组中最后一个元素"></a>获取数组中最后一个元素</h2><p><code>Array.prototype.slice(begin,end)</code>用来获取<code>begin</code>和<code>end</code>之间的数组元素。如果你不设置<code>end</code>参数，将会将数组的默认长度值当作<code>end</code>值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为<code>begin</code>的值，那么你可以获取数组的最后一个元素。如：</p>
<pre><code>var array = [1,2,3,4,5,6];
console.log(array.slice(-1)); // [6]
console.log(array.slice(-2)); // [5,6]
console.log(array.slice(-3)); // [4,5,6]
</code></pre>
<h2 id="数组截断"><a href="#数组截断" class="headerlink" title="数组截断"></a>数组截断</h2><p>这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有<code>10</code>个元素，但你只想只要前五个元素，那么你可以通过<code>array.length=5</code>来截断数组。如下面这个示例：</p>
<pre><code>var array = [1,2,3,4,5,6];
console.log(array.length); // 6
array.length = 3;
console.log(array.length); // 3
console.log(array); // [1,2,3]
</code></pre>
<h2 id="替换所有"><a href="#替换所有" class="headerlink" title="替换所有"></a>替换所有</h2><p><code>String.replace()</code>函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的<code>/g</code>来模拟<code>replaceAll()</code>函数功能：</p>
<pre><code>var string = &quot;john john&quot;;
console.log(string.replace(/hn/, &quot;ana&quot;)); // &quot;joana john&quot;
console.log(string.replace(/hn/g, &quot;ana&quot;)); // &quot;joana joana&quot;
</code></pre>
<h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><p>如果你要合并两个数组，一般情况之下你都会使用<code>Array.concat()</code>函数：</p>
<pre><code>var array1 = [1,2,3];
var array2 = [4,5,6];
console.log(array1.concat(array2)); // [1,2,3,4,5,6];
</code></pre>
<p>然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用<code>Array.pus().apply(arr1,arr2)</code>来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：</p>
<pre><code>var array1 = [1,2,3];
var array2 = [4,5,6];
console.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];
</code></pre>
<h2 id="将NodeList转换成数组"><a href="#将NodeList转换成数组" class="headerlink" title="将NodeList转换成数组"></a>将<code>NodeList</code>转换成数组</h2><p>如果你运行<code>document.querySelectorAll(“p”)</code>函数时，它可能返回DOM元素的数组，也就是<code>NodeList</code>对象。但这个对象不具有数组的函数功能，比如<code>sort()</code>、<code>reduce()</code>、<code>map()</code>、<code>filter()</code>等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用<code>[].slice.call(elements)</code>来实现：</p>
<pre><code>var elements = document.querySelectorAll(&quot;p&quot;); // NodeList
var arrayElements = [].slice.call(elements); // Now the NodeList is an array
var arrayElements = Array.from(elements); // This is another way of converting NodeList to Array
</code></pre>
<h2 id="数组元素的洗牌"><a href="#数组元素的洗牌" class="headerlink" title="数组元素的洗牌"></a>数组元素的洗牌</h2><p>对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：</p>
<pre><code>var list = [1,2,3];
console.log(list.sort(function() &#123; Math.random() - 0.5 &#125;)); // [2,1,3]
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在你学会了些有用的JavaScript小技巧。希望这些小技巧能在工作中帮助你解决一些麻烦，或者说这篇文章对你有所帮助。如果你有一些优秀的JavaScript小技巧，欢迎在评论中与我们一起分享。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu日常问题搜集和解决办法</title>
    <url>/2016/11/linux-mint-use/</url>
    <content><![CDATA[<p>搜集了日常工作中linuxmint的使用的命令备份和遇到的问题以及解决办法.(持续更新中)</p>
<span id="more"></span>

<h2 id="保持ssh链接超时不自动断开"><a href="#保持ssh链接超时不自动断开" class="headerlink" title="保持ssh链接超时不自动断开"></a>保持ssh链接超时不自动断开</h2><p>用ssh链接服务端，一段时间不操作或屏幕没输出（比如复制文件）的时候，会自动断开.</p>
<p>在客户端~/.ssh/config文件(没有则新建)添加配置<code>ServerAliveInterval 30</code></p>
<pre><code>Host github.com
     IdentityFile ~/.ssh/id_rsa_github
Host git.oschina.net
     IdentityFile ~/.ssh/id_rsa_gitosc
Host 192.168.1.72
     IdentityFile ~/.ssh/id_rsa_deploy
 ServerAliveInterval 30
</code></pre>
<h2 id="常用软件源"><a href="#常用软件源" class="headerlink" title="常用软件源"></a>常用软件源</h2><pre><code class="js">//git
sudo add-apt-repository ppa:git-core/ppa
//atom
sudo add-apt-repository ppa:webupd8team/atom
//wiz
sudo add-apt-repository ppa:wiznote-team
//telegram
sudo add-apt-repository ppa:atareao/telegram
//nodev7
curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -
//nodev6
curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -
//nginx  --stable
//下载此key文件
http://nginx.org/keys/nginx_signing.key
//然后
sudo apt-key add nginx_signing.key
//firefox stable
sudo add-apt-repository ppa:ubuntu-mozilla-security/ppa
//firefox beta
sudo add-apt-repository ppa:mozillateam/firefox-next
//touchpad-indicator
sudo add-apt-repository ppa:atareao/atareao
</code></pre>
<h2 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh-My-Zsh"></a>Oh-My-Zsh</h2><pre><code class="js">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
</code></pre>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><pre><code class="js">curl -fsSL https://get.docker.com/ | sh
</code></pre>
<h2 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h2><pre><code class="js">npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>
<h2 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h2><pre><code class="js">//apt 安装
sudo apt install git subversion wget zsh wiznote hexo-cli guake atom rar unrar p7zip-full gshutdown
//flash
aptitude install pepperflashplugin-nonfree browser-plugin-freshplayer-pepperflash
//需要下载deb安装的软件：
brackets，mysql，jd-gui，filezilla, smartsvn, smartgit,smartsynchronize,DBeaver
</code></pre>
<h2 id="Sublime-Text-3输入中文办法"><a href="#Sublime-Text-3输入中文办法" class="headerlink" title="Sublime Text 3输入中文办法"></a>Sublime Text 3输入中文办法</h2><p>** 使用<a href="https://github.com/lyfeyaj/sublime-text-imfix">这里的方法</a> **</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>React + Redux 入坑指南</title>
    <url>/2016/08/react-redux/</url>
    <content><![CDATA[<p>React + Redux 基本入坑配置</p>
<span id="more"></span>

<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>1. 单一数据源</strong></p>
<p><code>all states ==&gt;Store</code></p>
<ul>
<li>随着组件的复杂度上升（包括交互逻辑和业务逻辑），数据来源逐渐混乱，导致组件内部数据调用十分复杂，会产生数据冗余或者混用等情况。</li>
<li>Store 的基本思想是将所有的数据集中管理，数据通过 Store 分类处理更新，不再在组件内放养式生长。</li>
</ul>
<p><strong>2. 单向数据流</strong></p>
<p><code>dispatch(actionCreator) =&gt; Reducer =&gt; (state, action) =&gt; state</code></p>
<ul>
<li>单向数据流保证了数据的变化是有迹可循且受控制的。</li>
<li>通过绑定 Store 可以确定唯一数据来源。</li>
<li>actionCreator 通过 dispatch 触发，使组件内事件调用逻辑清晰，具体的事件处理逻辑不用放在组件写，保持 view 层的纯净。</li>
<li>Reducer 通过判断不同的 actionType 处理不同数据更新，保证数据有秩序更新。</li>
</ul>
<h1 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React + Redux"></a>React + Redux</h1><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><ul>
<li>actionType 定义操作类型</li>
<li>actionCreator 定义操作具体执行函数</li>
</ul>
<h3 id="1-Action-nbsp-基础写法"><a href="#1-Action-nbsp-基础写法" class="headerlink" title="1. Action&nbsp;基础写法"></a>1. Action&nbsp;基础写法</h3><ul>
<li>actionType 提供给 Reducer 判断动作类型</li>
<li>actionCreator 为可调用的执行函数，必须返回 actionType 类型</li>
</ul>
<pre><code class="js">// actionType
export const ACTION_TYPE = &quot;ACTION_TYPE&quot;;

// actionCreator
let actionCreator = config =&gt; &#123;
  return &#123;
    type: ACTION_TYPE, // 必须定义 type
    config // 传递参数 =&gt; reducer
  &#125;;
&#125;;
</code></pre>
<h3 id="2-Action-异步解决方法"><a href="#2-Action-异步解决方法" class="headerlink" title="2. Action 异步解决方法"></a>2. Action 异步解决方法</h3><ul>
<li><a href="https://github.com/gaearon/redux-thunk?spm=5176.100239.blogcont58700.7.nE2wTr">redux-thunk</a> 中间层做数据异步转换</li>
<li><a href="https://github.com/yelouafi/redux-saga?spm=5176.100239.blogcont58700.8.nE2wTr">redux-saga</a> 使用 ES6 generator / yield</li>
</ul>
<h3 id="2-1-redux-thunk-使用方法"><a href="#2-1-redux-thunk-使用方法" class="headerlink" title="2.1 redux-thunk 使用方法"></a>2.1 redux-thunk 使用方法</h3><ul>
<li><strong>redux-thunk 配置</strong><br>redux-thunk 为独立工具，需要另外安装，通过 redux 提供的中间件 applyMiddleware ，绑定到 store 中。</li>
</ul>
<pre><code class="js">import &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;
import thunk from &quot;redux-thunk&quot;;
import reducers from &quot;../reducers&quot;;

let store = createStore(reducers, applyMiddleware(thunk));
</code></pre>
<ul>
<li><strong>Action 使用 redux-thunk</strong><br>获取数据方法在异步获取数据后需要再次调用接收方法接收数据。</li>
</ul>
<pre><code class="js">// 接收方法
let receiveSomething = res =&gt; &#123;
  return &#123;
    type: RECEIVE_SOME,
    res
  &#125;;
&#125;;

// 获取数据方法
export let fetchSomething = args =&gt; &#123;
  return dispatch =&gt; &#123;
    return fetch(args).then(res =&gt; &#123;
      return dispatch(receiveSomething(res));
    &#125;);
  &#125;;
&#125;;
</code></pre>
<h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><ul>
<li>引入 Action 中定义好的 actionType</li>
<li>传入 初始数据 和 actionType 后，返回更新数据<code>(initialState, action) =&gt; newState</code></li>
</ul>
<h3 id="Reducer-基础写法"><a href="#Reducer-基础写法" class="headerlink" title="Reducer 基础写法"></a>Reducer 基础写法</h3><h4 id="1-依据不同执行-ActionType-直接更新状态"><a href="#1-依据不同执行-ActionType-直接更新状态" class="headerlink" title="1.依据不同执行 ActionType 直接更新状态"></a>1.依据不同执行 ActionType 直接更新状态</h4><pre><code class="js">import &#123; ACTION_A, ACTION_B &#125; from &#39;../actions&#39;;

let initialState = &#123; ... &#125;

function example(state = initialState, action) &#123;
    switch(action.type) &#123;
        case ACTION_A:
          return Object.assign(&#123;&#125;, state, action.config)
        case ACTION_B:
          return Object.assign(&#123;&#125;, state, action.config)
    &#125;
&#125;
</code></pre>
<h4 id="2-对-Action-传递的数据多加一层处理"><a href="#2-对-Action-传递的数据多加一层处理" class="headerlink" title="2.对 Action 传递的数据多加一层处理"></a>2.对 Action 传递的数据多加一层处理</h4><pre><code class="js">let doSomething = config =&gt; &#123;
  let &#123; a, b &#125; = config;
  // do something with a, b
  return &#123; a, b &#125;;
&#125;;

function example(state = initialState, action) &#123;
  switch (action.type) &#123;
    case ACTION_TYPE:
      return Object.assign(&#123;&#125;, state, doSomething(action.config));
  &#125;
&#125;
</code></pre>
<h4 id="3-合并多个-Reducer"><a href="#3-合并多个-Reducer" class="headerlink" title="3.合并多个 Reducer"></a>3.合并多个 Reducer</h4><p>通过 redux 提供的 combineReducers 将不同处理逻辑的 reducer 合并起来。</p>
<pre><code class="js">import &#123; combineReducers &#125; from &#39;redux&#39;;

export default combineReducers(&#123;
  reducerA,
  reducerB
&#125;);

// or

export let reducer = (state = initialState, action) &#123;
    a: processA(state.a, action),
    b: processB(state.b, action)
&#125;
</code></pre>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><h3 id="1-将-Store-绑定-React"><a href="#1-将-Store-绑定-React" class="headerlink" title="1. 将 Store 绑定 React"></a>1. 将 Store 绑定 React</h3><p>使用 react-redux 提供的 Provider 可以将 Store 注入到 react 中。</p>
<p>Store 将合并后的 reducers 通过 createStore 创建，此外下面示例代码还使用中间件加入了一层 react-thunk 处理。</p>
<pre><code class="js">import ReactDOM from &quot;react-dom&quot;;
import &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;
import &#123; Provider &#125; from &quot;react-redux&quot;;
import thunk from &quot;redux-thunk&quot;;
import reducers from &quot;./reducers&quot;;

let store = createStore(reducers, applyMiddleware(thunk));

ReactDOM.render(
  &lt;Provider store=&#123;store&#125;&gt;// ...&lt;/Provider&gt;,
  document.querySelector(&quot;#app&quot;)
);
</code></pre>
<h3 id="2-将-state-绑定到-Component"><a href="#2-将-state-绑定到-Component" class="headerlink" title="2. 将 state 绑定到 Component"></a>2. 将 state 绑定到 Component</h3><p>使用 react-redux 提供的 connect 方法 将组件和所需数据绑定。</p>
<p><strong>需要注意的是</strong>，Store 创建时接收的是合并后的 reducers, 因此不同 reducer 上的处理数据绑定在了不同 reducer 对象上，而不是全部挂载在 Store 上。</p>
<p>mapStateToProps 将组件内部所需数据通过 props 传入组件内部。更多绑定机制，具体可参考<a href="http://cn.redux.js.org/docs/react-redux/api.html?spm=5176.100239.blogcont58700.9.nE2wTr">connect</a></p>
<pre><code class="js">import React, &#123; Component &#125; from &quot;react&quot;;
import &#123; connect &#125; from &quot;react-redux&quot;;

class ComponentA extends Component &#123;
  //...
&#125;

let mapStateToProps = state =&gt; &#123;
  // attention !!!
  let &#123; reducerA, reducerB &#125; = state;
  return &#123;
    propA: reducerA.propA,
    propB: reducerB.propB
  &#125;;
&#125;;

export default connect(mapStateToProps)(ComponentA);
</code></pre>
<h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><blockquote>
<p>React bindings for Redux embrace the idea of separating presentational and container components.</p>
<p>Redux 的 React 绑定库包含了 <strong>容器组件和展示组件相分离</strong> 的开发思想。</p>
</blockquote>
<ul>
<li>Presentational Components 展示型组件</li>
<li>Container Components 容器型组件</li>
</ul>
<p>展示型组件和容器型组件的区别在官方文档中已经给出很详细的解释了，但是中文文档的翻译有误，所以直接看英文比较更容易懂。</p>
<table>
<thead>
<tr>
<th></th>
<th>Presentational Components</th>
<th>Container Components</th>
</tr>
</thead>
<tbody><tr>
<td>Purpose</td>
<td>How things look (markup, styles)</td>
<td>How things work (data fetching, state updates)</td>
</tr>
<tr>
<td>Aware of Redux</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>To read data</td>
<td>Read data from props</td>
<td>Subscribe to Redux state</td>
</tr>
<tr>
<td>To change data</td>
<td>Invoke callbacks from props</td>
<td>Dispatch Redux actions</td>
</tr>
<tr>
<td>Are written</td>
<td>By hand</td>
<td>Usually generated by React Redux</td>
</tr>
</tbody></table>
<p>组件类型区分的模糊点在于怎么界定组件的内部功能规划。如果判定一个组件为展示型组件，那么它所需数据和处理方法都应该从父级传入，保持组件内部“纯净”。</p>
<p>在实际开发中，一个组件的逻辑跟业务紧密相关。如果需要将数据和方法从外部传入，那么父级组件所做的事情会很多，多重的子组件也会把父级逻辑弄乱，这就不是 redux 的初衷了。</p>
<p>中文文档翻译的意思是：容器组件应该为路由层面的组件，但这样既不符合实际开发需要，也违背了 redux 思想。真正界定两种组件的因素是：</p>
<ul>
<li><strong>展示型组件：</strong> 类似纯模板引擎，外加一层样式渲染，只负责渲染从 props 传进来的数据或者监听事件和父组件做小联动。它是“纯净”的，不需要使用到 Redux 的一套规则。</li>
<li><strong>容器型组件：</strong> 需要异步获取数据，更新组件状态等等。需要跟业务逻辑打交道的组件都可以认为是容器组件。这些逻辑的复杂性需要将数据整合到 Store 里统一管理。</li>
</ul>
<h3 id="2-Component-基础写法"><a href="#2-Component-基础写法" class="headerlink" title="2. Component 基础写法"></a>2. Component 基础写法</h3><ul>
<li><strong>组件渲染完成后调用 Action</strong></li>
</ul>
<p>当组件 connect 后，dispatch 方法已经注入到 props 中，所以触发 Action 可以从 props 获取 dispatch 方法。</p>
<pre><code class="js">import React, &#123; Component &#125; from &quot;react&quot;;
// actionCreator
import &#123; actionA, actionB &#125; from &quot;actions/actionA&quot;;

class ComponentA extends Component &#123;
  constructor(props) &#123;
    super(props);
  &#125;
  componentDidMount() &#123;
    let &#123; dispatch &#125; = this.props;
    dispatch(actionA());
  &#125;
&#125;
export default connect()(ComponentA);
</code></pre>
<ul>
<li><strong>组件模板内调用 Action</strong></li>
</ul>
<p>组件内部所需的渲染数据都已经绑定在了 props 上，直接获取即可。</p>
<p><strong>需要注意的是</strong>，在事件监听中触发 Action，需要用一个匿名函数封装，否则 React 在渲染时就会执行事件绑定事件，而不是当事件发生再执行。</p>
<pre><code class="js">render() &#123;
  let &#123; dispatch, propA, propB &#125; = this.props;

    return (
      &lt;section&gt;
        // Attention !!!
        &lt;input type=&quot;text&quot; onClick=&#123;(ev) =&gt; dispatch(actionB(ev))&#125; /&gt;
        &lt;p className=&#123;propA&#125;&gt;&#123;propB&#125;&lt;/p&gt;
      &lt;/section&gt;
    )
&#125;
</code></pre>
<ul>
<li><strong>容器组件传递方法</strong></li>
</ul>
<p>容器型组件需要连接 Redux，使用 dispatch 触发 actionCreator。</p>
<p>展示型组件需要用到的方法调用在容器型组件内定义好，通过 props 传入到展示型组件中。</p>
<pre><code class="js">// get actionCreator
import &#123; actionA &#125; from &quot;./actions/actionA&quot;;

class Parent extends Component &#123;
  handleCallback(data) &#123;
    // use dispatch
    let &#123; dispatch &#125; = this.props;
    dispatch(actionA(data));
  &#125;
  render() &#123;
    return &lt;Child onSomethingChange=&#123;this.handleCallback&#125; /&gt;;
  &#125;
&#125;
// connet Redux
export default connect()(Parent);
</code></pre>
<ul>
<li><strong>展示组件接收 props</strong></li>
</ul>
<p>展示型组件不需要用到 Redux 的一切，它的 props 仅仅存在于父级传入的数据和方法。</p>
<pre><code class="js">// don&#39;t need action/dispatch/connect
class Child extends Component &#123;
  handleSomething(data) &#123;
    // handle anything with props
    this.props.onSomethingChange(data);
  &#125;
  render() &#123;
    return (
      // just markup &amp; style
      &lt;input onChange=&#123;handleSomething&#125; /&gt;
    );
  &#125;
&#125;
</code></pre>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>图示箭头代表各概念之间的相互关系，不代表数据流。（ 能理解下面这张图，这篇文章就没白看了 -。- ）</p>
<p><img data-src="//img.leense.site/post/2016/08/201608080930-1.png"></p>
<p><strong>参考文档</strong></p>
<ul>
<li><a href="http://redux.js.org/?spm=5176.100239.blogcont58700.11.nE2wTr">Redux 英文文档</a></li>
<li><a href="http://cn.redux.js.org/index.html?spm=5176.100239.blogcont58700.12.nE2wTr">Redux 中文文档</a></li>
</ul>
<p>END.</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>我与JetBrains</title>
    <url>/2016/06/jetbrains-with-me/</url>
    <content><![CDATA[<p>CSDN上正在举行一个<a href="http://bss.csdn.net/m/product/jetbrains/index">JetBrains使用技能分享征集大赛</a>,正好也趁这个机会记录一下我与JetBrains的一路旅程,也算是记录一下这几年的成长历程.</p>
<span id="more"></span>
<p>能进入软件行业也完全是机缘巧合.在校学习的是电子信息专业,只接触过一点点的C语言,但也仅仅是C语言,对于其他的完全没有一点认知.虽然对C很感兴趣,却也没有深入的去学习.11年的时候刚从学校毕业,顺道说下老家是安徽的,学校在河南,毕业后跟着就业协议来到了厦门.一个普通的院校想找份工作确实不容易,最后也是逼急了有人要就直接签了.在厦门工作一路磕磕碰碰,没到一个月跟我一起过去的两个同学都想回去考研,而我也辗转到了成都.</p>
<p>又是一段艰辛的找工作之路,期间看中一家公司,连续去了三次每次都是被拒绝…后来阴错阳差进入了一家软件公司,搞起了Java,开始了这一段代码之路…</p>
<p>最开始码代码使用的是Eclipse,包括其他各种版本,EclipseEE,MyEclipse,STS.当时只知道还有个NetBeans的IDE,个人比较喜欢折腾,eclipse上安装了各种插件,加上之前的电脑配置比较差,写代码的时候一度想怒砸键盘.<br>12年的时候折腾病又犯了,突然想玩一下NetBeans.结果NetBeans没玩上却勾搭上了Idea.</p>
<p>Idea是个好东西,不过调教起来太费劲了,尤其是熟悉了Eclipse习惯的.于是各种改啊,好在idea很人性化的提供了eclipse的快捷键.每天都会在百度上找”Idea怎么像Eclipse一样XXXX”,苦于当时网上刻钟资料都比较少,有的还都很旧,在idea上只能跑跑hello world,web项目完全不知道怎么运行.想放弃又不舍得,idea的各种概念跟eclipse都不一样,只能一点一点的摸索.</p>
<p>还记得成功运行起了第一个maven项目时的激动..总算是稍微了解了一点Idea,能正常开发了.当即干掉了eclipse,完全投入了idea的怀抱,快捷键也改回默认的了,虽然还不能完全驾驭,但是起码短时调教的比较听话了.</p>
<p>Idea提供了很强大和方便的代码工具,智能提示,live templete,debuggger等等等等各种以至现在我帮别人调试代码都完全不好下手..收来接触到Sublime Text又是被那黑色主题迷倒了,Idea好像是到14的时候才提供了Dark主题,在EAP版本刚放出来就迫不及待换上了.</p>
<p>爱上了Idea就爱上了JetBrains全家桶,后来把PHPStorm,WebStorm,RubyMine,ReShaper,TeamCity都尝试了一遍,还有后来出的CLion和0xdbe(DataGrip).</p>
<p>Idea也提供了很多优质的插件,直到目前自己常用的有:</p>
<p><code>CheckStyle-IDEA</code>:代码检查工具</p>
<p><code>CodeGlance</code>:提供一个类似sublime的minimap代码地图(找了好久才找到)</p>
<p><code>EclipseFormatter</code>:统一代码风格,谁叫他们都是eclipser呢</p>
<p><code>intellij-javadocs</code>:javadoc工具</p>
<p><code>jr-ide-idea</code>:Jrebel工具</p>
<p><code>MavenRunHelper</code>:提供便捷的maven操作</p>
<p>还有很多好用的插件只是在工作中不常用就没有装上.</p>
<p>idea的社区发展的很快,网上的各种资料和教程都多了起来,很愧疚没有提供一些有价值的经验给后来者.<br>在GitHub上接触到了一个Idea的qq群 IntelliJ IDEA后端开发群.这是至今最喜欢的群,群里提供了各种学习资料,有问题在群内可以得到热心的解答.</p>
<p>最近转做前端了,Idea用的越来越少了,现在主用WebStorm.非常感谢Jetbrains提供的这一系列Ide,现在使用起来已经是得心应手了,不过idea确实还有很多不足之处需要改进的.<br>一个是编码和字体问题,非Utf-8格式的支持很差.javadoc的便利性还是稍显欠缺.内存占用也比较大.但是相对于他的优点来说这些就显得微不足道了..</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>IDEA</tag>
        <tag>JetBrains</tag>
      </tags>
  </entry>
  <entry>
    <title>10个习惯助你成为一名优秀的程序员</title>
    <url>/2016/11/10-behaviors-will-make-unstoppable-programmer/</url>
    <content><![CDATA[<p>当谈到编程时，很多人应该都有听过10x程序员的说法。 据说一个10x程序员的效率大约是其他程序员的10倍。</p>
<p>这是一个有争议的话题，无论你选择相信10x程序员，还是认为这十分可笑，下面的10个习惯可以在一定程度上助你成为一名势不可挡的优秀程序员。</p>
<span id="more"></span>

<h2 id="1、积极使用搜索工具"><a href="#1、积极使用搜索工具" class="headerlink" title="1、积极使用搜索工具"></a>1、积极使用搜索工具</h2><p>作为开发人员，你需要了解如何利用搜索解惑，查看其他人对你正在研究的主题所讨论的话题和内容，并将学到的知识应用于手头的项目。</p>
<p>当面临一个问题，优秀的程序员应该知道如何花很少时间去查验和解决手头的问题。</p>
<h2 id="2、保持初学者心态"><a href="#2、保持初学者心态" class="headerlink" title="2、保持初学者心态"></a>2、保持初学者心态</h2><p>技术发展如此之快，需要不断地学习新技术。 因此，当没有经验的时候，你需要适当地用新的视角看待事情。优秀的开发人员享受作为新技术的初学者的过程，并掌握自我教育的节奏，以尽快自给自足。</p>
<p>每个专家在某个时间点都可能是一个初学者。 而且有这么多的技术，即使在某个技术领域是专家，在另一个可能就是菜鸟。</p>
<h2 id="3、将小事做好"><a href="#3、将小事做好" class="headerlink" title="3、将小事做好"></a>3、将小事做好</h2><p>当编写程序时，它通常会让你觉得需要做出十亿个决定，即使你只是添加一个小功能。 你需要考虑诸如命名变量、调用函数、命名CSS属性、使用hash与使用数组、命名事物等等。</p>
<p>为你干的事情做好命名是编程中一个重要的部分。 这不容易， 但很重要。有开发人员还开玩笑说，在计算机科学领域有两个难题：缓存无效+命名。</p>
<p>新程序员通常不会对变量和函数命名足够重视， 普通程序员会花更多的时间去思考它，而优秀的程序员已经通过之前遇到错误和问题学到了经验。 他们找到了来帮助他们命名变量的模式，他们甚至不需要再去考虑它，因为一直沿用相同的方式命名就好。</p>
<h2 id="4、收放自如"><a href="#4、收放自如" class="headerlink" title="4、收放自如"></a>4、收放自如</h2><p>在构建应用程序的过程中，往往需要做出重大决策，这将影响你如何编写大多数代码。例如，在ruby中，你可能需要权衡MiniTest和RSpec之间的区别。 人们对于这些类型都有着强烈的自我意见和看法，因此容易引起争执。 但是优秀的开发人员想法不同，往往不太在意这些，他们重视编写、测试的习惯，他们知道你使用的具体工具其实不那么重要。</p>
<p>优秀的程序员往往不参与其他开发者的相互争执和指责中，他们更收放自如。</p>
<h2 id="5、使用正确的工具"><a href="#5、使用正确的工具" class="headerlink" title="5、使用正确的工具"></a>5、使用正确的工具</h2><p>在编程中，有许多不同的开源库、工具和框架可供使用。 优秀的程序员不断地评估他们正在使用的工具，并找出为工作选择正确工具的方法。 由于他们习惯自给自足，他们愿意承受学习新东西的痛苦，只要它们能帮其提升效率。</p>
<p>有很多的开发人员喜欢去搜索和查看相关的文档、博客文章来比较工具，并最终选择一个单一的工具。但优秀的开发人员会将他们的研究缩小到2-3个选项，并迅速将这些工具应用到他们的项目，以了解它们是如何在他们的环境中工作的。</p>
<h2 id="6、理解“code-is-cheap”"><a href="#6、理解“code-is-cheap”" class="headerlink" title="6、理解“code is cheap”"></a>6、理解“code is cheap”</h2><p>优秀的程序员往往可以产生更多的产出，因为他们不会被沉没成本误导。这些东西很容易导致人们做出不合理的行为，特别是在编写代码的时候……</p>
<p>在编码中，沉没成本的误导涉及到花费在解决某个问题上的时间。例如，考虑一个场景，其中某人开始为项目编写代码，并预计需要大约一个星期。他们根据这个预期做出决定，在完成项目一整个星期后，他们意识到它实际上需要一个月。大多数开发人员将继续他们已经开始的路径走下去，证明他们的决定，并展示已经做了一个星期的进展来进行说服自己。</p>
<p>但是优秀的开发者思考方向不同：</p>
<p>“有一种其它的方法，我认为只需要半个月就能搞定。这意味着如果采取这种方法，它将可能比我保持现在的路径一直走到底要快两倍。”</p>
<h2 id="7、使用正确的技术"><a href="#7、使用正确的技术" class="headerlink" title="7、使用正确的技术"></a>7、使用正确的技术</h2><p>一群人在屋里评估技术，然后忽略掉一个在特定技术里的大拿这种情况并不罕见。</p>
<p>例如，我非常有声望，我对 Elixir 编程语言很是看好。但是这项技术很新，如果想要实际构建复杂的功能，可能会相对其它更难找到相应的开源技术，这将提升团队构建的难度。</p>
<p>解决问题需要最实际的决定，使用的技术应该是基于它能够很容易在2016年，在目前实现。在2017年、2018年、2020年，技术可能会有所不同，那时候再根据需要进行调整。</p>
<h2 id="8、不知道就说“不知道”"><a href="#8、不知道就说“不知道”" class="headerlink" title="8、不知道就说“不知道”"></a>8、不知道就说“不知道”</h2><p>拒绝承认你不知道的东西是很容易导致浪费你时间的事情。 作为一个优秀的程序员，你要明白你的自我价值并不受那些你不懂的东西束缚。</p>
<p>初学者经常难以发现最新技术的发展趋势，优秀的开发者会意识到，他们所知道的每一种技术（编程语言，框架，库等）都可能不再是明天的可行选择。 他们会提前考虑更高级别的编程方式和问题解决方式。</p>
<h2 id="9、始终分析错误消息中提示的线索"><a href="#9、始终分析错误消息中提示的线索" class="headerlink" title="9、始终分析错误消息中提示的线索"></a>9、始终分析错误消息中提示的线索</h2><p>传统教育告诉我们，失败是不可取的。当学习代码时，错误消息通常与失败相关联。学习如何排除故障和调试错误消息是一个重要的技能。</p>
<p>还值得注意的是，开发人员可能会再次遇到类似的错误消息。你应该专注于学习如何解决问题，以及为什么你需要解决它们。这样做将允许你以更快的速度修复类似的错误。</p>
<h2 id="10、不安于目前的成功"><a href="#10、不安于目前的成功" class="headerlink" title="10、不安于目前的成功"></a>10、不安于目前的成功</h2><p>错误往往是最好的学习机会， 所以不要把错误当作失败。 相反，将他们当作可学习的机会，并评估如何防止情况下一次发生。成长的关键是理解如何使同样的错误只有一次。</p>
<p>编程，就像生活中的许多事情一样。这就是为什么这么多的行为，能帮助你做好一名优秀的程序员，也能帮你在日常生活中做一个优秀的人。</p>
<p>参考资料：<a href="http://blog.thefirehoseproject.com/posts/">http://blog.thefirehoseproject.com/posts/</a></p>
<p>文章转载自: 开源中国社区<a href="/">[http://www.oschina.net]</a></p>
<p>本文标题：10个习惯助你成为一名优秀的程序员</p>
<p>本文地址:<a href="https://www.oschina.net/news/79264/10-behaviors-will-make-unstoppable-programmer">https://www.oschina.net/news/79264/10-behaviors-will-make-unstoppable-programmer</a></p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux教程2：链接React</title>
    <url>/2016/11/redux-learn-02/</url>
    <content><![CDATA[<p>通过前面的教程，我们有了简单的环境，并且可以运行<code>Redux</code>的程序，也对 <em>如何编写Redux示例</em> 有了初步的印象；</p>
<p>掌握了 <em>使用Redux控制状态转移</em> ，继而驱动 <em>React</em> 组件发生改变，这才是学习Redux的初衷。</p>
<p>本篇我们将 Redux 和 React 联合起来，着重讲解<code>redux-react</code>模块的使用；</p>
<span id="more"></span>

<h2 id="1、编写红绿灯React组件"><a href="#1、编写红绿灯React组件" class="headerlink" title="1、编写红绿灯React组件"></a>1、编写红绿灯React组件</h2><p>在原有的基础上，我们编写红绿灯组件：</p>
<pre><code>touch components/light/index.js components/light/index.less
</code></pre>
<p>在 <em>components/light/index.js</em> 中写React代码，其结构非常简单：</p>
<pre><code class="js">import React, &#123; PropTypes, Component &#125; from &#39;react&#39;
import &#123; render &#125; from &#39;react-dom&#39;
import classnames from &#39;classnames&#39;
import &#39;./index.less&#39;

class Light extends Component&#123;
    render()&#123;
        let color = this.props.light.color;
        return(
            &lt;div className=&quot;traffic-light&quot;&gt;
                &lt;span className=&#123;classnames(&#39;light&#39;,color)&#125; /&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

Light.propTypes = &#123;
    light: PropTypes.object.isRequired
&#125;

Light.defaultProps = &#123;
    light : &#123;color:&#39;red&#39;,time:&#39;4&#39;&#125;
&#125;

export default Light
</code></pre>
<p>根据更改样式类名（’red’、’green’、’yellow’），从而移动 <em>sprite图</em> 产生灯变换的效果：</p>
<pre><code class="css">.traffic-light&#123;
  .light&#123;
    display: inline-block;
    background: url(//lh3.googleusercontent.com/-YWLqWZXDYHU/VmWC7GHoAuI/AAAAAAAACgk/nXvEmSWAhQU/s800/light.png) no-repeat 0 0;
    background-size: auto 100%;
    overflow: hidden;
    width:140px / 2;
    height:328px / 2;

    &amp;.red&#123;
      background-position: 0,0;
    &#125;
    &amp;.yellow&#123;
      background-position: -78px , 0;
    &#125;
    &amp;.green&#123;
      background-position: -156px , 0;
    &#125;
  &#125;
&#125;
</code></pre>
<p>修改 <em>components/light/demo.js</em> 文件代码为：</p>
<pre><code class="js">import React, &#123;Component, PropTypes&#125; from &#39;react&#39;
import &#123;render&#125; from &#39;react-dom&#39;
import Light from &#39;./index&#39;

var color = &#39;red&#39;;

render(
    &lt;div id=&quot;traffic&quot;&gt;
        &lt;Light color=&#123;color&#125;/&gt;
    &lt;/div&gt;,
    document.getElementById(&#39;demo&#39;)
)
</code></pre>
<p>这样就能通过 <a href="http://localhost:3000/light/demo">http://localhost:3000/light/demo</a> 预览这个组件了；</p>
<p><a href="https://gw.alicdn.com/tps/TB1Ca9FKVXXXXXQXFXXXXXXXXXX-252-245.jpg"><img data-src="https://gw.alicdn.com/tps/TB1Ca9FKVXXXXXQXFXXXXXXXXXX-252-245.jpg" alt="demo light" title="demo light"></a></p>
<h2 id="2、链接React和redux"><a href="#2、链接React和redux" class="headerlink" title="2、链接React和redux"></a>2、链接React和redux</h2><p>有了React和之前的Redux，现在就要将两者链接起来了。我们的目标是让红绿灯运行起来，就好比平时在十字路口看到的那样；</p>
<h3 id="2-1、创建示例文件"><a href="#2-1、创建示例文件" class="headerlink" title="2.1、创建示例文件"></a>2.1、创建示例文件</h3><p>再创建一个示例文件，就不叫demo了，叫做<code>redux</code>好了：</p>
<pre><code class="js">touch components/light/redux.js
</code></pre>
<blockquote>
<p>之所以示例文件名称为<code>demo.js</code>或<code>redux.js</code>，是因为我在 <em>webpack.config.js</em> 中配置了，如果想用其他的文件名，只要依样画葫芦就可以；</p>
</blockquote>
<p>首先在 <em>components/light/redux.js</em> 中输入最基本的脚手架代码，引入所需要的组件或模块：</p>
<pre><code class="js">import React, &#123;Component, PropTypes&#125; from &#39;react&#39;
import &#123;render&#125; from &#39;react-dom&#39;
import &#123; Provider, connect &#125; from &#39;react-redux&#39;
import &#123; bindActionCreators &#125; from &#39;redux&#39;
import * as LightActions from &#39;../../actions/light/&#39;
import lightStore from &#39;../../stores/light/&#39;
import Light from &#39;./index&#39;

// 声明store
let store = lightStore();
</code></pre>
<h3 id="2-2、创建容器React"><a href="#2-2、创建容器React" class="headerlink" title="2.2、创建容器React"></a>2.2、创建容器React</h3><p>继而创建一个 <em>App React类</em> ，作为总的容器，将上述的 <em>Light</em> 组件放入其中：</p>
<pre><code class="js">import React, &#123;Component, PropTypes&#125; from &#39;react&#39;
import &#123;render&#125; from &#39;react-dom&#39;
import &#123; Provider, connect &#125; from &#39;react-redux&#39;
import &#123; bindActionCreators &#125; from &#39;redux&#39;
import * as LightActions from &#39;../../actions/light/&#39;
import lightStore from &#39;../../stores/light/&#39;
import Light from &#39;./index&#39;

// 声明store
let store = lightStore();

class App extends Component&#123;
    _bind(...methods)&#123;
        methods.forEach((method)=&gt;this[method] = this[method].bind(this));
    &#125;
    constructor()&#123;
        super();
        this._bind(&#39;autoChange&#39;,&#39;handleClick&#39;);
        this.state = &#123;
            count : 0,
            timeId : null
        &#125;
    &#125;

    autoChange()&#123; // 自动更改红绿灯
        var _self = this;

        // 这里放置逻辑代码

        this.state.timeId = setTimeout(function()&#123;
            // 递归调用，实现 setInterval 方法
            _self.autoChange();
        &#125;,1000);
    &#125;
    handleClick(e)&#123;  // 用点击模拟红路灯

        if(this.state.timeId)&#123;
            clearTimeout(this.state.timeId);
            this.state.timeId = null;
        &#125; else &#123;
            this.autoChange();
        &#125;

    &#125;
    render()&#123;
        // 通过connect 注入 redux 的 dispatch 方法
        return (
            &lt;div id=&quot;traffic&quot; onClick=&#123;this.handleClick&#125;&gt;
                &lt;Light light=&#123;&#39;yellow&#39;&#125;/&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<p>上面的代码还是个半成品，看不到效果；简单描述一下上面的代码做了什么：</p>
<ul>
<li>  定义<code>App</code>容器，将 <em>Light</em> 组件放在其<code>render</code>方法中</li>
<li>   <em>constructor</em> 方法引用了 <em>_bind</em> 方法，方便一次性绑定<code>this</code>上下文，该方法来自文章<a href="http://www.newmediacampaigns.com/blog/refactoring-react-components-to-es6-classes">Refactoring React Components to ES6 Classes</a></li>
<li>   <em>handleClick</em> 方法是纯粹是为了演示，当用户点击红绿灯的时候，红绿灯调用 <em>autoChange方法</em> 开始自动变换，用户再次点击的时候就停止变换；</li>
<li>   <em>autoChange</em> 方法用于红绿灯状态自动转换的，这里占位；本质是使用<code>setTimeout</code>代替<code>setInterval</code>实现；</li>
</ul>
<h3 id="2-3、链接React组件和Redux类"><a href="#2-3、链接React组件和Redux类" class="headerlink" title="2.3、链接React组件和Redux类"></a>2.3、链接React组件和Redux类</h3><p>这是最为关键的一个步骤，</p>
<pre><code class="js">class App extends Component&#123;

    ...
&#125;

// 声明 connect 连接
// 将 redux 中的 state传给 App
function mapStateToProps(state)&#123;
    return&#123;
        light:state
    &#125;
&#125;

function mapDispatchToProps(dispatch)&#123;
    return&#123;
        actions : bindActionCreators(LightActions,dispatch)
    &#125;
&#125;

// 声明 connect 连接
App = connect(mapStateToProps,mapDispatchToProps)(App);

// 真正的连接
render(
    &lt;Provider store=&#123;store&#125;&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;,
    document.getElementById(&#39;demo&#39;)
)
</code></pre>
<p>这里使用 <em>react-redux</em> 提供<code>connect</code>的方法 <em>链接React组件和Redux类</em> ：</p>
<pre><code class="js">// 声明 connect 连接
App = connect(mapStateToProps,mapDispatchToProps)(App);
</code></pre>
<ul>
<li>   <em>connect</em> 方法不会改变原来的组件类，反而返回一个新的 <em>已与 Redux store 连接的</em> 组件类。注意这里并没有注入<code>store</code>对象，真正<code>store</code>对象的注入靠最后的<code>&lt;Provider store&gt;</code>组件；（更多说明请参考 [react-redux 的 API][1]）</li>
<li>  传入 <em>connect</em> 的 <em>mapStateToProps方法</em> ，正如其名，是将 Redux 的状态 映射到 React组件的props属性。任何时候，<strong>只要 Redux store 发生改变，mapStateToProps 函数就会被调用</strong>。这里返回对象是<code>&#123;light:state&#125;</code>，这样确保 Redux 中的 state 发生改变时，组件的 props.light 都是最新的 Redux state。</li>
<li>   <em>mapDispatchToProps方法</em> 则是将 Store 中的 dispatch方法 直接封装成对象的一个属性，一般会用到 Redux 的辅助函数<a href="http://camsong.github.io/redux-in-chinese/docs/api/bindActionCreators.html">bindActionCreators()</a>；这里将<code>dispatch</code>绑定到<code>action</code>属性，这样在红绿灯组件内让其变成红灯的时候，不需要<code>dispatch(changeRed())</code>这么调用，直接使用<code>actions.changeRed()</code>，语义化更好；（更多说明请参考 [react-redux 的 API][1]）</li>
<li>  最后的<code>&lt;Provider store&gt;</code>使组件层级中的 <em>connect()</em> 方法都能够获得 <em>Redux store</em> ，这里才真正注入<code>store</code>变量，之前的只是声明而已（之前的好比store是个形参，到了这一步store就是实参了）。（更多说明请参考 [react-redux 的 API][1]）</li>
</ul>
<p>经过上面的语句，Redux就将 <em>state属性</em> 、 （<strong>store</strong> 的）<code>dispatch方法</code>与 React 组件的 <em>props</em> 绑定在一起，凡是更改 <em>redux</em> 的 states，就会更新所连接组件的<code>props</code>属性。</p>
<blockquote>
<p> <em>react-redux</em> 中的 <em>connect</em> 方法就算是HOC（High Order Component，高阶组件）了，具体原理可参考文章<a href="http://leozdgao.me/chushi-hoc/">初识React中的High Order Component</a>，这是因为如果使用ES6 写React组件的话，mixin是不支持的，因此使用High Order Component代替；</p>
</blockquote>
<h3 id="2-4、利用redux驱动react"><a href="#2-4、利用redux驱动react" class="headerlink" title="2.4、利用redux驱动react"></a>2.4、利用redux驱动react</h3><p>理解了最为困难的部分，之后的事情就水到渠成了；</p>
<p>现在，只要记住 <em>在App中可以直接使用Redux中的一切了</em> 就行了</p>
<p>我们回过头来，完善<code>App</code>组件的代码，完善 <em>autoChange</em> 方法：</p>
<pre><code class="js">class App extends Component&#123;
    _bind(...methods)&#123;
        methods.forEach((method)=&gt;this[method] = this[method].bind(this));
    &#125;
    constructor()&#123;
        super();
        this._bind(&#39;changeColor&#39;,&#39;handleClick&#39;,&#39;autoChange&#39;);
        this.state = &#123;
            count : 0,
            timeId : null
        &#125;
    &#125;
    changeColor(light,actions)&#123; // 红路灯变换规则
        switch(light.color)&#123;
            case &#39;red&#39;:
                actions.changeGreen();
                break;
            case &#39;green&#39;:
                actions.changeYellow();
                break;
            case &#39;yellow&#39;:
                actions.changeRed();
                break;
            default:
                actions.changeRed();
        &#125;       
    &#125;
    autoChange()&#123; // 自动更改红绿灯
        const &#123; light, actions &#125; = this.props;
        let _self = this;

        let curCount = ++this.state.count;

        // console.log(&#39;xx,&#39;,curCount);
        if(this.state.count &gt; +light.time)&#123;
            curCount = 0;
            this.changeColor(light,actions);
        &#125;
        // 自动更改
        this.state.timeId = setTimeout(function()&#123;
            _self.setState(&#123;count:curCount&#125;);
            _self.autoChange();
        &#125;,1000);

    &#125;
    handleClick(e)&#123;  // 用点击模拟红路灯

        if(this.state.timeId)&#123;
            clearTimeout(this.state.timeId);
        &#125; else &#123;
            this.autoChange();
        &#125;

    &#125;
    render()&#123;
        // 通过connect 注入 redux 的 dispatch 方法
        const &#123; light, actions &#125; = this.props;
        return (
            &lt;div id=&quot;traffic&quot; onClick=&#123;this.handleClick.bind(this)&#125;&gt;
                &lt;Light light=&#123;light&#125;/&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<p>至此已经完成本节示例，通过<code>npm start</code>开启服务， 在 <a href="http://localhost:3000/light/redux">http://localhost:3000/light/redux</a> 中查看。</p>
<p>在这个示例里，通过点击红绿灯，每隔若干秒红绿灯就会变换颜色，这说明两者已经链接起来；</p>
<p><a href="https://gw.alicdn.com/tps/TB1uaysKVXXXXXiaXXXXXXXXXXX-320-188.gif"><img data-src="https://gw.alicdn.com/tps/TB1uaysKVXXXXXiaXXXXXXXXXXX-320-188.gif" alt="demo light" title="demo light"></a></p>
<p>（这个是gif图，如果没动画请点击在新窗口打开）</p>
<p>在后一篇文章，将示例如何处理多个Redux、React的情形；</p>
<p>[1]<a href="http://camsong.github.io/redux-in-chinese/docs/react-redux/api.html">http://camsong.github.io/redux-in-chinese/docs/react-redux/api.html</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>提升你的开发效率，10 个 NPM 使用技巧</title>
    <url>/2016/11/npm-tips-and-tricks/</url>
    <content><![CDATA[<p>对于一个项目，常用的一些npm简单命令包含的功能有：初始化一个文件夹(<a href="https://docs.npmjs.com/cli/init">npm init</a>)，下载npm模块(<a href="https://docs.npmjs.com/cli/install">npm install</a>)，创建测试(<a href="https://docs.npmjs.com/cli/test">npm test</a>) 和自定义脚本(<a href="https://docs.npmjs.com/cli/run-script">npm run</a>)。但是，进一步了解一些 npm 的使用技巧可以彻底改变你的日常开发任务。</p>
<span id="more"></span>

<p><strong>注:</strong><br> 如果你需要关于初学npm的参考，可以参阅我们的<br><a href="https://www.sitepoint.com/beginners-guide-node-package-manager/">初学者指南</a><br>。如果你对 npm 和 Yarn 之间的差异感到困扰，可以参阅我们发表的文章：<br><a href="https://www.sitepoint.com/yarn-vs-npm/">Yarn vs npm:你需要知道的一切</a></p>
<h2 id="1-获取帮助"><a href="#1-获取帮助" class="headerlink" title="1. 获取帮助"></a>1. 获取帮助</h2><p><a href="https://docs.npmjs.com/">npm 文档</a> 和 <a href="https://docs.npmjs.com/#cli">CLI 命令行文档</a> 是非常不错地的学习资料，但需要通过浏览器访问，这并不是很方便。因而可以通过命令行快速获取所有可选项：</p>
<pre><code class="js">npm help
</code></pre>
<p>此外，还能获取特定 npm 命令的使用帮助：</p>
<pre><code class="js">npm help &lt;command&gt;
</code></pre>
<p>例如：<code>npm help install</code></p>
<p>另一种方式是通过下面的命令：</p>
<pre><code class="js">npm &lt;command&gt; -h
</code></pre>
<h2 id="2-npm-命令自动完成"><a href="#2-npm-命令自动完成" class="headerlink" title="2. npm 命令自动完成"></a>2. npm 命令自动完成</h2><p>npm 通过bash提供了命令自动完成功能(包括<a href="https://msdn.microsoft.com/en-us/commandline/wsl/about?f=255&MSPPError=-2147217396"> Bash for Windows 10</a> ):</p>
<pre><code class="js">npm completion &gt;&gt; ~/.bashrc

//or Z shell

npm completion &gt;&gt; ~/.zshrc
</code></pre>
<p>重新加载shell配置文件：</p>
<pre><code class="js">source ~/.bashrc
</code></pre>
<p>现在，在终端注入 <code>npm ins</code> ，然后按下 <code>tab</code> 键就会出现 <code>install</code> 了，不会再浪费时间去全部输入了。</p>
<h2 id="3-修复全局模块的权限"><a href="#3-修复全局模块的权限" class="headerlink" title="3.修复全局模块的权限"></a>3.修复全局模块的权限</h2><p>当你试图安装全部模块时，类 Linux 系统可能会抛出权限错误，可以在npm命令之前添加 sudo 来执行，但这是一个较危险的选择。一个更高的解决方式是改变 npm 默认的模块安装目录：</p>
<pre><code class="js">mkdir ~/.npm-global
npm config set prefix &#39;~/.npm-global&#39;
</code></pre>
<p>使用适当的文本编辑器将下面的一行添加到 <code>~/.bashrc</code> 或者 <code>~/.zshrc</code> 文件中：</p>
<pre><code class="js">export PATH=&quot;$HOME/.npm-global/bin:$PATH&quot;
</code></pre>
<p>重新加载配置文件(<code>source ~/.bashrc</code>)，然后重新安装npm到用户所属路径：</p>
<pre><code class="js">npm install -g npm
</code></pre>
<p>这也会更新npm。</p>
<h2 id="4-持续更新npm"><a href="#4-持续更新npm" class="headerlink" title="4.持续更新npm"></a>4.持续更新npm</h2><p>你可以通过下面的命令显示npm当前的版本：</p>
<pre><code class="js">npm -v
</code></pre>
<p>如果有需要，可以通过下面的命令更新npm：</p>
<pre><code class="js">npm install -g npm
</code></pre>
<p>当 Node 的主版本 released 之后，你也可能需要重新构建 C++ 扩展：</p>
<pre><code class="js">npm rebuild
</code></pre>
<p>如果你需要管理多个版本的node.js和npm，可以考虑使用 <a href="https://github.com/tj/n">n</a> 或者 <a href="https://github.com/creationix/nvm">nvm</a>。这有一篇关于 nvm 的文章：<a href="https://www.sitepoint.com/quick-tip-multiple-versions-node-nvm/">使用 nvm 安装多版本的Node.js</a></p>
<h2 id="5-定义默认的-npm-init"><a href="#5-定义默认的-npm-init" class="headerlink" title="5.定义默认的 npm init"></a>5.定义默认的 npm init</h2><p>使用 <code>npm init</code> 初始化一个新的项目，这会提示你关于项目的更多细节，并创建一个 <code>package.json</code> 文件。</p>
<p>如果你厌倦了每次开始一个新的项目都需要重新输入同样的信息，可以使用 <code>-y</code> 标记表示你能接受 <code>package.json</code> 文件的一堆默认值：</p>
<pre><code class="js">npm init -y
</code></pre>
<p>或者你可以设置一些语义化的默认值：</p>
<pre><code class="js">npm config set init.author.name &lt;name&gt;
npm config set init.author.email &lt;email&gt;
</code></pre>
<h2 id="6-更精准的模块搜索"><a href="#6-更精准的模块搜索" class="headerlink" title="6.更精准的模块搜索"></a>6.更精准的模块搜索</h2><p>到目前为止，npm上已经有超过350000个模块了，并且每天还在持续增长。尽管有很多非常棒的模块，但是你还是想避免使用一些不受欢迎的、存在bug的或者无人维护的模块。</p>
<p>在<a href="https://www.npmjs.com/">npmjs</a> 和<a href="https://github.com/">Github</a> 上搜索npm模块是很实用但这还有一些其它选择：</p>
<h3 id="npms"><a href="#npms" class="headerlink" title="npms"></a>npms</h3><p> <a href="https://npms.io/">npms</a><br> 根据一个基于项目版本、模块下载次数、最新更新日期、提交频率、测试覆盖率、文档、贡献者数量、issues数、star数、forks数和作者在社区的地位的综合测量分数进行模块排名。</p>
<h3 id="npm-Discover"><a href="#npm-Discover" class="headerlink" title="npm Discover"></a>npm Discover</h3><p> <a href="http://www.npmdiscover.com/">npm Discover</a><br> 定位于快速搜索和其它模块通常一起使用的模块，如<br><a href="https://www.npmjs.com/package/body-parser">body-parser</a><br> 通常和Express一起使用。</p>
<h3 id="Packages-by-PageRank"><a href="#Packages-by-PageRank" class="headerlink" title="Packages by PageRank"></a>Packages by PageRank</h3><p> <a href="http://anvaka.github.io/npmrank/online/">Packages by PageRank</a><br> 按照模块的谷歌排名进行搜索和排序。</p>
<h3 id="Curated-npm-Lists"><a href="#Curated-npm-Lists" class="headerlink" title="Curated npm Lists"></a>Curated npm Lists</h3><p> 还一个选择就是利用别人的搜索结果。当需要一个健壮的解决方案时，我经常会参考<br><a href="https://twitter.com/sindresorhus">sindresorhus</a>的<a href="https://github.com/sindresorhus/awesome-nodejs">Awesome Node.js</a>。</p>
<h2 id="7-管理你的模块"><a href="#7-管理你的模块" class="headerlink" title="7.管理你的模块"></a>7.管理你的模块</h2><p>你已经安装了一些模块，看看都有啥：</p>
<pre><code class="js">npm list
</code></pre>
<p>(ls、la &amp; ll 可以用作 list 的别名)</p>
<p>该命令会显示所有模块：(安装的)模块，子模块以及子模块的子模块等。可以限制输出的模块层级：</p>
<pre><code class="js">npm list --depth=0
</code></pre>
<p>打开一个模块的主页：</p>
<pre><code class="js">npm home &lt;package&gt;
</code></pre>
<p>这只有在你的系统能打开浏览器时有用–在服务端的系统上会失败。同样，可以打开一个模块的 Github 仓库：</p>
<pre><code class="js">npm repo &lt;package&gt;
</code></pre>
<p>或者它的文档：</p>
<pre><code class="js">npm docs &lt;package&gt;
</code></pre>
<p>或者它目前的bugs列表：</p>
<pre><code class="js">npm bugs &lt;package&gt;
</code></pre>
<p>npm list 会显示和你已经安装地模块的关联模块—这些没有在 package.json文件中被引用。你可以单独 npm uninstall 每一个模块或者全部移除它们：</p>
<pre><code class="js">npm prune
</code></pre>
<p>如果安装模块时你添加了 <code>--production</code> 标记或者 <code>NODE_ENV</code> 被设置成 <code>productio</code>n，package.json 文件中被指定为 <code>devDependencies</code> 的模块也会被移除。</p>
<h2 id="8-锁定依赖"><a href="#8-锁定依赖" class="headerlink" title="8.锁定依赖"></a>8.锁定依赖</h2><p>默认情况下，当用 –save/-S 或者 –save-dev/-D 安装一个模块时，npm 通过脱字符(^)来限定所安装模块的主版本号。例如，当运行 npm update 时， ^1.5.1 允许安装版本号大于 1.5.1 但小于 2.0.0 版本的模块。</p>
<p>波浪号(<del>)字符是限定模块的次要版本。例如，当运行 npm update 时， ~1.5.1 允许安装版本号大于 1.5.1但小于 1.6.0 版本的模块。可以将需要安装的模块版本前缀默认设置成波浪号(</del>):</p>
<pre><code class="js">npm config set save-prefix=&quot;~&quot;
</code></pre>
<p>对于那些偏执的认为任何更新(模块的行为)会破坏系统的人，可以配置npm仅安装精确版本号的模块：</p>
<pre><code class="js">npm config set save-exact true
</code></pre>
<p>另一个选择是，可以在项目中使用 shrinkwrap:</p>
<pre><code class="js">npm shrinkwrap
</code></pre>
<p>这会生成一个 shrinkwrap.json 文件，该文件包含了你正在使用的模块的指定版本。当运行 npm install时，该文件所指定的模块版本会覆盖 package.json 文件中所指定的版本。</p>
<h2 id="9-找出过时的模块"><a href="#9-找出过时的模块" class="headerlink" title="9. 找出过时的模块"></a>9. 找出过时的模块</h2><p>怎么知道一个模块已经更新了呢？我之前的方式是先列举出项目所依赖的模块(npm list –depth=0)，然后在 npmjs.com 上找到该模块，手动检查该模块的版本是否已经更新。这非常费时。幸运的是，有一个更简单的方式：</p>
<pre><code class="js">npm outdated
</code></pre>
<p>或者 npm outdated -g 来查找全局模块。</p>
<p>你也可以查看一个独立模块的当前版本：</p>
<pre><code class="js">npm list &lt;package&gt;
</code></pre>
<p>也可以查看检验当前和历史版本：</p>
<pre><code class="js">npm view &lt;package&gt; versions
</code></pre>
<p><code>npm view &lt;package&gt;</code> 会显示一个独立模块的所有信息，包括它的依赖、关键字、更新日期、贡献者、仓库地址和许可证等。</p>
<h2 id="10-使用开发中的模块"><a href="#10-使用开发中的模块" class="headerlink" title="10.使用开发中的模块"></a>10.使用开发中的模块</h2><p>当你正在开发一个模块时，会经常想在其它项目中尝试使用或者在任何一个目录运行它(如果你的应用支持)，这时没必要将其发布到 npm，并全局安装—仅需在该模块所在目录使用下面的命令：</p>
<pre><code class="js">npn link
</code></pre>
<p>该命令会为模块在全局目录下创建一个符号链接。可以通过下面的命令查看模块引用：</p>
<pre><code class="js">npm list -g --depth=0
</code></pre>
<p>或者：</p>
<pre><code class="js">npm outdated -g
</code></pre>
<p>现在，就可以从命令行运行模块或者通过 require 在任何项目中引入该模块。</p>
<p>另一个选择是，可以通过文件路径在 package.json 文件中声明对该模块的依赖：</p>
<pre><code class="js">&quot;dependencies&quot;: &#123;
  &quot;myproject&quot;: &quot;file:../myproject/&quot;
&#125;
</code></pre>
<p>原文：[10 Tips and Tricks That Will Make You an npm Ninja](<a href="http://0.0.0.10/">http://10</a> Tips and Tricks That Will Make You an npm Ninja)</p>
<p>编译：<a href="https://github.com/dwqs/blog/issues/40?hmsr=">10个 NPM 使用技巧</a><br>译者：<a href="https://github.com/dwqs">dwqs</a></p>
<p>文章转载自: 开源中国社区<a href="/">[http://www.oschina.net]</a></p>
<p>本文标题：提升你的开发效率，10 个 NPM 使用技巧</p>
<p>本文地址:<a href="https://www.oschina.net/news/79226/10-tips-and-tricks-that-will-make-you-an-npm-ninja">https://www.oschina.net/news/79226/10-tips-and-tricks-that-will-make-you-an-npm-ninja</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>npm</tag>
        <tag>npmjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux教程3：添加倒计时</title>
    <url>/2016/11/redux-learn-03/</url>
    <content><![CDATA[<p>前面的教程里面，我们搭建了一个简单红绿灯示例，通过在console输出当面的倒计时时间；由于界面上不能显示倒计时，用户体验并不良好，本节我们就添加一个简单的倒计时改善一下。</p>
<p>作为本系列的最后一篇文章，将示例如何处理多个Redux、React的情形；</p>
<span id="more"></span>

<h2 id="1、创建Counter类"><a href="#1、创建Counter类" class="headerlink" title="1、创建Counter类"></a>1、创建Counter类</h2><p>我们定义倒计时的类名为 <em>Counter</em> ，创建所需要的文件（夹）：</p>
<pre><code class="js">mkdir actions/counter reducers/counter stores/counter components/counter views/counter

touch constants/Counter.js actions/counter/index.js reducers/counter/index.js stores/counter/index.js components/counter/index.js components/counter/redux.js components/counter/index.less  components/counter/demo.js views/counter/index.hbs
</code></pre>
<p>创建 <em>Counter</em> 的 Redux 和 React 组件的过程就相当于重复了一下之前两篇文章的过程，代码也不复杂，我这边也就不粘贴了。可自行参考代码，代码托管在 <a href="https://github.com/boycgit/demos/tree/master/traffic">https://github.com/boycgit/demos/tree/master/traffic</a> </p>
<p>可以通过 <a href="http://localhost:3000/counter/redux">http://localhost:3000/counter/redux</a> 检验是否正常运行；</p>
<p><a href="https://gw.alicdn.com/tps/TB1iUuTKVXXXXXyXXXXXXXXXXXX-248-316.gif"><img data-src="https://gw.alicdn.com/tps/TB1iUuTKVXXXXXyXXXXXXXXXXXX-248-316.gif" alt="预览效果" title="gif"></a></p>
<p>（这个是gif图，如果没动画请点击在新窗口打开）</p>
<p>在假设用户已经编写上面的代码文件的基础上，我们继续讲解如何将 <em>Counter</em> 和 <em>Light</em> 两个组件联合起来。</p>
<h2 id="2、创建入口文件"><a href="#2、创建入口文件" class="headerlink" title="2、创建入口文件"></a>2、创建入口文件</h2><p>Redux的三个原则之一 ： <em>单一store，单一reducer</em> 。我们创建两个文件，分别整合之前所写的 reducer 和 store 。</p>
<h3 id="2-1、reducer入口文件"><a href="#2-1、reducer入口文件" class="headerlink" title="2.1、reducer入口文件"></a>2.1、reducer入口文件</h3><p>创建<code>reducers/traffic.js</code>文件，作为 <em>主reducer</em> 入口文件：</p>
<pre><code class="js">import &#123; combineReducers &#125; from &#39;redux&#39;
import light from &#39;./light/&#39;
import count from &#39;./counter/&#39;

const rootReducer = combineReducers(&#123;
    light,
    count
&#125;);

export default rootReducer
</code></pre>
<p>这里包含了最佳实践法则， <em>将不同的状态转移关系写进不同的js文件，最后汇总到 index.js 中（这里名为traffic.js，地位是一样的）</em> ，比如后期如果多出一种 “汽车的状态转移” 关系，只要新建对应的js文件，然后再在index.js中的<code>combineReducers</code>函数中多添加一行配置即可；</p>
<blockquote>
<p>详细的概念及作用请参考Redux的中文文档<a href="http://camsong.github.io/redux-in-chinese/docs/basics/Reducers.html">Reducer</a></p>
</blockquote>
<h3 id="2-2、store入口文件"><a href="#2-2、store入口文件" class="headerlink" title="2.2、store入口文件"></a>2.2、store入口文件</h3><p>创建<code>stores/traffic.js</code>文件，作为 <em>主store</em> 入口文件：</p>
<pre><code class="js">import &#123; createStore &#125; from &#39;redux&#39;
import rootReducer from &#39;../reducers/traffic&#39;

export default function trafficStore(initState)&#123;
    return createStore(rootReducer,initState);
&#125;
</code></pre>
<p>可以看到并没有什么工作量，只是多了几行代码而已；</p>
<h2 id="3、创建应用"><a href="#3、创建应用" class="headerlink" title="3、创建应用"></a>3、创建应用</h2><p>前面创建的 <em>Counter</em> 和 <em>Light</em> 算是组件，将两者结合起来，可以视作一款小应用了（假设应用名为<code>traffic</code>）；</p>
<p>为了方便管理，专门创建 <em>App</em> 文件夹来存放应用，并创建应用相关的等辅助内容（比如视图等）：</p>
<pre><code class="js">mkdir app app/traffic views/app

touch app/traffic/index.js app/traffic/index.less views/app/index.hbs views/app/traffic.hbs
</code></pre>
<p>核心是 <em>app/traffic/index.js</em> 文件，其余文件只是其辅助作用，这边也不重点讲解，可自行到git clone后查看；</p>
<h3 id="3-1、初始化"><a href="#3-1、初始化" class="headerlink" title="3.1、初始化"></a>3.1、初始化</h3><p>在 <em>app/traffic/index.js</em> 中引入 <em>Counter</em> 和 <em>Light</em> 组件并设置初始化值：</p>
<pre><code class="js">import React, &#123;Component, PropTypes&#125; from &#39;react&#39;
import &#123;render&#125; from &#39;react-dom&#39;
import &#123; Provider, connect &#125; from &#39;react-redux&#39;
import &#123; bindActionCreators &#125; from &#39;redux&#39;
import * as LightActions from &#39;../../actions/light/&#39;
import * as CounterActions from &#39;../../actions/counter/&#39;
import Light from &#39;../../components/light/&#39;
import Counter from &#39;../../components/counter/&#39;
import trafficStore from &#39;../../stores/traffic&#39;

// 初始化状态
let initLight = &#123;
    light:&#123;
        color:&#39;green&#39;,
        time:&#39;5&#39;
    &#125;
&#125;
let initCount = &#123;
    count:&#123;
        num : parseInt(initLight.light.time)
    &#125;
&#125;
let initState = Object.assign(&#123;&#125;,initLight,initCount);

// 声明store
let store = trafficStore(initState);
</code></pre>
<ul>
<li>  初始化的时候，我们从绿灯开始；</li>
<li>  倒计时的时间来自于 <em>initLight.light.time</em> ，这样在初始化状态的时候关联起来两个组件</li>
<li>  将两个组件的状态（initLight,initCount）合并成 <em>initState</em> ，传给应用的 store，以完成 <em>应用store的初始化</em></li>
</ul>
<h3 id="3-2、创建React组件，并链接到Redux"><a href="#3-2、创建React组件，并链接到Redux" class="headerlink" title="3.2、创建React组件，并链接到Redux"></a>3.2、创建React组件，并链接到Redux</h3><p>紧接着，使用 <em>connect</em> 方法链接 Redux 和 React组件：</p>
<pre><code class="js">class App extends Component&#123;
    // 占位
&#125;

// 声明 connect 连接
// 将 redux 中的 state传给 App
function mapStateToProps(state)&#123;
    return&#123;
        light:state.light,
        count:state.count
    &#125;
&#125;

// 绑定多个actions
function mapDispatchToProps(dispatch)&#123;
    let boundLight = bindActionCreators(LightActions,dispatch);
    let boundCount = bindActionCreators(CounterActions,dispatch);
    return&#123;
        actions : Object.assign(&#123;&#125;,boundLight,boundCount)
    &#125;
&#125;

// 声明 connect 连接
App = connect(mapStateToProps,mapDispatchToProps)(App);

// 真正的连接
render(
    &lt;Provider store=&#123;store&#125;&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;,
    document.getElementById(&#39;demo&#39;)
)
</code></pre>
<p>形式和上篇提到的类似，细节略微有些不同：</p>
<ul>
<li>   <em>mapStateToProps</em> 中返回的对象有两个属性 <em>light</em> 和 <em>count</em> ，在React组件中 对应 this.props.light 、 this.props.count</li>
<li>   <em>mapDispatchToProps</em> 中现将两个组件的方法先和<code>dispatch</code>绑定，合成一个对象之后再赋值，这样在React组件中使用 <em>this.props.actions</em> 可以调用这两个组件的所有的actions创造函数；</li>
<li>  最后使用<code>&amp;lt;Provider&amp;gt;</code>注入 store 实例；</li>
</ul>
<h3 id="3-3、完善App组件内容"><a href="#3-3、完善App组件内容" class="headerlink" title="3.3、完善App组件内容"></a>3.3、完善App组件内容</h3><p>最后，绑定store之后完善 <em>App类</em> 的代码，大部分的逻辑和前一篇的类似：</p>
<pre><code class="js">class App extends Component&#123;
    _bind(...methods)&#123;
        methods.forEach((method)=&gt;this[method] = this[method].bind(this));
    &#125;
    constructor()&#123;
        super();
        this._bind(&#39;changeColor&#39;,&#39;handleClick&#39;,&#39;autoChange&#39;);
        this.state = &#123;
            timeId : null
        &#125;
    &#125;
    changeColor(light,actions)&#123; // 红路灯变换规则
        switch(light.color)&#123;
            case &#39;red&#39;:
                actions.changeGreen();
                break;
            case &#39;green&#39;:
                actions.changeYellow();
                break;
            case &#39;yellow&#39;:
                actions.changeRed();
                break;
            default:
                actions.changeRed();
        &#125;       
    &#125;
    autoChange()&#123; // 自动更改红绿灯
        const &#123; light,count, actions &#125; = this.props;

        let _self = this;

        actions.countDown();

        let curState = store.getState();
        if(curState.count.num &lt; 1)&#123;
            this.changeColor(light,actions);
            curState = store.getState();
            actions.countInit(parseInt(curState.light.time));
        &#125;
        // 自动更改
        this.state.timeId = setTimeout(function()&#123;
            _self.autoChange();
        &#125;,1000);

    &#125;
    handleClick(e)&#123;  // 用点击模拟红路灯
        if(this.state.timeId)&#123;
            clearTimeout(this.state.timeId);
            this.state.timeId = null;
        &#125; else &#123;
            this.autoChange();
        &#125;

    &#125;
    render()&#123;
        // 通过connect 注入 redux 的 dispatch 方法
        const &#123; light,count, actions &#125; = this.props;

        return (
            &lt;div id=&quot;traffic&quot; onClick=&#123;this.handleClick&#125;&gt;
                &lt;Light light=&#123;light&#125;/&gt;
                &lt;Counter num=&#123;count.num&#125;/&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;

// 声明 connect 连接
</code></pre>
<p>变换的逻辑都在 <em>autoChange</em> 方法中</p>
<ul>
<li>  使用 <em>actions.countDown();</em> 让倒计时减1，通过 <em>store.getState();</em> 获取更新后的状态，因为如果直接使用 <em>count.num</em> 获取的是 <em>更新之前</em> 的状态；</li>
<li>  当 <em>curState.count.num</em> 小于 0 的时候，调用 <em>this.changeColor(light,actions);</em> 更改红绿等的颜色，同时将 新的红绿灯的time值初始化 Counter 组件，这样就完成了两者的绑定</li>
</ul>
<h3 id="3-4、预览效果"><a href="#3-4、预览效果" class="headerlink" title="3.4、预览效果"></a>3.4、预览效果</h3><p>在 <a href="http://localhost:3000/app/traffic">http://localhost:3000/app/traffic</a> 中查看效果，效果正如此系列文章第一篇开头所展示的那样，红绿灯搭配倒计时运行：</p>
<p><a href="https://gw.alicdn.com/tps/TB1HYmUKVXXXXXhXXXXXXXXXXXX-224-316.gif"><img data-src="https://gw.alicdn.com/tps/TB1HYmUKVXXXXXhXXXXXXXXXXXX-224-316.gif" alt="预览效果" title="result"></a></p>
<p>（这个是gif图，如果没动画请点击在新窗口打开）</p>
<p>红绿灯初始状态是 <em>绿灯5s</em> ，继而循环 <em>黄灯3s</em> -&gt; <em>红灯7s</em> -&gt; <em>绿灯5s</em> -&gt; <em>黄灯3s</em> -&gt; …</p>
<p>就这样， <em>Counter</em> 和 <em>Light</em> 融洽地结合起来，完美，happy ending~</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>到这里，Redux 的入门教程算是完结；整个过程下来，你可以体会得到，React只需要关注逐渐的展示就行了，所有状态的管理交由<code>redux</code>即可，这种绑定恰好体现了<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">容器组件和展示组件相分离</a>的开发思想： <em>只在最顶层组件（如路由操作）里使用 Redux；内部组件应该像木偶一样保持“呆滞”，所有数据都通过 props 传入</em> 。</p>
<p>这里需要再强调一下：Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解 JavaScript 中的 for 循环</title>
    <url>/2016/12/javascript-for-loop/</url>
    <content><![CDATA[<p>在<a href="https://link.zhihu.com/?target=http://ecma-international.org/ecma-262/5.1/">ECMAScript5（简称 ES5）</a>中，有三种 for 循环，分别是：</p>
<ul>
<li>  简单for循环</li>
<li>  for-in</li>
<li>  forEach</li>
</ul>
<p>在2015年6月份发布的<a href="https://link.zhihu.com/?target=https://people.mozilla.org/~jorendorff/es6-draft.html">ECMAScript6（简称 ES6）</a>中，新增了一种循环，是：</p>
<ul>
<li>  for-of</li>
</ul>
<p>下面我们就来看看这 4 种 for 循环。</p>
<span id="more"></span>

<h2 id="简单-for-循环"><a href="#简单-for-循环" class="headerlink" title="简单 for 循环"></a>简单 for 循环</h2><p>下面先来看看大家最常见的一种写法：</p>
<pre><code class="js">const arr = [1, 2, 3];
for(let i = 0; i　&lt; arr.length; i++) &#123;
    console.log(arr[i]);
&#125;
</code></pre>
<p>当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率，下面是改进的写法：</p>
<pre><code class="js">const arr = [1, 2, 3];
for(let i = 0, len = arr.length; i &lt; len; i++) &#123;
    console.log(arr[i]);
&#125;
</code></pre>
<h2 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h2><p>通常情况下，我们可以用 for-in 来遍历一遍数组的内容，代码如下：</p>
<pre><code class="js">const arr = [1, 2, 3];
let index;
for(index in arr) &#123;
    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);
&#125;
</code></pre>
<p>一般情况下，运行结果如下：</p>
<pre><code class="js">arr[0] = 1
arr[1] = 2
arr[2] = 3
</code></pre>
<p>但这么做往往会出现问题。</p>
<p><strong>for-in 的真相</strong></p>
<p>for-in 循环遍历的是对象的属性，而不是数组的索引。因此， for-in 遍历的对象便不局限于数组，还可以遍历对象。例子如下：</p>
<pre><code class="js">const person = &#123;
    fname: &quot;san&quot;,
    lname: &quot;zhang&quot;,
    age: 99
&#125;;
let info;
for(info in person) &#123;
    console.log(&quot;person[&quot; + info + &quot;] = &quot; + person[info]);
&#125;
</code></pre>
<p>结果如下：</p>
<pre><code class="js">person[fname] = san
person[lname] = zhang
person[age] = 99
</code></pre>
<p>需要注意的是， for-in 遍历属性的顺序并不确定，即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。</p>
<p><strong>Array 的真相</strong></p>
<p>Array 在 Javascript 中是一个对象， Array 的索引是属性名。事实上， Javascript 中的 “array” 有些误导性， Javascript 中的 Array 并不像大部分其他语言的数组。首先， Javascript 中的 Array 在内存上并不连续，其次， Array 的索引并不是指偏移量。实际上， Array 的索引也不是 Number 类型，而是 String 类型的。我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0″ 。所以，在 Javascript 中从来就没有 Array 的索引，而只有类似 “0″ 、 “1″ 等等的属性。有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。</p>
<p>现在，我们再回过头来看看用 for-in 来循环数组的例子,我们修改一下前面遍历数组的例子：</p>
<pre><code class="js">const arr = [1, 2, 3];
arr.name = &quot;Hello world&quot;;
let index;
for(index in arr) &#123;
    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);
&#125;
</code></pre>
<p>运行结果是：</p>
<pre><code class="js">arr[0] = 1
arr[1] = 2
arr[2] = 3
arr[name] = Hello world
</code></pre>
<p>我们看到 for-in 循环访问了我们新增的 “name” 属性，因为 for-in 遍历了对象的所有属性，而不仅仅是“索引”。同时需要注意的是，此处输出的索引值，即 “0″、 “1″、 “2″不是 Number 类型的，而是 String 类型的，因为其就是作为属性输出，而不是索引。那是不是说不在我们的 Array 对象中添加新的属性，我们就可以只输出数组中的内容了呢？答案是否定的。因为 for-in 不仅仅遍历 array 自身的属性，其还遍历 array 原型链上的所有可枚举的属性。下面我们看个例子：</p>
<pre><code class="js">Array.prototype.fatherName = &quot;Father&quot;;
const arr = [1, 2, 3];
arr.name = &quot;Hello world&quot;;
let index;
for(index in arr) &#123;
    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);
&#125;
</code></pre>
<p>运行结果是：</p>
<pre><code class="js">arr[0] = 1
arr[1] = 2
arr[2] = 3
arr[name] = Hello world
arr[fatherName] = Father
</code></pre>
<p>写到这里，我们可以发现 for-in 并不适合用来遍历 Array 中的元素，其更适合遍历对象中的属性，这也是其被创造出来的初衷。却有一种情况例外，就是稀疏数组。考虑下面的例子：</p>
<pre><code class="js">let key;
const arr = [];
arr[0] = &quot;a&quot;;
arr[100] = &quot;b&quot;;
arr[10000] = &quot;c&quot;;
for(key in arr) &#123;
    if(arr.hasOwnProperty(key)  &amp;&amp;    
        /^0$|^[1-9]\d*$/.test(key) &amp;&amp;    
        key &lt;= 4294967294               
        ) &#123;
        console.log(arr[key]);
    &#125;
&#125;
</code></pre>
<p>for-in 只会遍历存在的实体，上面的例子中， for-in 遍历了3次（遍历属性分别为”0″、 “100″、 “10000″的元素，普通 for 循环则会遍历 10001 次）。所以，只要处理得当， for-in 在遍历 Array 中元素也能发挥巨大作用。</p>
<p>为了避免重复劳动，我们可以包装一下上面的代码：</p>
<pre><code class="js">function arrayHasOwnIndex(array, prop) &#123;
    return array.hasOwnProperty(prop) &amp;&amp;
        /^0$|^[1-9]\d*$/.test(prop) &amp;&amp;
        prop &lt;= 4294967294; // 2^32 - 2
&#125;
</code></pre>
<p>使用示例如下：</p>
<pre><code class="js">for (let key in arr) &#123;
    if (arrayHasOwnIndex(arr, key)) &#123;
        console.log(arr[key]);
    &#125;
&#125;
</code></pre>
<p><strong>for-in 性能</strong></p>
<p>正如上面所说，每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢，一般速度为其他类型循环的 1/7。因此，除非明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快，比如下面的例子：</p>
<pre><code class="js">const obj = &#123;
    &quot;prop1&quot;: &quot;value1&quot;,
    &quot;prop2&quot;: &quot;value2&quot;
&#125;;

const props = [&quot;prop1&quot;, &quot;prop2&quot;];
for(let i = 0; i &lt; props.length; i++) &#123;
    console.log(obj[props[i]]);
&#125;
</code></pre>
<p>上面代码中，将对象的属性都存入一个数组中，相对于 <code>for-in</code> 查找每一个属性，该代码只关注给定的属性，节省了循环的开销和时间。</p>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>在 ES5 中，引入了新的循环，即 forEach 循环。</p>
<pre><code class="js">const arr = [1, 2, 3];
arr.forEach((data) =&gt; &#123;
    console.log(data);
&#125;);
</code></pre>
<p>运行结果：</p>
<pre><code class="js">1
2
3
</code></pre>
<p>forEach 方法为数组中含有有效值的每一项执行一次 callback 函数，那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。 callback 函数会被依次传入三个参数：</p>
<ul>
<li>  数组当前项的值；</li>
<li>  数组当前项的索引；</li>
<li>  数组对象本身；</li>
</ul>
<p>需要注意的是，forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。</p>
<pre><code class="js">const arr = [];
arr[0] = &quot;a&quot;;
arr[3] = &quot;b&quot;;
arr[10] = &quot;c&quot;;
arr.name = &quot;Hello world&quot;;
arr.forEach((data, index, array) =&gt; &#123;
    console.log(data, index, array);
&#125;);
</code></pre>
<p>运行结果：</p>
<pre><code class="js">a 0 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]
b 3 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]
c 10 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]
</code></pre>
<p>这里的 index 是 Number 类型，并且也不会像 for-in 一样遍历原型链上的属性。</p>
<p>所以，使用 forEach 时，我们不需要专门地声明 index 和遍历的元素，因为这些都作为回调函数的参数。</p>
<p>另外，forEach 将会遍历数组中的所有元素，但是 ES5 定义了一些其他有用的方法，下面是一部分：</p>
<ul>
<li>  every: 循环在第一次 return false 后返回</li>
<li>  some: 循环在第一次 return true 后返回</li>
<li>  filter: 返回一个新的数组，该数组内的元素满足回调函数</li>
<li>  map: 将原数组中的元素处理后再返回</li>
<li>  reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果。</li>
</ul>
<p><strong>forEach 性能</strong></p>
<p>大家可以看 <a href="https://jsperf.com/for-vs-foreach/66">jsPerf</a> ，在不同浏览器下测试的结果都是 forEach 的速度不如 for。如果大家把测试代码放在控制台的话，可能会得到不一样的结果，主要原因是控制台的执行环境与真实的代码执行环境有所区别。</p>
<h2 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h2><p>先来看个例子：</p>
<pre><code class="js">const arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
for(let data of arr) &#123;
    console.log(data);
&#125;
</code></pre>
<p>运行结果是：</p>
<pre><code class="js">a
b
c
</code></pre>
<p><strong>为什么要引进 for-of？</strong></p>
<p>要回答这个问题，我们先来看看ES6之前的 3 种 for 循环有什么缺陷：</p>
<ul>
<li>  forEach 不能 break 和 return；</li>
<li>  for-in 缺点更加明显，它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。而且，遍历数组元素的顺序可能是随机的。</li>
</ul>
<p>所以，鉴于以上种种缺陷，我们需要改进原先的 for 循环。但 ES6 不会破坏你已经写好的 JS 代码。目前，成千上万的 Web 网站依赖 for-in 循环，其中一些网站甚至将其用于数组遍历。如果想通过修正 for-in 循环增加数组遍历支持会让这一切变得更加混乱，因此，标准委员会在 ES6 中增加了一种新的循环语法来解决目前的问题，即 for-of 。</p>
<p>那 for-of 到底可以干什么呢？</p>
<ul>
<li>  跟 forEach 相比，可以正确响应 break, continue, return。</li>
<li>  for-of 循环不仅支持数组，还支持大多数类数组对象，例如 DOM nodelist 对象。</li>
<li>  for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。</li>
<li>  for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历。</li>
</ul>
<p>总结一下，for-of 循环有以下几个特征：</p>
<ul>
<li>  这是最简洁、最直接的遍历数组元素的语法。</li>
<li>  这个方法避开了 for-in 循环的所有缺陷。</li>
<li>  与 forEach 不同的是，它可以正确响应 break、continue 和 return 语句。</li>
<li>  其不仅可以遍历数组，还可以遍历类数组对象和其他可迭代对象。</li>
</ul>
<p>但需要注意的是，for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用</p>
<p>for-in 循环（这也是它的本职工作）。</p>
<p>最后要说的是，ES6 引进的另一个方式也能实现遍历数组的值，那就是 Iterator。上个例子：</p>
<pre><code class="js">const arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
const iter = arr[Symbol.iterator]();

iter.next() // &#123; value: &#39;a&#39;, done: false &#125;
iter.next() // &#123; value: &#39;b&#39;, done: false &#125;
iter.next() // &#123; value: &#39;c&#39;, done: false &#125;
iter.next() // &#123; value: undefined, done: true &#125;
</code></pre>
<p>不过，这个内容超出了本文的范围，而且 Iterator 要讲的也有很多，以后有时间专门写一篇文章介绍，欢迎关注。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>For</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux教程1：环境搭建，初写Redux</title>
    <url>/2016/11/redux-learn-01/</url>
    <content><![CDATA[<p>如果将React比喻成士兵的话，你的程序还需要一位将军，去管理士兵（的状态），而Redux恰好是一位好将军，简单高效；</p>
<p>相比起React的学习曲线，Redux的稍微平坦一些；本系列教程，将以“红绿灯”为示例贯穿整个demo，希望能让用户快速理解&amp;学习Redux。</p>
<span id="more"></span>

<p>强烈推荐 <a href="http://camsong.github.io/redux-in-chinese/index.html">Redux 中文文档</a>，本redux教程所有的材料和思路都来源于此；</p>
<p>这个系列拆分成3篇文章，最后获得的效果图为：</p>
<p><a href="https://gw.alicdn.com/tps/TB1HYmUKVXXXXXhXXXXXXXXXXXX-224-316.gif"><img data-src="https://gw.alicdn.com/tps/TB1HYmUKVXXXXXhXXXXXXXXXXXX-224-316.gif" alt="result" title="result"></a><br>（这个是gif图，如果没动画请点击在新窗口打开）</p>
<p>红绿灯初始状态是 #绿灯5s#，继而循环 #黄灯3s# -&gt; #红灯7s# -&gt; #绿灯5s# -&gt; #黄灯3s# -&gt; …</p>
<h2 id="1、Redux简介"><a href="#1、Redux简介" class="headerlink" title="1、Redux简介"></a>1、Redux简介</h2><p>在Redux中，最为核心的概念就是 <code>state</code>、<code>action</code> 、<code>reducer</code> 以及 <code>store</code>，单词大家都懂，就是初学者不知道该怎么用。</p>
<p>以常见的红路灯为例，将其应用到Redux中：</p>
<ul>
<li>  <code>action</code>：就是灯的变化，”红变绿”等，用名词表述</li>
<li>  <code>state</code>：就是灯的名字，红灯、绿灯等，用名词表述</li>
<li>  <code>reducer</code>：就是灯的变化规则，红灯之后是绿灯等，用状态转移表述，归根到底也是名词</li>
<li>  <code>store</code>：就像是交警，执行上述的交通规则；</li>
</ul>
<p>简单的说，Redux所想表达的就是这些内容，所以它的学习曲线不会很陡。对于程序员来讲，阅读代码会比阅读文字舒服，那么我们如何简单地用redux实现。</p>
<h2 id="2、文件夹结构"><a href="#2、文件夹结构" class="headerlink" title="2、文件夹结构"></a>2、文件夹结构</h2><h3 id="2-1、安装依赖"><a href="#2-1、安装依赖" class="headerlink" title="2.1、安装依赖"></a>2.1、安装依赖</h3><p>创建符合redux风格的文件夹结构：</p>
<pre><code class="js">mkdir actions constants components layouts reducers stores tests views
touch server.js index.js webpack.config.js
</code></pre>
<p>这些文件夹结构也是借鉴自官网redux的todos示例；</p>
<p>然后安装依赖：</p>
<pre><code class="js">npm init
npm install --save koa koa-handlebars koa-router react react-dom react-redux classnames
npm install --save-dev webpack webpack-dev-server webpack-hot-middleware babel-core babel-loader babel-plugin-react-transform style-loader less-loader css-loader extract-text-webpack-plugin babel-preset-es2015 babel-preset-react
</code></pre>
<p>最终的文件夹结构为：</p>
<p><a href="https://gw.alicdn.com/tps/TB1lE1DKVXXXXaDXFXXXXXXXXXX-170-352.jpg"><img data-src="https://gw.alicdn.com/tps/TB1lE1DKVXXXXaDXFXXXXXXXXXX-170-352.jpg" alt="file structor" title="file structor"></a></p>
<h3 id="2-2、配置开发环境"><a href="#2-2、配置开发环境" class="headerlink" title="2.2、配置开发环境"></a>2.2、配置开发环境</h3><p>这里需要启用两个服务器，一个是webpack服务器，专门用于转换代码；另外一个是web应用服务器，响应客户端的请求</p>
<pre><code class="js">var path = require(&#39;path&#39;);
var fs = require(&#39;fs&#39;);
var webpack = require(&#39;webpack&#39;);
var ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);

// 遍历目录
var searchDir = [&#39;components&#39;,&#39;app&#39;]; // 需要webpack打包的目录
var entry = &#123;&#125;;

searchDir.forEach(function(dir)&#123;
  var srcBasePath = path.join(__dirname, &#39;./&#39;, dir);
  var files = fs.readdirSync(srcBasePath);
  var ignore = [&#39;.DS_Store&#39;]; // 忽略某些文件夹
  files.map(function (file) &#123;

    if (ignore.indexOf(file) &lt; 0) &#123;
      entry[dir+&#39;/&#39;+file] = path.join(srcBasePath, file, &#39;index.js&#39;);

      var demofile = path.join(srcBasePath, file, &#39;demo.js&#39;);
      if(fs.existsSync(demofile))&#123;
        entry[dir+&#39;/&#39;+file + &#39;/demo&#39;] = demofile;
      &#125;

      var reduxfile = path.join(srcBasePath, file, &#39;redux.js&#39;);
      if(fs.existsSync(reduxfile))&#123;
        entry[dir+&#39;/&#39;+file + &#39;/redux&#39;] = reduxfile;
      &#125;
    &#125;

  &#125;);
&#125;);

Object.keys(entry).forEach(function (key) &#123;
  entry[key] = [entry[key], &#39;webpack-hot-middleware/client&#39;];
&#125;);

module.exports = &#123;
  devtool:&#39;cheap-module-eval-source-map&#39;,
  entry :entry,
  output:&#123;
    path:path.join(__dirname,&#39;dist&#39;),
    filename:&#39;[name].js&#39;,
    publicPath:&#39;/static/&#39;
  &#125;,
  plugins:[
    new ExtractTextPlugin(&quot;[name]/index.css&quot;),
    new webpack.optimize.OccurenceOrderPlugin(),
    new webpack.HotModuleReplacementPlugin(),
    new webpack.NoErrorsPlugin()
  ],
  module:&#123;
    loaders:[&#123;
      test:/\.js$/,
      loader:&#39;babel-loader&#39;,
      exclude:/node_modules/,
      include:__dirname,
      query:&#123;
        presets: [&#39;es2015&#39;,&#39;react&#39;]
      &#125;
    &#125;,&#123;
      test: /\.less$/,
      loader: ExtractTextPlugin.extract(&#39;style-loader&#39;,&#39;css-loader!less-loader&#39;),
      exclude: /node_modules/
    &#125;]
  &#125;
&#125;
</code></pre>
<p>注意Babel 6的配置和上一个版本有很大的不同；详见：<a href="http://babeljs.io/blog/2015/10/31/setting-up-babel-6/">Setting up Babel 6</a></p>
<p>这是webpack配置项，接下来专门起一个nodejs程序提供webpack服务：</p>
<p><code>server.js</code>：</p>
<pre><code class="js">var webpack = require(&#39;webpack&#39;);
var WebpackDevServer = require(&#39;webpack-dev-server&#39;);
var config = require(&#39;./webpack.config&#39;);

new WebpackDevServer(webpack(config), &#123;
  publicPath: config.output.publicPath,
  hot: true,
  stats: &#123; colors: true &#125;,
  historyApiFallback: true
&#125;).listen(3009, &#39;localhost&#39;, function (err, result) &#123;
  if (err) &#123;
    console.log(err);
  &#125;

  console.log(&#39;Listening at localhost:3009&#39;);
&#125;);
</code></pre>
<p>此webpack服务专门用于整合前端资源，顺带使用babel转换ES6的JS代码；这里的含义就不多说了，可以参考以前的文章 <a href="http://www.atatech.org/articles/37601">Webpack</a>；</p>
<p>使用koa作为web服务器，因为测试所以比较简单，用了最基本的代码快速搭建：</p>
<pre><code class="js">var koa = require(&#39;koa&#39;);
var router = require(&#39;koa-router&#39;)();
var handlebars = require(&quot;koa-handlebars&quot;);
var app = koa();
var port = 3000;

// 使用handlerbars作为模板文件
app.use(handlebars(&#123;
  defaultLayout: &quot;index&quot;
&#125;));

// 定义路由
router.get(&quot;/&quot;, function *(next) &#123;
  yield this.render(&#39;index&#39;,&#123;
    title:&#39;Redux示例-交通灯&#39;,
    name:&#39;交通灯示例&#39;
  &#125;);
&#125;);

// 定义应用路由
router.get(&#39;app&#39;,&#39;/app/:name&#39;,function*(next)&#123;
  this.appName = this.params.name || &#39;index&#39;; // 应用名字

  yield this.render(&#39;app/&#39;+this.appName,&#123;
    title:&#39;应用&#39;,
    filename:this.appName
  &#125;);

&#125;)

// 定义demo路由
router.get(&#39;demo&#39;,&#39;/:name/:type&#39;, function *(next) &#123;
  this.demoName = this.params.name || &#39;demo&#39;; // 获取demo名称
  this.demoType = this.params.type; // 获取文件类型，&#39;demo&#39; 或者 &#39;redux&#39;
  yield this.render(this.demoName + &#39;/index&#39;,&#123;
    title:&#39;示例&#39;,
    filename:this.demoType
  &#125;);
&#125;);

// 启用路由
app
  .use(router.routes())
  .use(router.allowedMethods());

// 监听端口
app.listen(port, function(error) &#123;
  if (error) &#123;
    console.error(error)
  &#125; else &#123;
    console.info(&quot;==&gt;   监听端口 %s. 请在浏览器里打开 http://localhost:%s/.&quot;, port, port)
  &#125;
&#125;)
</code></pre>
<p>好了，在命令行里开启这两个服务吧：</p>
<pre><code class="js">nodemon server.js &amp; nodemon --harmony index.js
</code></pre>
<p>在package.json中的<code>scripts</code>增加一条配置：<code>&quot;start&quot;: &quot;nodemon server.js &amp; nodemon --harmony index.js&quot;</code>，以后就可以使用 <code>npm start</code> 命令同时启动两个服务了；</p>
<p>这里使用了<code>nodemon</code>应用程序，方便修改后快速启动，该程序可通过<code>npm install -g nodemon</code>安装</p>
<h2 id="3、开始Redux吧"><a href="#3、开始Redux吧" class="headerlink" title="3、开始Redux吧"></a>3、开始Redux吧</h2><p>环境搭建好了，我们就依据最开始的设定用redux搭建红绿灯示例。</p>
<p>先创建所需要的文件：</p>
<pre><code class="js">mkdir actions/light reducers/light stores/light components/light

touch constants/TrafficLight.js actions/light/index.js reducers/light/index.js stores/light/index.js components/light/redux.js
</code></pre>
<h3 id="3-1、Actions"><a href="#3-1、Actions" class="headerlink" title="3.1、Actions"></a>3.1、Actions</h3><p>Action 本质是 <em>JavaScript 普通对象</em> action 内必须使用一个 <em>字符串类型</em> 的 <code>type</code> 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p>
<p>在 <code>constants/TrafficLight.js</code>中定义actions的名称，使用 <code>const</code> 修饰防止被修改：</p>
<pre><code class="js">export const CHANGE_GREEN = &#39;CHANGE_GREEN&#39;
export const CHANGE_YELLOW = &#39;CHANGE_YELLOW&#39;
export const CHANGE_RED = &#39;CHANGE_RED&#39;
</code></pre>
<p>然后在 <code>actions/light/index.js</code> 文件，定义 <em>Actions</em> 对象：</p>
<pre><code class="js">import * as lights from &#39;../../constants/TrafficLight&#39;

export function changeGreen()&#123;
 return &#123;type:lights.CHANGE_GREEN&#125;
&#125;

export function changeYellow()&#123;
 return &#123;type:lights.CHANGE_YELLOW&#125;
&#125;

export function changeRed()&#123;
 return &#123;type:lights.CHANGE_RED&#125;
&#125;
</code></pre>
<p>这里的 <em>{type:lights.CHANGE_GREEN}</em> 等就是Redux的 <em>action对象</em>（就是这么简单….）， 而对应的 <code>changeGreen</code>方法则称为 <em>action创建函数</em> ；</p>
<p>详细的概念及作用请参考Redux的中文文档 <a href="http://camsong.github.io/redux-in-chinese/docs/basics/Actions.html">Actions</a></p>
<h3 id="3-2、Reducer"><a href="#3-2、Reducer" class="headerlink" title="3.2、Reducer"></a>3.2、Reducer</h3><p>正所谓“不以规矩，不能方圆”，万物的运作都要符合规律，Reducer 就是描述各状态之间流转的 <em>规律</em>：</p>
<ul>
<li>  当红灯时，过n1秒会触发 <code>CHANGE_GREEN</code> 事件，灯编程绿色的</li>
<li>  当绿灯时，过n2秒会触发 <code>CHANGE_YELLOW</code> 事件，灯编程黄色的</li>
<li>  当黄灯时，过n3秒会触发 <code>CHANGE_RED</code> 事件，灯编程红色的</li>
<li>  …周而复始…</li>
</ul>
<p>继续在 <code>reducers/light/index.js</code>文件，描述不同等之间的转移：</p>
<pre><code class="js">import &#123;CHANGE_GREEN, CHANGE_YELLOW, CHANGE_RED&#125; from &#39;../../constants/TrafficLight&#39;

// 定义初始化状态，初始化状态是常量
// 初始状态是红灯
const initState = &#123;
 color:&#39;red&#39;,
 time:&#39;7&#39; // 持续时间20ms
&#125;

// 定义灯转换的reducer函数
export default function light(state=initState,action)&#123;
 switch(action.type)&#123;
   case CHANGE_GREEN:
     return &#123;
       color:&#39;green&#39;,
       time:&#39;5&#39;
     &#125;

   case CHANGE_YELLOW:
     return &#123;
       color:&#39;yellow&#39;,
       time:&#39;3&#39;
     &#125;

   case CHANGE_RED:
     return Object.assign(&#123;&#125;,initState);

   default:
     return state
 &#125;
&#125;
</code></pre>
<p>这里的<code>switch</code>语句就是典型的用于表述 <em>状态转移</em> 逻辑的代码结构，自己尝试写状态机的同学应该深有体会；</p>
<h3 id="3-3、Store"><a href="#3-3、Store" class="headerlink" title="3.3、Store"></a>3.3、Store</h3><p>有了交规还不行，得有付诸具体行动的载体 —— 交通信号灯 才行，在 <code>stores/light/index.js</code> ：</p>
<pre><code class="js">import &#123;createStore&#125; from &#39;redux&#39;
import lightReducer from &#39;../../reducers/light/&#39;

export default function lightStore(initState)&#123;
 return createStore(lightReducer,initState); // 初始化创建
&#125;
</code></pre>
<p>关键就那句<code>createStore</code>函数，接受 <code>reducer</code>（交通规则）和 <code>initState</code> （初始状态，灯的初始状态是红灯）作为参数；</p>
<p>这里的 “交通信号灯” 也是一种类别，并不是具体指 “灯” —— 额，希望你能理解我想表述的…</p>
<p>自此，恭喜你你已经成功实施了 Redux 的必要规范了，接下来我们检验一下是否正如你所愿；</p>
<p>此节中我们先简单的实施一下，后续文章再补充细节</p>
<h2 id="4、检查能否运行"><a href="#4、检查能否运行" class="headerlink" title="4、检查能否运行"></a>4、检查能否运行</h2><p>按照上面创建的一系列JS文件，你已经基于 <code>Redux</code> 完成了红绿灯的规则效果，那怎么检验呢？</p>
<p>来，拿一个红绿灯过来！</p>
<p>接通电源，给这个灯 <em>发送</em> 事件（类似于dom中的“触发事件”），假设事件的 <code>type</code> 依次是 <strong>CHANGE_GREEN</strong> 、<strong>CHANGE_GREEN</strong>，看看事件结束之后的状态是否符合期望。</p>
<h3 id="4-1、编写demo文件"><a href="#4-1、编写demo文件" class="headerlink" title="4.1、编写demo文件"></a>4.1、编写demo文件</h3><p>编写 <code>components/light/demo.js</code>：</p>
<pre><code class="js">import lightStore from &#39;../../stores/light&#39;
import &#123;changeGreen, changeYellow, changeRed&#125; from &#39;../../actions/light&#39;

let store = lightStore();

let unsubscribe = store.subscribe(() =
  console.log(store.getState())
);

store.dispatch(changeGreen());
store.dispatch(changeYellow());
store.dispatch(changeRed());
</code></pre>
<h3 id="4-2、编写view模板"><a href="#4-2、编写view模板" class="headerlink" title="4.2、编写view模板"></a>4.2、编写view模板</h3><p>上面的都是 <code>redux</code> 的功能代码，现在为了方便在浏览器查看，使用 <code>koa</code> 搭建一个简单的服务器；使用<code>handlerbars</code> 作为模板引擎，使用下列方式创建模板和视图</p>
<p>在 <code>layouts/index.hbs</code> 中编写母模板，其中的 <code>&#123;@body&#125;</code> 是留给子模板填充的</p>
<pre><code class="js">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&#123;&#123;title&#125;&#125;&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &#123;@body&#125;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在<code>views/light/index.hbs</code>中编写子模板内容，程序会自动将里面的内容自动替换上述模板中的 <code>&#123;@body&#125;</code> 占位符：</p>
<pre><code class="js">&lt;link rel=&quot;stylesheet&quot; href=&quot;http://localhost:3009/static/components/light/index.css&quot;&gt;

&lt;h1交通灯示例&lt;/h1&gt;
&lt;div id=&quot;demo&quot;&lt;/div&gt;

&lt;script src=&quot;http://localhost:3009/static/components/light/&#123;&#123;filename&#125;&#125;.js&quot;&lt;/script&gt;
</code></pre>
<h3 id="4-3、查看结果"><a href="#4-3、查看结果" class="headerlink" title="4.3、查看结果"></a>4.3、查看结果</h3><p>使用<code>npm start</code>开启两个服务，在浏览器URL里输入 <code>http://localhost:3000/light/demo</code> ，打开<code>console</code>，你将看到以下字符串：</p>
<pre><code class="js">Object &#123;color: &quot;green&quot;, time: &quot;5&quot;&#125;
Object &#123;color: &quot;yellow&quot;, time: &quot;3&quot;&#125;
Object &#123;color: &quot;red&quot;, time: &quot;7&quot;&#125;
</code></pre>
<p>你get到了什么？全程你都没有涉及到红绿灯的UI，但仿佛却有红绿灯的即视感，状态完全可控可预见！redux 其实就是帮你实现了一套状态机，且逻辑清晰。由于不涉及UI，所以非常也很利于单元测试。</p>
<p>如果启动的时候 webpack 报错：<strong>You may need an appropriate loader to handle this file type</strong> ，请见<a href="http://stackoverflow.com/questions/33469929/you-may-need-an-appropriate-loader-to-handle-this-file-type-with-webpack-and-b">use Webpack with Babel to compile ES6 assets,</a> 这里的解决方案，因为Babel 6是相比以前是一个重大升级，配置按模块方式加载了；</p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p> 在继续后面的章节之前，稍微整理一下上面的逻辑，使用图表描述会更加清晰些：</p>
<p> <a href="https://gw.alicdn.com/tps/TB1HK1IKVXXXXbRXpXXXXXXXXXX-1043-623.jpg"><img data-src="https://gw.alicdn.com/tps/TB1HK1IKVXXXXbRXpXXXXXXXXXX-1043-623.jpg" alt="light" title="light"></a></p>
<p> 这简单的图里面还涉及到 <code>倒计时的状态</code>，此篇文章为减少复杂度，方便读者快速理解Redux的基本概念，并不牵涉倒计时的状态，后续文章示例自然会将车的状态考虑进去；</p>
<p> 将图中的<code>Action</code> <code>Reducer</code>以及 <code>Store</code> 和上述代码对照，一切都是那么合乎逻辑，自然而然；</p>
<p> 本文更多的是讲解如何快速上手Redux，并没有对其中的语法和概念进行过多的解释</p>
<ul>
<li>  一方面是语法的解释，中文文档里面的解释很全面，我没有自信能够超越它；</li>
<li>  另一方面让新手对这些简单的代码中的陌生概念(诸如<code>combineReducers</code> <code>dispatch</code>等）产生疑惑，带着问题来探索答案，加深印象</li>
</ul>
<p> 这里将上述操作流程大致绘制一下：</p>
<p> <a href="https://gw.alicdn.com/tps/TB1PEqxKVXXXXXuXVXXXXXXXXXX-1556-817.jpg"><img data-src="https://gw.alicdn.com/tps/TB1PEqxKVXXXXXuXVXXXXXXXXXX-1556-817.jpg" alt="workflow" title="workflow"></a></p>
<p> 顺带提及一下Redux的三大原则，看一眼就好，后续用多了自然会记住：</p>
<p> <a href="https://gw.alicdn.com/tps/TB1n_uzKVXXXXXBXVXXXXXXXXXX-912-388.jpg"><img data-src="https://gw.alicdn.com/tps/TB1n_uzKVXXXXXBXVXXXXXXXXXX-912-388.jpg" alt="three princel" title="three princel"></a></p>
<p> 最后，非常推荐<code>redux</code>库，里面有很多示例可以参考，比如经典的 <code>todos</code> 例子：</p>
<pre><code class="js">git clone https://github.com/rackt/redux.git

cd redux/examples/todomvc
npm install
npm start

open http://localhost:3000/
</code></pre>
<p>  该示例包含：</p>
<ul>
<li>  Redux 中使用两个 reducer 的方法</li>
<li>  嵌套数据更新</li>
<li>  测试代码</li>
</ul>
<p>  更多参考：<a href="http://camsong.github.io/redux-in-chinese/docs/introduction/Examples.html">Redux示例</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 字符串常用操作</title>
    <url>/2016/12/javascript-string-operation/</url>
    <content><![CDATA[<p>JavaScript 字符串用于存储和处理文本。因此在编写 JS 代码之时她总如影随形，在你处理用户的输入数据的时候，在读取或设置 DOM 对象的属性时，在操作 Cookie 时，在转换各种不同 Date 时，诸此等等，繁不能数；而她那满多的 API 呵，总有些让人不愿去记忆的冲动，既然用时常搜，倒不如烂笔头一翻，顺道也体现下博客存在的价值，由此就有了这篇纪要。</p>
<span id="more"></span>
<h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><h3 id="1-substring"><a href="#1-substring" class="headerlink" title="1. substring()"></a>1. substring()</h3><p>xString.substring(start,end)</p>
<p>substring()是最常用到的字符串截取方法，它可以接收两个参数(参数不能为负值)，分别是要截取的开始位置和结束位置，它将返回一个新的字符串，其内容是从start处到end-1处的所有字符。若结束参数(end)省略，则表示从start位置一直截取到最后。</p>
<pre><code class="js">let str = &#39;www.jeffjade.com&#39;
console.log(str.substring(0,3)) // www
console.log(str.substring(0))   //www.jeffjade.com
console.log(str.substring(-2))  //www.jeffjade.com (传负值则视为0)
</code></pre>
<h3 id="2-slice"><a href="#2-slice" class="headerlink" title="2. slice()"></a>2. slice()</h3><pre><code class="js">stringObject.slice(start, end)
</code></pre>
<p><code>slice()</code>方法与<code>substring()</code>方法非常类似，它传入的两个参数也分别对应着开始位置和结束位置。而区别在于，<code>slice()</code>中的参数可以为负值，如果参数是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符。</p>
<pre><code class="js">let str = &#39;www.jeffjade.com&#39;
console.log(str.slice(0, 3))    // www
console.log(str.slice(-3, -1))  // co
console.log(str.slice(1, -1))   // www.jeffjade.co
console.log(str.slice(2, 1))    // &#39;&#39; (返回空字符串,start须小于end)
console.log(str.slice(-3, 0))   // &#39;&#39; (返回空字符串,start须小于end)
</code></pre>
<h3 id="3-substr"><a href="#3-substr" class="headerlink" title="3. substr()"></a>3. substr()</h3><pre><code class="js">stringObject.substr(start,length)
</code></pre>
<p><code>substr()</code>方法可在字符串中抽取从<code>start</code>下标开始的指定数目的字符。其返回值为一个字符串，包含从<code> stringObject</code>的<code>start</code>（包括<code>start</code>所指的字符）处开始的<code>length</code>个字符。如果没有指定 <code>length</code>，那么返回的字符串包含从<code>start</code>到<code>stringObject</code>的结尾的字符。另外如果<code>start</code>为负数，则表示从字符串尾部开始算起。</p>
<pre><code class="js">let str = &#39;www.jeffjade.com&#39;
console.log(webStr.substr(1, 3))   // ww.
console.log(webStr.substr(0))      // www.jeffjade.com
console.log(webStr.substr(-3, 3))  // com
console.log(webStr.substr(-1, 5))  // m  (目标长度较大的话，以实际截取的长度为准)
</code></pre>
<h3 id="4-split"><a href="#4-split" class="headerlink" title="4. split()"></a>4. split()</h3><pre><code class="js">str.split([separator][, limit])
</code></pre>
<p><code>separator</code> 指定用来分割字符串的字符（串）。<code>separator</code> 可以是一个字符串或正则表达式。 如果忽略 <code>separator</code>，则返回整个字符串的数组形式。如果 <code>separator</code> 是一个空字符串，则 str 将会把原字符串中每个字符的数组形式返回。<br>limit 一个整数，限定返回的分割片段数量。split 方法仍然分割每一个匹配的 <code>separator</code>，但是返回的数组只会截取最多 limit 个元素。</p>
<pre><code class="js">let str = &#39;www.jeffjade.com&#39;
str.split(&#39;.&#39;)      // [&quot;www&quot;, &quot;jeffjade&quot;, &quot;com&quot;]
str.split(&#39;.&#39;, 1)   // [&quot;www&quot;]
str.split(&#39;.&#39;).join(&#39;&#39;) // wwwjeffjadecom
</code></pre>
<p>话说这个函数真心好用，很多时候的字符截取需求，就是依赖于某个字符；而以上三个函数都需知道其位置。我们当然可以借助 indexOf 等方法获取，很显然这很繁琐；而借助 split 则显得更轻而易举。</p>
<h2 id="查找类方法"><a href="#查找类方法" class="headerlink" title="查找类方法"></a>查找类方法</h2><h3 id="1-indexOf-amp-includes"><a href="#1-indexOf-amp-includes" class="headerlink" title="1. indexOf() &amp; includes()"></a>1. indexOf() &amp; includes()</h3><pre><code class="js">stringObject.indexOf(searchValue,fromIndex)
</code></pre>
<p><code>indexOf()</code>用来检索指定的字符串值在字符串中首次出现的位置。它可以接收两个参数，<code>searchValue</code>表示要查找的子字符串，<code>fromIndex</code> 表示查找的开始位置，省略的话则从开始位置进行检索。</p>
<pre><code class="js">let str = &#39;www.jeffjade.com&#39;
console.log(str.indexOf(&#39;.&#39;))     // 3
console.log(str.indexOf(&#39;.&#39;, 1))  // 3
console.log(str.indexOf(&#39;.&#39;, 5))  // 12
console.log(str.indexOf(&#39;.&#39;, 12)) // -1
</code></pre>
<p>虽然 <code>indexOf()</code>用来检索指定的字符串值在字符串中首次出现的位置 ，然而很多时候，使用它的场景在于判断字符串中是否存在指定的字符串；因此代码就会如此：</p>
<pre><code class="js">if (str.indexOf(&#39;yoursPecifiedStr&#39;) !== -1) &#123;
    // do something
&#125;
</code></pre>
<p>要知道在这样的场景下，ES6 语言中的<code>includes()</code>就显得更优雅许多；<code>includes()</code> 方法用于判断一个字符串是否被包含在另一个字符串中，如果是返回true，否则返回false。</p>
<pre><code class="js">str.includes(searchString[, position])
</code></pre>
<p><code>searchString</code> 将要搜寻的子字符串。<code>position</code> 可选。从当前字符串的哪个索引位置开始搜寻子字符串；默认为0。需要注意的是，<code>includes()</code> 是区分大小写的。</p>
<pre><code class="js">&#39;Blue Whale&#39;.includes(&#39;blue&#39;); // returns false
&#39;乔峰乔布斯乔帮主&#39;.includes(&#39;乔布斯&#39;); // returns true
if (str.includes(&#39;yoursPecifiedStr&#39;)) &#123;
    // do something(这样写是不是更为人性化？Yeah，这是一个更趋向人性化的时代嘛)
&#125;
</code></pre>
<h3 id="2-lastIndexOf"><a href="#2-lastIndexOf" class="headerlink" title="2. lastIndexOf()"></a>2. lastIndexOf()</h3><pre><code class="js">stringObject.lastIndexOf(searchValue,fromIndex)
</code></pre>
<p><code>lastIndexOf()</code>语法与<code>indexOf()</code>类似，它返回的是一个指定的子字符串值最后出现的位置，其检索顺序是从后向前。</p>
<pre><code class="js">let str = &#39;www.jeffjade.com&#39;
console.log(str.lastIndexOf(&#39;.&#39;))     // 12
console.log(str.lastIndexOf(&#39;.&#39;, 1))  // -1
console.log(str.lastIndexOf(&#39;.&#39;, 5))  // 3
console.log(str.lastIndexOf(&#39;.&#39;, 12)) // 12
</code></pre>
<h3 id="3-search"><a href="#3-search" class="headerlink" title="3. search()"></a>3. search()</h3><pre><code class="js">stringObject.search(substr)
stringObject.search(regexp)
</code></pre>
<p>search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。它会返回第一个匹配的子字符串的起始位置，如果没有匹配的，则返回-1。</p>
<pre><code class="js">let str = &#39;www.jeffjade.com&#39;
console.log(str.search(&#39;w&#39;))    // 0
console.log(str.search(/j/g))   // 4
console.log(str.search(/\./g))  // 3
</code></pre>
<h3 id="4-match-方法"><a href="#4-match-方法" class="headerlink" title="4. match()方法"></a>4. match()方法</h3><pre><code class="js">stringObject.match(substr)
stringObject.match(regexp)
</code></pre>
<p><code>match()</code>方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p>
<p>如果参数中传入的是子字符串或是没有进行全局匹配的正则表达式，那么match()方法会从开始位置执行一次匹配，如果没有匹配到结果，则返回null。否则则会返回一个数组，该数组的第0个元素存放的是匹配文本，除此之外，返回的数组还含有两个对象属性index和input，分别表示匹配文本的起始字符索引和stringObject 的引用(即原字符串)。</p>
<pre><code class="js">let str = &#39;#1a2b3c4d5e#&#39;;
console.log(str.match(&#39;A&#39;));    //返回null
console.log(str.match(&#39;b&#39;));    //返回[&quot;b&quot;, index: 4, input: &quot;#1a2b3c4d5e#&quot;]
console.log(str.match(/b/));    //返回[&quot;b&quot;, index: 4, input: &quot;#1a2b3c4d5e#&quot;]
</code></pre>
<p>如果参数传入的是具有全局匹配的正则表达式，那么match()从开始位置进行多次匹配，直到最后。如果没有匹配到结果，则返回null。否则则会返回一个数组，数组中存放所有符合要求的子字符串，并且没有index和input属性。</p>
<pre><code class="js">let str = &#39;#1a2b3c4d5e#&#39;
console.log(str.match(/h/g))     //返回null
console.log(str.match(/\d/g))    //返回[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]
</code></pre>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h3><pre><code class="js">stringObject.replace(regexp/substr,replacement)
</code></pre>
<p><code>replace()</code>方法用来进行字符串替换操作，它可以接收两个参数，前者为被替换的子字符串（可以是正则），后者为用来替换的文本。</p>
<p>如果第一个参数传入的是子字符串或是没有进行全局匹配的正则表达式，那么replace()方法将只进行一次替换（即替换最前面的），返回经过一次替换后的结果字符串。</p>
<pre><code class="js">let str = &#39;www.jeffjade.com&#39;
console.log(str.replace(&#39;w&#39;, &#39;W&#39;))   // Www.jeffjade.com
console.log(str.replace(/w/, &#39;W&#39;))   // Www.jeffjade.com
</code></pre>
<p>如果第一个参数传入的全局匹配的正则表达式，那么replace()将会对符合条件的子字符串进行多次替换，最后返回经过多次替换的结果字符串。</p>
<pre><code class="js">let str = &#39;www.jeffjade.com&#39;
console.log(str.replace(/w/g, &#39;W&#39;))   // WWW.jeffjade.com
</code></pre>
<h3 id="toLowerCase-amp-toUpperCase"><a href="#toLowerCase-amp-toUpperCase" class="headerlink" title="toLowerCase() &amp; toUpperCase()"></a>toLowerCase() &amp; toUpperCase()</h3><pre><code class="js">stringObject.toLowerCase()
stringObject.toUpperCase()
</code></pre>
<p><code>toLowerCase()</code>方法可以把字符串中的大写字母转换为小写，<code>toUpperCase()</code>方法可以把字符串中的小写字母转换为大写。</p>
<pre><code class="js">let str = &#39;www.jeffjade.com&#39;
console.log(str.toLowerCase())   // www.jeffjade.com
console.log(str.toUpperCase())   // WWW.JEFFJADE.COM
</code></pre>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>这个也是 ES6 才引入进来的新语法，来解决传统输出String模板的蹩脚问题；其功能之强大，设计之贴心，着实令人得到极大满足感，好如久旱逢甘霖一般的舒畅。更何况，在当今 MVVM 前端框架大行其道的时代，使用 ES6 语法也是不用自己个儿去操心兼容性问题，对于塑造 Dom Template 更是如虎添翼，令人爱不释手。</p>
<p>对于她的使用，阮一峰在ECMAScript 6 入门有过详细的描述以及示例，在此就不赘述。只需要明白我们可以像这样去操作了，试问爽否？</p>
<pre><code class="js">function ncieFunc() &#123;
  return &quot;四海无人对夕阳&quot;;
&#125;
var niceMan = &quot;陈寅恪&quot;;
var jadeTalk = `一生负气成今日 \n $&#123;ncieFunc()&#125; ,
语出 $&#123;niceMan&#125; 的《忆故居》。
`
console.log(jadeTalk)
</code></pre>
<p>运行之，Chrome Console 输出结果如下：</p>
<pre><code>    一生负气成今日
    四海无人对夕阳 ,
    语出 陈寅恪 的《忆故居》。
</code></pre>
<h2 id="组合其法"><a href="#组合其法" class="headerlink" title="组合其法"></a>组合其法</h2><p>细看 JavaScript 提供的String Api，还是有蛮多的，也有些许废弃的，也有将在未来版本会出来的；这其中不乏很多也挺有用的，譬如： charAt(x)、charCodeAt(x)、concat(v1, v2,…)、fromCharCode(c1, c2,…) 等等,还有 ES6 对字符串的扩展，比如 字符串的遍历器接口，repeat() 等等，这可以参见 ES6-string，这里就不多赘述。</p>
<p>在实际代码生产中，很多时候需要用这些提供的基本方法，来打出一套组合拳，以解决其需求所需。很显然又可以借助 prototype 属性，将自造的各路拳法，其归置于 String 对象，然后天亮啦。这一步就看个人喜好了，这里抛出一二段，以引大玉。</p>
<h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><pre><code class="js">String.prototype.reverse = function () &#123;
    return this.split(&#39;&#39;).reverse().join(&#39;&#39;)
&#125;
</code></pre>
<h3 id="去除空白行"><a href="#去除空白行" class="headerlink" title="去除空白行"></a>去除空白行</h3><pre><code class="js">String.prototype.removeBlankLines = function () &#123;
    return this.replace(/(\n[\s\t]*\r*\n)/g, &#39;\n&#39;).replace(/^[\n\r\n\t]*|[\n\r\n\t]*$/g, &#39;&#39;)
&#125;
</code></pre>
<h3 id="String转化为数组"><a href="#String转化为数组" class="headerlink" title="String转化为数组"></a>String转化为数组</h3><h4 id="1-转化为一维数组"><a href="#1-转化为一维数组" class="headerlink" title="1, 转化为一维数组"></a>1, 转化为一维数组</h4><p>场景是根据某子字符串转化，直接就用 split 就好；如果转换规则不统一，那么请自求多福吧。</p>
<pre><code class="js">let Str = &#39;陈寅恪,鲁迅,钱钟书,胡适,王国维,梁启超,吴宓,季羡林&#39;
let hallAllOfFameArr = Str.split(&#39;,&#39;)
console.log(hallAllOfFameArr)
// [&quot;陈寅恪&quot;, &quot;鲁迅&quot;, &quot;钱钟书&quot;, &quot;胡适&quot;, &quot;王国维&quot;, &quot;梁启超&quot;, &quot;吴宓&quot;, &quot;季羡林&quot;]
</code></pre>
<h4 id="2-转化为二维数组"><a href="#2-转化为二维数组" class="headerlink" title="2, 转化为二维数组"></a>2, 转化为二维数组</h4><pre><code class="js">String.prototype.removeBlankLines = function () &#123;
    return this.replace(/(\n[\s\t]*\r*\n)/g, &#39;\n&#39;).replace(/^[\n\r\n\t]*|[\n\r\n\t]*$/g, &#39;&#39;)
&#125;
String.prototype.strTo2dArr = function(firstSplit, secondSplit)&#123;
    var contentStr = this.removeBlankLines(),
        contentStrArr = contentStr.split(firstSplit),
        resultArr = contentStrArr.map((element) =&gt; &#123;
            return element.split(secondSplit)
        &#125;)
    return resultArr
&#125;
var str = `
渺渺钟声出远方,依依林影万鸦藏。
一生负气成今日,四海无人对夕阳。
破碎山河迎胜利,残馀岁月送凄凉。
松门松菊何年梦,且认他乡作故乡。
`
console.log(str.strTo2dArr(&#39;\n&#39;, &#39;,&#39;))
</code></pre>
<p>运行之，输出结果如下：</p>
<pre><code>[ [ ‘渺渺钟声出远方’, ‘依依林影万鸦藏。’ ],
[ ‘一生负气成今日’, ‘四海无人对夕阳。’ ],
[ ‘破碎山河迎胜利’, ‘残馀岁月送凄凉。’ ],
[ ‘松门松菊何年梦’, ‘且认他乡作故乡。’ ] ]
</code></pre>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>String</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局之-水平垂直居中</title>
    <url>/2017/04/css-vertical-align/</url>
    <content><![CDATA[<p>对一个元素水平垂直居中，在我们的工作中是会经常遇到的，也是 CSS 布局中很重要的一部分，本文就来讲讲 CSS 水平垂直居中的一些方法。</p>
<span id="more"></span>

<p>另外，文中的 css 都是用 less 书写的，如果看不懂 less，可以把我给的 demo 链接打开，然后在控制台中查看最终的 css，或者是点击 codepen 上的“View Compiled”按钮，可以查看编译后的 css</p>
<p>先看一张图，这是去年 cssConf 大会时阿里的 @寒冬 winter 老师放出来的：</p>
<p><img data-src="//img.souche.com/20160316/png/75f94274a6a7095538eb10cbd18eb4a8.png" alt="alt"></p>
<p>如图所示，CSS 布局是可以分为几大块的：</p>
<ul>
<li>盒子内部的布局<ul>
<li>文本的布局</li>
<li>盒模型本身的布局</li>
</ul>
</li>
<li>盒子之间的布局 visual formatting<ul>
<li>脱离正常流 normal flow 的盒子的布局<ul>
<li>absolute 布局上下文下的布局</li>
<li>float 布局上下文下的布局</li>
</ul>
</li>
<li>正常流 normal flow 下的盒子的布局<ul>
<li>BFC 布局上下文下的布局</li>
<li>IFC 布局上下文下的布局</li>
<li>FFC 布局上下文下的布局</li>
<li>table 布局上下文下的布局</li>
<li>css grid 布局上下文下的布局</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所有的 CSS 布局其实都是围绕着这些布局模块来的，水平垂直居中也一样。</p>
<h4 id="一-文本的水平垂直居中"><a href="#一-文本的水平垂直居中" class="headerlink" title="一. 文本的水平垂直居中"></a>一. 文本的水平垂直居中</h4><p><strong>line-height + text-align:center</strong></p>
<p><a href="http://codepen.io/Dudy/pen/aOKWWO?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;水平垂直居中水平垂直居中&lt;/div&gt;
</code></pre>
<pre><code class="js">html,body&#123;
  margin: 0;
&#125;

.wrap&#123;
  line-height: 400px;
  text-align:center;

  height: 400px;
  font-size: 36px;
  background-color: #ccc;
&#125;
</code></pre>
<p>这种方法只适合单行文字的水平垂直居中</p>
<h4 id="二-利用盒模型的水平垂直居中"><a href="#二-利用盒模型的水平垂直居中" class="headerlink" title="二. 利用盒模型的水平垂直居中"></a>二. 利用盒模型的水平垂直居中</h4><p>我们一般讲的盒模型都是说的块级盒的盒模型，也只有块级盒的盒模型用得多一点，块级盒 block-level box 又是分别由 content-box、padding-box、border-box、margin-box 组成的，如下图：</p>
<p><img data-src="//img.souche.com/20160316/png/93a4055545278d504a8add63bc0883bf.png" alt="Alt text"></p>
<p>也就说我任一个子盒子的水平和垂直方向的边与最外面盒子的间距都是可以控制的，因此也就有如下居中方法：</p>
<p><strong>padding 填充</strong></p>
<p><a href="http://codepen.io/Dudy/pen/EjRvgp?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;content&quot; /&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">@wrapWidth : 400px;

.wrap&#123;
  margin-left: auto;
  margin-right: auto;
  margin-top: 20px;
  width: @wrapWidth;
  height: @wrapWidth;
  background-color: #ccc;
&#125;

.content&#123;
  @contentWidth : 100px;
  width: @contentWidth;
  height: @contentWidth;
  padding: (@wrapWidth - @contentWidth) / 2;
  background-color: #333;
  background-clip:content-box;
&#125;
</code></pre>
<p>也可以用 css3 的 calc()动态计算:</p>
<p><a href="http://codepen.io/Dudy/pen/RPJZVw?editors=110">DEMO 链接</a></p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;content&quot; /&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">.wrap&#123;
  margin-top: 20px;
  margin-left: auto;
  margin-right: auto;
  width: 400px;
  height: 400px;
  background-color: #ccc;
  .content&#123;
    padding: -webkit-calc(~&quot;(100% - 100px) / 2&quot;);
    padding: calc(~&quot;(100% - 100px) / 2&quot;);
    width: 100px;
    height: 100px;
    background-color: #333;
    background-clip: content-box;
  &#125;
&#125;
</code></pre>
<p>注意这里我在 calc 中使用了一个~””的写法，这是 less 中的一个语法，告诉 less 这里不被 less 所编译，要是被 less 编译了的话，css 的 calc 函数的参数就不是 100% - 100px，而是 0%了。</p>
<p><strong>margin 填充</strong></p>
<p><a href="http://codepen.io/Dudy/pen/jPKxYL?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;ele&quot; /&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">.wrap&#123;
  @wrapHeight : 400px;
  @contenHeight : 100px;
  overflow: hidden;
  width: 100%;
  height: @wrapHeight;
  background-color: #ccc;
  .ele&#123;
    margin-left: auto;
    margin-right: auto;
    margin-top: (@wrapHeight - @contenHeight) / 2;
    width: 100px;
    height: @contenHeight;
    background-color: #333;
    color: #fff;
  &#125;
&#125;
</code></pre>
<p>使用 margin 填充我们需要知道元素的宽度，这点不太灵活，不过 CSS3 搞出了一个加 fit-content 的属性值，可以动态计算元素的宽度，<a href="http://codepen.io/Dudy/pen/yNEZVQ">DEMO 链接</a></p>
<p>使用盒模型进行布局不会产生 reflow，兼容也好，使用盒模型布局是一种布局思想，其实仅仅靠它就能实现很多 visual formatting 才能实现的布局，这是另一个话题，这里不展开。</p>
<h4 id="三-absolute-布局上下文下的水平垂直居中"><a href="#三-absolute-布局上下文下的水平垂直居中" class="headerlink" title="三. absolute 布局上下文下的水平垂直居中"></a>三. absolute 布局上下文下的水平垂直居中</h4><p><strong>50% + -50%</strong></p>
<p>原理很简单，就是利用 left：50%将盒子的左边先置于父容器的中点，然后再将盒子往左偏移盒子自身宽度的 50%，这里有三种具体实现：</p>
<p><a href="http://codepen.io/Dudy/pen/VLdzRv?editors=110">DEMO 链接</a></p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;ele margin&quot;&gt;水平垂直居中水平垂直&lt;br&gt;居中水平垂直居中水平&lt;br&gt;垂直居中水平垂直居&lt;br&gt;中水平垂直居中&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;ele translate&quot;&gt;水平垂直居中水平垂直&lt;br&gt;居中水平垂直居中水平&lt;br&gt;垂直居中水平垂直居&lt;br&gt;中水平垂直居中&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;ele relative&quot;&gt;
    &lt;div class=&quot;ele-inner&quot;&gt;水平垂直居中水平垂直&lt;br&gt;居中水平垂直居中水平&lt;br&gt;垂直居中水平垂直居&lt;br&gt;中水平垂直居中&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">.wrap&#123;
  position: relative;
  width: 100%;
  height: 200px;
  border:1px solid;
  background-color: #ccc;
  .ele&#123;
    position: absolute;
    left: 50%;
    top: 50%;
    background-color: #333;
    &amp;.margin&#123;
      width: 160px;
      height: 100px;
      margin-left: -80px;
      margin-top: -50px;
    &#125;
    &amp;.translate&#123;
      -webkit-transform:translate3d(-50%, -50%, 0);
      transform:translate3d(-50%, -50%, 0);
    &#125;
    .ele-inner&#123;
      position: relative;
      left: -50%;
      top: -50%;
      width: 100%;
      height: 100%;
      background-color: #333;
    &#125;
    &amp;.relative&#123;
      width: 150px;
      height: 100px;
      background-color: transparent;
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面三个方法中，margin 方法和 relative 方法都需要知道元素的宽高才行(relative 方法只知道高也行)，适用于固定式布局，而 transform 方法则可以不知道元素宽高</p>
<p><strong>text-align:center + absolute</strong></p>
<p>text-aign:center 本来是不能直接作用于 absolute 元素的，但是没有给其 left 等值的行级 absolute 元素是会受文本的影响的，可以参考张老师的<a href="http://www.zhangxinxu.com/wordpress/2011/12/position-absolute-text-align-center/">这篇文章</a></p>
<p><a href="http://codepen.io/Dudy/pen/BNVwJx?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;ele&quot; /&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">.wrap&#123;
  text-align: center;

  width: 100%;
  height: 400px;
  background-color: #ccc;
  font-size: 0;
&#125;
.ele&#123;
  position: absolute;
  margin-left: -(100px / 2);
  margin-top: (400px - 100px) / 2;

  width: 100px;
  height: 100px;
  display: inline-block;
  background-color: #333;
&#125;
</code></pre>
<p>简单解释下，首先，text-align:center 作用的是文本而不是 absolute 的元素，但是，当 absolute 元素为 inline-block 的时候，它会受到文本的影响，然后你可能会问这里没文本啊，我只能告诉你说这下面是有的，是个匿名的文本节点。具体的这里不展开，可以参考<a href="http://www.w3.org/TR/CSS2/visudet.html#propdef-line-height">标准</a>，然后理解这句话:</p>
<blockquote>
<p>If the inline box contains no glyphs at all, it is considered to contain a strut (an invisible glyph of zero width) with the A and D of the element’s first available font</p>
</blockquote>
<p>然后这个匿名文本由于受到 text-align:center 影响居中了，这个时候 absolute 盒子的左边跟父容器的中点对齐了，所以就还需要往回拉 50%，这里用的是 margin-left，你也可以用其它方式拉。然后就是垂直方向的对齐，垂直方向是不能被操作文本的属性影响的，所以我这里用的是 margin-top 来让它偏移下去。</p>
<p><strong>absolute + margin : auto</strong></p>
<p><a href="http://codepen.io/Dudy/pen/mJKqXa?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;ele&quot; /&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">html,body&#123;
  width: 100%;
  height: 100%;
  margin: 0;
&#125;
.wrap&#123;
  position: relative;
  width: 100%;
  height: 100%;
  background-color: #ccc;
  .ele&#123;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: auto;
    width: 100px;
    height: 100px;
    background-color: #333;
  &#125;
&#125;
</code></pre>
<p>关于这种布局的原理，在标准中能找到如下解释：</p>
<p><a href="http://www.w3.org/TR/CSS21/visudet.html#abs-non-replaced-width">w3c.org</a>中有这样一句话：</p>
<blockquote>
<p>The constraint that determines the used values for these elements is:<br>‘left’ + ‘margin-left’ + ‘border-left-width’ + ‘padding-left’ + ‘width’ + ‘padding-right’ + ‘border-right-width’ + ‘margin-right’ + ‘right’ = width of containing block</p>
</blockquote>
<p>这句话说的是 absolute 性质的盒子，它的包含块的宽度等于它的盒模型的宽度 + left + right 值，包含块的高度同理，盒模型包括 margin-box、border-box、padding-box、content-box，而在这个居中方法中，.ele 的 left + right 值是 0，width 是定值，width 所在盒子包括了除了 margin-box 外的那三个 box，margin 都是 auto 值，按照上面那个公式，margin-left + margin-right 的值应该等于包含块的宽度 - left 的值 - right 的值 - width 的值，也就是说 margin-left + margin-right 的值等于除了 width 所占宽度外的剩下宽度，拥有剩下宽度后，就是平分其宽度，以让左右两边相等，达到居中，标准中给出了答案：</p>
<blockquote>
<p>If none of the three is ‘auto’: If both ‘margin-left’ and ‘margin-right’ are ‘auto’, solve the equation under the extra constraint that the two margins get equal values, unless this would make them negative, in which case when direction of the containing block is ‘ltr’ (‘rtl’), set ‘margin-left’ (‘margin-right’) to zero and solve for ‘margin-right’ (‘margin-left’)</p>
</blockquote>
<p>这里的”three”指的是 left, width, right。如果 left、right 和 width 都不为 auto，同时 margin-left 和 margin-right 都是 auto，除非特别情况，它们俩就是相等的，而这个例子中不在特殊情况之列，因此两者平分，此时达到了水平居中。而对于垂直方向的 margin 的 auto 值的计算，标准中也有如下两句话，跟水平方向的同理(这里的“three”指的是“top, height, bottom”)：</p>
<blockquote>
<p>the used values of the vertical dimensions must satisfy this constraint:<br>‘top’ + ‘margin-top’ + ‘border-top-width’ + ‘padding-top’ + ‘height’ + ‘padding-bottom’ + ‘border-bottom-width’ + ‘margin-bottom’ + ‘bottom’ = height of containing block</p>
<p>if none of the three are ‘auto’: If both ‘margin-top’ and ‘margin-bottom’ are ‘auto’, solve the equation under the extra constraint that the two margins get equal values.</p>
</blockquote>
<p>垂直方向也就因此也居中了。</p>
<p>这种方法能简单的做到居中，但是必须有 width 和 height 值</p>
<p><strong>适用于图片居中的网易 nec 的一个方法</strong></p>
<p><a href="http://codepen.io/Dudy/pen/GJGzJr?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;p&gt;
    &lt;img src=&quot;http://nec.netease.com/img/s/1.jpg&quot; alt=&quot;&quot; /&gt;
    &lt;img src=&quot;http://nec.netease.com/img/s/1.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">html,body&#123;
  width: 100%;
  height: 100%;
  margin: 0;
&#125;

.wrap&#123;
  position:relative;
  width: 100%;
  height: 100%;
  p&#123;
    position:absolute;
    left:50%;
    top:50%;
  &#125;
  img&#123;
    &amp;:nth-child(1)&#123;
      position:static;
      visibility:hidden;
    &#125;
    &amp;:nth-child(2)&#123;
      position:absolute;
      right:50%;
      bottom:50%;
    &#125;
  &#125;
&#125;
</code></pre>
<p>这种方法主要是利用了一个图片进行占位，以让父容器获得高宽，从而让进行-50%偏移的图片能有一个参照容器作百分比计算。优点是可以不知道图片的大小，随便放张尺寸不超过父容器的图片上去都能做到居中。另外，兼容性好，如果是不使用 nth-child 选择器的花，IE6 都是能顺利兼容的</p>
<h4 id="四-float-布局上下文下的水平垂直居中"><a href="#四-float-布局上下文下的水平垂直居中" class="headerlink" title="四. float 布局上下文下的水平垂直居中"></a>四. float 布局上下文下的水平垂直居中</h4><p><strong>float + -50%</strong></p>
<p><a href="http://codepen.io/Dudy/pen/xGzjZa?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;ele&quot;&gt;
    &lt;div class=&quot;ele-inner&quot;&gt;居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中居中居&lt;br&gt;中居中居中居中居中居中居中居中居中居&lt;br&gt;中居中居中居中居中居中居中&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">.wrap&#123;
  float: left;
  width: 100%;
  height: 400px;
  background-color: #ccc;
  .ele&#123;
    float: left;
    position: relative;
    left: 50%;
    top: 50%;
  &#125;
  .ele-inner&#123;
    position: relative;
    left: -50%;
    -webkit-transform : translate3d(0, -50%, 0);
    transform : translate3d(0, -50%, 0);
    background-color: #333;
    color: #fff;
  &#125;
&#125;
</code></pre>
<p>这种方法的原理，首先是利用 float 属性将需要居中的元素的父元素.ele 的宽度收缩，然后 left:50%将.ele 的左边和水平中线对齐，这个时候还没居中，还需要将其往回拉自身宽度的 50%，于是.ele-inner 便是真正需要水平居中的元素，我给它一个 position:relative，将其往回拉自身宽度 50%就行了。对于垂直方向，依然是先将.ele top:50%到垂直方向中点，但是这时给.ele-inner top:50%是不起作用的，因为如果没给父元素明确高度的话，这个 50%是计算不出来的，因此，就有了 transform : translate3d(0, -50%, 0)。</p>
<p>这种方法的好处是元素可以不定宽，任何时候都可以做到居中</p>
<p>我当时在 w3cplus 的站上发现这个方法后，当时觉得这个方法很好，兼容性好，又还可以不定宽，但当我用了一段时间后，发现了一个问题：</p>
<p>就是当居中元素的父元素 left:50%时，如果元素宽度足够大，会超出外面的容器，而如果外面的容器又正好是 overflow:auto 的话，那就会在外面产生滚动条，问题 DEMO 链接<a href="http://codepen.io/Dudy/pen/vENMwr?editors=110">在这里</a>，后来我找到了一个办法：<a href="http://codepen.io/Dudy/pen/YPWeYY?editors=110">DEMO 链接</a> ，基本思想就是利用元素超出父元素的左边不会产生滚动条的特性，有点奇淫技巧，但是能解决问题，有兴趣的可以看看</p>
<p><strong>margin-bottom : -50%</strong></p>
<p><a href="http://codepen.io/Dudy/pen/bdKMrB?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;placeholder&quot; /&gt;
  &lt;div class=&quot;content&quot; /&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">.wrap&#123;
  float: left;
  width: 100%;
  height: 400px;
  background-color: #ccc;
  @contentHeight : 100px;
  .placeholder&#123;
    float: left;
    width: 100%;
    height: 50%;
    /*居中元素.content高度一半*/
    margin-bottom: -(@contentHeight / 2);
  &#125;
  .content&#123;
    position: relative;
    left: 50%;
    transform:translate3d(-50%, 0, 0);
    clear: both;
    /*演示用，实际不需要定宽*/
    max-width: 100px;
    height: @contentHeight;
    background-color: #333;
  &#125;
&#125;
</code></pre>
<p>这种方法是先让占位元素.placeholder 占据 50%高度，然后给一个居中元素高度一半的负的 margin-bottom，然后下面的元素只要跟着摆放就能垂直居中了。水平方向就是利用 translate 做偏移，这个没什么好说的，你也可以换成其他办法。</p>
<p>这种方法就是各种固定死，首先最外层的父容器需要一个固定高度，以让.placeholder 的 height:50%有效，然后，margin-bottom 也需要固定死，而且得需要知道居中元素高度。单纯就水平方向来说，这个方法比较适合需要兼容低版本 IE 的固定式布局的项目，因为兼容性好。</p>
<h4 id="五-BFC-布局上下文下的水平垂直居中"><a href="#五-BFC-布局上下文下的水平垂直居中" class="headerlink" title="五.BFC 布局上下文下的水平垂直居中"></a>五.BFC 布局上下文下的水平垂直居中</h4><p>BFC 的全称是块级排版上下文，这里有篇<a href="http://div.io/topic/834?page=1#3261">文章</a>对齐进行了简单的介绍，BFC 布局上下文下的布局其实就是利用盒模型本身进行的布局，前面在利用盒模型布局的那一节中已经讲过了，这里就不重复了</p>
<h4 id="六-IFC-布局上下文下的水平垂直居中"><a href="#六-IFC-布局上下文下的水平垂直居中" class="headerlink" title="六.IFC 布局上下文下的水平垂直居中"></a>六.IFC 布局上下文下的水平垂直居中</h4><p>IFC 又是个什么概念呢，你可以看看<a href="http://www.w3.org/TR/CSS21/visuren.html#inline-formatting">官方文档</a>，也可以简单的理解为 display 为 inline 性质的行级元素的布局。</p>
<p><strong>text-align:center + vertical-align:middle</strong></p>
<p><a href="http://codepen.io/Dudy/pen/pJKVZa?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&#39;placeholder&#39;&gt;&lt;!--占位元素，用来作为居中元素的参照物--&gt;&lt;/div&gt;
  &lt;div class=&quot;ele&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">.wrap&#123;
  width: 100%;
  height: 400px;
  /* min-height: 400px; */
  text-align:center;
  font-size: 0;
  background-color: #ccc;
  .placeholder,
  .ele&#123;
    vertical-align: middle;
    display: inline-block;
  &#125;
  .placeholder&#123;
    overflow: hidden;
    width: 0;
    min-height: inherit;
    height: inherit;
  &#125;
  .ele&#123;
    width: 100px;
    height: 100px;
    background-color: #333;
  &#125;
&#125;
</code></pre>
<p>行级元素会受到 text-align 和 vertical-align 的影响，关于 vertical-align，不太好理解，我多贴几篇文章：<a href="http://www.html-js.com/article/2952">@灵感 idea 的</a>，<a href="http://www.zhangxinxu.com/wordpress/2010/05/%E6%88%91%E5%AF%B9css-vertical-align%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%E4%B8%8E%E8%AE%A4%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/">张鑫旭的</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align">MDN 上的</a>，<a href="https://css-tricks.com/almanac/properties/v/vertical-align/">css-trick 上的</a>，以及<a href="http://www.w3.org/TR/CSS21/visudet.html#line-height">官方文档</a>，这里首先是用 text-center 让 inline-block 水平居中，然后给一个 vertical-align:middle，但是仅仅给 vertical-align:middle 是不够的，因为此时它还没有 vertical-align 对齐的参照物，所以就给了一个占位的 inline-block，它的高度是 100%。</p>
<p>这个方法对于居中元素不需要定宽高，而且元素根据 vertical-align 值的不同不仅仅可以实现居中，还可以将其放在上面下面等。缺点是父元素需定高</p>
<p><strong>text-align:center + line-height</strong></p>
<p><a href="http://codepen.io/Dudy/pen/ZGRmqL?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;ele&quot;&gt;居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中居中&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">.wrap&#123;
  text-align: center;
  line-height: 400px;

  width: 100%;
  height: 400px;
  background-color: #ccc;
  font-size: 0;
  .ele&#123;
    line-height: normal;
    vertical-align: middle;
    display: inline-block;
    background-color: #333;
    font-size: 18px;
    color: #fff;
  &#125;
&#125;
</code></pre>
<p>这个方法，首先是水平方向，text-align:center 就行了，至于垂直方向，起作用的就是父容器的一个 line-height 和居中元素的 vertical-align:middle，为什么这两个属性可以让一个 inline-block 垂直居中呢，这里重点是父容器在其下面产生了一个隐匿的文本节点，这个我在上面 text-align:center + absolute 那个方法的讲解中说到过了，然后这个这个隐匿文本节点会因 line-height 属性的作用而拥有了一个父容器一样高的行高，此时元素有了一个 vertical-align 对齐的参照物，再给其 vertical-align:middle 值就能垂直对齐了。</p>
<p>使用这个方法，居中元素无需定宽高，但缺点是得给父容器一个固定的行高才行。</p>
<p><strong>text-align:center + font-size</strong></p>
<p><a href="http://codepen.io/Dudy/pen/vOrvBP?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;ele&quot; /&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">.wrap&#123;
  text-align: center;
  font-size: 400px * 0.873;/*约为高度的0.873*/

  margin-left: auto;
  margin-right: auto;
  width: 400px;
  height: 400px;
  background-color: #ccc;
  .ele&#123;
    vertical-align: middle;

    width: 100px;
    height: 100px;
    display: inline-block;
    background-color: #333;
  &#125;
&#125;
</code></pre>
<p>这个方法来自淘宝，基本原理还是让隐匿文本节点所占据的行高等于父容器的高度，然后给居中元素一个 vertical-align:middle 对齐的一个参照。只是这里把定义 line-height 值换成了定义 font-size 值，让 font-siz 足够大从而让其行高等于父容器高度。为了证明这个 font-size 的作用，我把居中元素换成文本</p>
<p><a href="http://codepen.io/Dudy/pen/JdZwGa?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;a&lt;/div&gt;
</code></pre>
<pre><code class="js">.wrap&#123;
  text-align: center;
  font-size: 400px * 0.873;/*约为高度的0.873*/

  margin-left: auto;
  margin-right: auto;
  width: 400px;
  height: 400px;
  background-color: #ccc;
&#125;
</code></pre>
<p>效果：</p>
<p><img data-src="//img.souche.com/20160316/png/12de8abcbfff3671be67c69f4353273a.png" alt="alt"></p>
<p>可以看到字母 a 垂直居中了，这个字母 a 就对应那个隐匿文本节点</p>
<h4 id="七-FFC-布局上下文下的水平垂直居中"><a href="#七-FFC-布局上下文下的水平垂直居中" class="headerlink" title="七.FFC 布局上下文下的水平垂直居中"></a>七.FFC 布局上下文下的水平垂直居中</h4><p><strong>父元素、子元素都定义 flex：</strong></p>
<p><a href="http://codepen.io/Dudy/pen/PqaXOZ?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;ele&quot;&gt;
  居中居中居中居中居中居中居中&lt;br&gt;
    居中居中居中居中居中居中居中&lt;br&gt;
    居中居中居中居中居中居中居中&lt;br&gt;
    居中居中居中居中居中居中居中&lt;br&gt;
    居中居中居中居中居中居中居中
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">html,body&#123;
  width: 100%;
  height: 100%;
&#125;

.wrap&#123;
  display: flex;
 align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  background-color: #ccc;
  .ele&#123;
    background-color: #333;
  &#125;
&#125;
</code></pre>
<p><strong>只有父元素定义 flex，子元素定义 margin:auto：</strong></p>
<p><a href="http://codepen.io/Dudy/pen/zGLzRN?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&quot;wrap&quot;&gt;
  &lt;div class=&quot;ele&quot;&gt;
  居中居中居中居中居中居中居中&lt;br&gt;
    居中居中居中居中居中居中居中&lt;br&gt;
    居中居中居中居中居中居中居中&lt;br&gt;
    居中居中居中居中居中居中居中&lt;br&gt;
    居中居中居中居中居中居中居中
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">html,body&#123;
  width: 100%;
  height: 100%;
&#125;

.wrap&#123;
  display: flex;
  width: 100%;
  height: 100%;
  background-color: #ccc;
  .ele&#123;
    margin:auto;
    background-color: #333;
  &#125;
&#125;
</code></pre>
<p>flex box 的标准中有这句话(参考链接:<a href="http://www.w3.org/TR/css-flexbox-1/#item-margins">http://www.w3.org/TR/css-flexbox-1/#item-margins):</a>:)</p>
<blockquote>
<p>The margins of adjacent flex items do not collapse. Auto margins absorb extra space in the corresponding dimension and can be used for alignment and to push adjacent flex items apart; see Aligning with auto margins.</p>
</blockquote>
<p>意思就是说 flex item 的 margin 不会折叠，在 flex-item 有明确大小并且 margin:auto 时外边距吸收了伸缩包含块下的额外的空间，并且能被用于居中以及会让其相邻的 flex item 尽可能的往这个 flex item 所在的那一个方向靠。</p>
<p>flexbox 是个很强大的布局模块，也就三个属性就搞定居中了，而且不论父容器还是居中元素都可以不定宽高。参考链接：<a href="http://www.w3cplus.com/css3/a-visual-guide-to-css3-flexbox-properties.html">图解 CSS3 Flexbox 属性</a></p>
<h4 id="八-table-布局上下文下的水平垂直居中"><a href="#八-table-布局上下文下的水平垂直居中" class="headerlink" title="八.table 布局上下文下的水平垂直居中"></a>八.table 布局上下文下的水平垂直居中</h4><p><a href="http://codepen.io/Dudy/pen/EjRGRO?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;div class=&#39;wrap&#39;&gt;
    &lt;div class=&#39;ele&#39;&gt;
      &lt;div class=&quot;ele-inner&quot;&gt;居中居中居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中居中&lt;br&gt;居中居中居中居中居中居中居中居中居中居中&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="js">.wrap&#123;
  width: 100%;
  height: 300px;
  display: table;
  background-color: #ccc;
&#125;
.ele&#123;
  text-align:center;
  vertical-align: middle;
  display:table-cell;
&#125;

.ele-inner&#123;
  display: inline-block;
  background-color: #333;
&#125;
</code></pre>
<p>原理就是把 div 模拟成表格（换成真正的表格标签也是可以的），然后给那几个属性就成了，这个没什么好讲的，不懂的去翻翻手册就明白了，然后<a href="http://weibo.com/u/2945647940?topnav=1&wvr=6&topsug=1">@于江水</a>写的一篇<a href="http://yujiangshui.com/about-table/">table 那些事</a>还不错</p>
<h4 id="九-CSS-grid-布局上下文下的水平垂直居中"><a href="#九-CSS-grid-布局上下文下的水平垂直居中" class="headerlink" title="九.CSS grid 布局上下文下的水平垂直居中"></a>九.CSS grid 布局上下文下的水平垂直居中</h4><p>CSS3 grid layout 是 IE 搞出来的一个布局模块，目前貌似还只有 IE0 和 IE11 支持，我没有研究过其居中的方法，有兴趣的可以看看<a href="http://www.w3cplus.com/blog/tags/356.html">大漠老师的介绍文章</a></p>
<h4 id="十-其它未知归属的水平垂直居中方法"><a href="#十-其它未知归属的水平垂直居中方法" class="headerlink" title="十.其它未知归属的水平垂直居中方法"></a>十.其它未知归属的水平垂直居中方法</h4><p><strong>使用 button 标签</strong></p>
<p><a href="http://codepen.io/Dudy/pen/aOKPgr?editors=110">DEMO 链接</a></p>
<p>代码：</p>
<pre><code class="js">&lt;button&gt;
  &lt;div&gt;
    居中居中居中居中居中居中&lt;br&gt;
    居中居中居中居中居中居中&lt;br&gt;
    居中居中居中居中居中居中&lt;br&gt;
    居中居中居中居中居中居中&lt;br&gt;
  &lt;/div&gt;
&lt;/button&gt;
</code></pre>
<pre><code class="js">button&#123;
  width: 100%;
  height: 400px;
  background-color: #cccccc;
  border-width:0;
  &amp;:focus&#123;
    outline:none;
  &#125;
  div&#123;
    display: inline-block;
    font-size: 18px;
    background-color: #333;
    color: #fff;
  &#125;
&#125;
</code></pre>
<p>这种方法属于奇淫技巧，利用 button 标签天生外挂的这一技能对其里面的元素进行居中。</p>
<p><strong>（本文完）</strong></p>
<blockquote>
<p>原文地址: <a href="http://div.io/topic/1155">http://div.io/topic/1155</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 的装饰器：它们是什么及如何使用</title>
    <url>/2017/06/js-decorator/</url>
    <content><![CDATA[<p>装饰器的流行应该感谢在Angular 2+中使用，在Angular中，装饰器因TypeScript能使用。但是在JavaScript中，还处于提议阶段。本文将介绍装饰器是什么，及装饰器如何让代码更加简洁和容易理解。</p>
<h1 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h1><p>装饰器是用一个代码包装另一个代码的简单方式。</p>
<p>这个概念与之前所听过的函数复合和高阶组件相似。</p>
<p>这已经用于很多情况，就是简单的将一个函数包装成另一个函数：</p>
<pre><code class="js">function doSomething(name) &#123;
  console.log(&#39;Hello, &#39; + name);
&#125;

function loggingDecorator(wrapped) &#123;
  return function() &#123;
    console.log(&#39;Starting&#39;);
    const result = wrapped.apply(this, arguments);
    console.log(&#39;Finished&#39;);
    return result;
  &#125;
&#125;

const wrapped = loggingDecorator(doSomething);
</code></pre>
<p>上个例子产生新函数<code>wrapped</code>，此函数与<code>doSomething</code>做同样事情，但是他们不同在于在包装函数之前和之后输出一些语句。</p>
<pre><code class="js">doSomething(&#39;Graham&#39;);
// Hello, Graham
wrapped(&#39;Graham&#39;);
// Starting
// Hello, Graham
// Finished
</code></pre>
<h1 id="如何使用JavaScript装饰器"><a href="#如何使用JavaScript装饰器" class="headerlink" title="如何使用JavaScript装饰器"></a>如何使用JavaScript装饰器</h1><p>JavaScript中装饰器使用特殊的语法，使用<code>@</code>作为标识符，且放置在被装饰代码之前。</p>
<blockquote>
<p><strong>注意：</strong>现在装饰器还处于提议阶段，意味着还有可以变化之处</p>
</blockquote>
<p>可以放置许多装饰器在同样代码之前，然后解释器会按照顺序相应执行</p>
<pre><code class="js">@log()
@immutable()
class Example &#123;
  @time(&#39;demo&#39;)
  doSomething() &#123;

  &#125;
&#125;
</code></pre>
<p>上例中定义了一个类，采用了三个装饰器：两个用于类本身，一个用于类的属性：</p>
<ul>
<li>  <code>@log</code>能记录所有所有访问类</li>
<li>  <code>@immutable</code>让类不可变-也许新实例调用了<code>Object.freeze</code></li>
<li>  <code>@time</code>会记录一个方法从执行到输出一个独特标签</li>
</ul>
<p>现在，虽然现在浏览器或Node还没支持。但是如果使用Babel，能使用 <a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy">transform-decorators-legacy</a>插件使用装饰器。</p>
<blockquote>
<p>插件中使用legacy是因为Babel 5支持处理装饰器，但是它也许会跟最终的标准有区别，所以才使用legacy这个词。</p>
</blockquote>
<h1 id="为什么使用装饰器"><a href="#为什么使用装饰器" class="headerlink" title="为什么使用装饰器"></a>为什么使用装饰器</h1><p>函数复合在JavaScript已经成为可能，但是它相当困难或不可能用于另一个代码（如类或类属性）。</p>
<p>装饰器提议可以用于类或属性，未来JavaScript版本可能会增加用于其他地方。</p>
<p>装饰器也考虑到采用较为简洁的语法。</p>
<h1 id="不同类型的装饰器"><a href="#不同类型的装饰器" class="headerlink" title="不同类型的装饰器"></a>不同类型的装饰器</h1><p>现在，装饰器只支持类和类属性，这包含属性、方法、get函数和set函数</p>
<p>装饰器只会在程序第一次运行时执行一次，装饰的代码会被返回的值代替</p>
<h2 id="类属性装饰器"><a href="#类属性装饰器" class="headerlink" title="类属性装饰器"></a>类属性装饰器</h2><p>属性装饰器适用于类的单独成员-无论是属性、方法、get函数或set函数。<br>装饰器函数调用三个参数：</p>
<ul>
<li>  target-被修饰的类</li>
<li>  name-类成员的名字</li>
<li>  descriptor-成员描述符。对象会将这个参数传给<code>Object.defineProperty</code></li>
</ul>
<p><code>@readonly</code>是经典的例子：</p>
<pre><code class="js">function readonly(target, name, descriptor) &#123;
  descriptor.writable = false;
  return descriptor;
&#125;
</code></pre>
<p>上例会将成员描述符中的<code>writable</code>设为<code>false</code>。</p>
<p>接着用于类中属性：</p>
<pre><code class="js">class Example &#123;
  a() &#123;&#125;
  @readonly
  b() &#123;&#125;
&#125;

const e = new Example();
e.a = 1;
e.b = 2;
// TypeError: Cannot assign to read only property &#39;b&#39; of object &#39;#&lt;Example&gt;&#39;
</code></pre>
<p>但是我们可以做的更好，可以用别的形式代替装饰函数。例如，记录所有的输入和输出：</p>
<pre><code class="js">function log(target, name, descriptor) &#123;
  const original = descriptor.value;
  if (typeof original === &#39;function&#39;) &#123;
    descriptor.value = function(...args) &#123;
      console.log(`Arguments: $&#123;args&#125;`);
      try &#123;
        const result = original.apply(this, args);
        console.log(`Result: $&#123;result&#125;`);
        return result;
      &#125; catch (e) &#123;
        console.log(`Error: $&#123;e&#125;`);
        throw e;
      &#125;
    &#125;
  &#125;
  return descriptor;
&#125;
</code></pre>
<p>注意我们使用了扩展运算符，会自动将所有参数转为数组。</p>
<pre><code class="js">class Example &#123;
    @log
    sum(a, b) &#123;
        return a + b;
    &#125;
&#125;

const e = new Example();
e.sum(1, 2);
// Arguments: 1,2
// Result: 3
</code></pre>
<p>可以让装饰器获取一些参数，例如重写<code>log</code>装饰器如下：</p>
<pre><code class="js">function log(name) &#123;
  return function decorator(t, n, descriptor) &#123;
    const original = descriptor.value;
    if (typeof original === &#39;function&#39;) &#123;
      descriptor.value = function(...args) &#123;
        console.log(`Arguments for $&#123;name&#125;: $&#123;args&#125;`);
        try &#123;
          const result = original.apply(this, args);
          console.log(`Result from $&#123;name&#125;: $&#123;result&#125;`);
          return result;
        &#125; catch (e) &#123;
          console.log(`Error from $&#123;name&#125;: $&#123;e&#125;`);
          throw e;
        &#125;
      &#125;
    &#125;
    return descriptor;
  &#125;;
&#125;
</code></pre>
<p>这与之前的<code>log</code>装饰器相同，只是利用了外部函数的<code>name</code>参数。</p>
<pre><code class="js">class Example &#123;
  @log(&#39;some tag&#39;)
  sum(a, b) &#123;
    return a + b;
  &#125;
&#125;

const e = new Example();
e.sum(1, 2);
// Arguments for some tag: 1,2
// Result from some tag: 3
</code></pre>
<h1 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h1><p>类装饰器用于整个类，装饰器函数的参数为被装饰的构造器函数。</p>
<p>注意只用于构造器函数，而不适用于类的每个实例。这就意味着如果想控制实例，就必须返回一个包装版本的构造器函数。</p>
<p>通常，类装饰器没什么用处，因为你所需要做的，同样可以用一个简单函数来处理。你所做的只需要在结束时返回一个新的构造函数来代替类的构造函数。</p>
<p>回到我们记录那个例子，编写一个记录构造函数参数：</p>
<pre><code class="js">function log(Class) &#123;
  return (...args) =&gt; &#123;
    console.log(args);
    return new Class(...args);
  &#125;;
&#125;
</code></pre>
<p>这里接收一个类作为参数，返回新函数作为构造器。此函数打印出参数，返回这些参数构造的实例。</p>
<p>例如：</p>
<pre><code class="js">@log
class Example &#123;
  constructor(name, age) &#123;
  &#125;
&#125;

const e = new Example(&#39;Graham&#39;, 34);
// [ &#39;Graham&#39;, 34 ]
console.log(e);
// Example &#123;&#125;
</code></pre>
<p>构造<code>Example</code>类时会输出提供的参数，构造值<code>e</code>也确实是<code>Example</code>的实例。</p>
<p>传递参数到类装饰器与类成员一样。</p>
<pre><code class="js">function log(name) &#123;
  return function decorator(Class) &#123;
    return (...args) =&gt; &#123;
      console.log(`Arguments for $&#123;name&#125;: args`);
      return new Class(...args);
    &#125;;
  &#125;
&#125;

@log(&#39;Demo&#39;)
class Example &#123;
  constructor(name, age) &#123;&#125;
&#125;

const e = new Example(&#39;Graham&#39;, 34);
// Arguments for Demo: args
console.log(e);
// Example &#123;&#125;
</code></pre>
<h1 id="真实例子"><a href="#真实例子" class="headerlink" title="真实例子"></a>真实例子</h1><h2 id="Core-decorators"><a href="#Core-decorators" class="headerlink" title="Core decorators"></a>Core decorators</h2><p><a href="https://www.npmjs.com/package/core-decorators">Core decorators</a>是一个库，提供了几个常见的修饰器，通过它可以更好地理解修饰器。</p>
<p>想理解此库，也可以去看看阮老师的关于<a href="http://es6.ruanyifeng.com/#docs/decorator#core-decorators-js">此库的介绍</a></p>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React广泛运用了高阶组件，这让React组件成为一个函数，并且能包含另一个组件。<br>使用装饰器是不错的替代法，例如，Redux库有一个<code>connect</code>函数，用于连接React组件和React store。</p>
<p>通常，是这么使用的：</p>
<pre><code class="js">class MyReactComponent extends React.Component &#123;&#125;

export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);
</code></pre>
<p>然而，可以使用装饰器代替：</p>
<pre><code class="js">@connect(mapStateToProps, mapDispatchToProps)
export default class MyReactComponent extends React.Component &#123;&#125;
</code></pre>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.sitepoint.com/javascript-decorators-what-they-are/">JavaScript Decorators: What They Are and When to Use Them</a><br><a href="http://es6.ruanyifeng.com%2F%23docs%2Fdecorator">阮老师ES6入门-修饰器</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Decorator</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 面试总结及技术规划</title>
    <url>/2018/03/interview-summary%20/</url>
    <content><![CDATA[<p>一晃博客又是大半年没有更新了。主要还是自己的惰性造成的，另外自己也是不善于总结，很多学习到的知识都没有及时的总结，形成文字记录下来，以后还是要多督促一下自己。</p>
<h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><p>各种原因年后离职了，面试了半个月目前定了一家，趁着周末总结下这次的面试过程和经验。</p>
<h2 id="面试前的准备"><a href="#面试前的准备" class="headerlink" title="面试前的准备"></a>面试前的准备</h2><p>准备工作还是很重要的，除了准备面试题目，还需要针对性的对面试公司做一定的了解。</p>
<p>面试的时候经常会问道 <code>你对我们公司了解多少？</code>，如果不稍微准备下这个还真的不好回答。最好面试之前先关注下公司的官网和产品，稍作了解免得什么都说不出来。</p>
<h2 id="夯实的基础"><a href="#夯实的基础" class="headerlink" title="夯实的基础"></a>夯实的基础</h2><p>不论面试的初级还是高级开发，基础都是必不可少的。</p>
<p>一些基础知识笔试和面试的时候都会遇上。比如说闭包、this的用法等。</p>
<h2 id="知识的深度和广度"><a href="#知识的深度和广度" class="headerlink" title="知识的深度和广度"></a>知识的深度和广度</h2><p>我在面试的过程中主要就是吃了这一点的亏，相关的技术了解的很多，但是很多内容都是局限在了解的层面上。</p>
<p>我说我熟悉React、VUE，然后面试官就问了那给我说一下他们两个的区别，再说下Redux的原理。<br>一时完全答不上来，会用并不代表就理解，而会用只是初级的表现。想要有所提高必须在某方面有比较深入的研究和理解。</p>
<h2 id="工作经历的多少"><a href="#工作经历的多少" class="headerlink" title="工作经历的多少"></a>工作经历的多少</h2><p>很多公司很关注以前的工作经历以及必问的一个问题 <code>为什么从商家公司离职？</code><br>关于这个问题的回答还是比较讲究的，如果是自己的原因，嫌工资太低了，直说人家觉得你只关注钱。<br>如果是公司的问题，直说人家觉得你一离职就在说公司坏话。<br>所以不管是因为什么，表达的时候还是需要委婉的说出来。</p>
<p>更重要的一点，在一家公司工作时间的长短和跳槽的频率对找工作还是有一定的影响。<br>一个频繁跳槽，工作不稳定的人公司自然不乐意招。</p>
<h2 id="常见的面试题"><a href="#常见的面试题" class="headerlink" title="常见的面试题"></a>常见的面试题</h2><ul>
<li>JS 部分：闭包、this、事件、原型、继承、Promise</li>
<li>CSS 部分：@import和link、less和sass、Flex布局、动画</li>
<li>框架部分： Redux流程和原理、虚拟DOM原理、React和VUE对比、ES6</li>
<li>其他：H5属性、浏览器加载过程、ajax、get和post、系统优化和提速、打包工具、模块化、组件化、浏览器缓存、storage和cookies</li>
<li>移动端：RN相关技术、小程序相关、微信SDK相关</li>
</ul>
<h1 id="2018年技术规划"><a href="#2018年技术规划" class="headerlink" title="2018年技术规划"></a>2018年技术规划</h1><ul>
<li>深入理解原生JS基础</li>
<li>深入学习 VUE 相关的使用，理解流程和原理</li>
<li>阅读 VUE 和 lodash 源码</li>
<li>深入学习 React 相关的使用（个人比较喜欢React，但是面试过程中大部分公司都是VUE使用的比较多）</li>
<li>熟悉小程序的开发</li>
<li>坚持更新博客内容，至少保证两周一篇</li>
</ul>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>面试</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>iview-admin 2.x 兼容IE11的方法</title>
    <url>/2019/01/iview-admin-ie/</url>
    <content><![CDATA[<p>最近使用iview-admin搭建的项目突然说要兼容ie,瀑汗.经过一番查阅资料,暂时找到一个可行的方法.记录如下</p>
<p>一般开源项目遇到问题首先想到去Issue中去寻找答案,兼容IE肯定是个普遍问题,issue中已经有很多类似问题和解决方案了.<a href="https://github.com/iview/iview-admin/issues?utf8=%E2%9C%93&q=is:issue+ie">https://github.com/iview/iview-admin/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+ie</a></p>
<p>整理了一下本人成功兼容IE11 的方案:</p>
<ol>
<li>更改webpack-dev-server版本为2.71</li>
</ol>
<p><code>npm install --save-dev webpack-dev-server@2.7.1 </code></p>
<ol start="2">
<li>安装@babel/polyfill </li>
</ol>
<p><code>npm install --save @babel/polyfill</code></p>
<ol start="3">
<li>main.js代码最前面加入</li>
</ol>
<p><code>import &#39;@babel/polyfill&#39;</code></p>
<ol start="4">
<li>main.js相关的语言包全部删除</li>
</ol>
<pre><code>1.main.js中的以下三部分注释掉：
//import i18n from &#39;@/locale&#39;

Vue.use(iView, &#123;
// i18n: (key, value) =&gt; i18n.t(key, value)
&#125;)

new Vue(&#123;
el: &#39;#app&#39;,
router,
// i18n,
store,
render: h =&gt; h(App)
&#125;)

2.还需要把components\main下的：

// this.setLocal(this.$i18n.locale)
两段注释掉
</code></pre>
<ol start="5">
<li>修改配置文件</li>
</ol>
<pre><code>编辑.babelrc
&#123;
  &quot;presets&quot;: [[&quot;@vue/app&quot;, &#123; &quot;useBuiltIns&quot;: &quot;entry&quot; &#125;]]
&#125;

编辑vue.config.js

  transpileDependencies: [&#39;tree-table-vue&#39;, &#39;iview&#39;],

  chainWebpack: config =&gt; &#123;
    config.entry(&#39;polyfill&#39;).add(&#39;@babel/polyfill&#39;)
    config.resolve.alias
      .set(&#39;@&#39;, resolve(&#39;src&#39;)) // key,value自行定义，比如.set(&#39;@@&#39;, resolve(&#39;src/components&#39;))
      .set(&#39;_c&#39;, resolve(&#39;src/components&#39;))
  &#125;,
</code></pre>
<ol start="6">
<li>删除TreeTable依赖</li>
</ol>
<p>TreeTable 插件不兼容ie需要注释掉</p>
<pre><code>在main.js注释掉

// import TreeTable from &#39;tree-table-vue&#39;
// import VOrgTree from &#39;v-org-tree&#39;

以及

// Vue.use(TreeTable)
// Vue.use(VOrgTree)

</code></pre>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoJob 使用文档</title>
    <url>/2021/04/autojob/</url>
    <content><![CDATA[<p>这里是AutoJob小程序的一个简单的使用手册</p>
<h2 id="支持项目"><a href="#支持项目" class="headerlink" title="支持项目"></a>支持项目</h2><ul>
<li>时光相册</li>
<li>天翼网盘</li>
<li>有道笔记</li>
<li>WPS签到</li>
</ul>
<h3 id="Server酱推送"><a href="#Server酱推送" class="headerlink" title="Server酱推送"></a>Server酱推送</h3><p>可选配置,填写SCKEY可以推送签到消息到微信</p>
<p>小程序默认会推送订阅消息,需要手动确认下,勾选同意不再询问则每天自动签到完成都会推送消息</p>
<p>自行配置<code>SCKEY</code>,<a href="http://sc.ftqq.com/">Server酱官网</a></p>
<h3 id="时光相册"><a href="#时光相册" class="headerlink" title="时光相册"></a>时光相册</h3><p>直接新增配置账号密码即可</p>
<h3 id="天翼网盘"><a href="#天翼网盘" class="headerlink" title="天翼网盘"></a>天翼网盘</h3><p>使用账号密码登录</p>
<p><strong>没有设置密码的请去cloud.189.cn设置一下</strong></p>
<p><strong>签到提示验证码的请 <a href="https://cloud.189.cn/udb/udb_login.jsp?pageId=1&redirectURL=/main.action">点击这里</a> 选择账号密码登录,一般会有验证码弹出来,退出多登录几次一般就不需要验证码了</strong></p>
<h3 id="有道笔记"><a href="#有道笔记" class="headerlink" title="有道笔记"></a>有道笔记</h3><p>使用账号密码登录</p>
<p><strong>没有设置密码的请去<a href="https://note.youdao.com/">https://note.youdao.com/web</a>设置一下</strong></p>
<h3 id="WPS签到"><a href="#WPS签到" class="headerlink" title="WPS签到"></a>WPS签到</h3><p>账号填写WPS的UID,密码填写sid<br>获取SID 电脑流量器打开<a href="https://zt.wps.cn/2018/clock_in?csource=pc_clock_oldactivity">https://zt.wps.cn/2018/clock_in?csource=pc_clock_oldactivity</a>登录账号 打开F12 查看cookie 拿到wps_sid的值</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 前端性能检查表</title>
    <url>/2018/04/front-end-performance-checklist-for-2018/</url>
    <content><![CDATA[<blockquote>
<p>原文地址：<a href="https://juejin.im/post/5ac1d117f265da2396128b9f">https://juejin.im/post/5ac1d117f265da2396128b9f</a></p>
</blockquote>
<p>众所周知，性能十分重要。然而，我们真的知道性能瓶颈具体在哪儿吗？是执行复杂的 JavaScript，下载缓慢的 Web 字体，巨大的图片，还是卡顿的渲染？研究摇树（Tree Shaking），作用域提升（Scope Hoisting），或是各种各样的与 IntersectionObserver、Clients Hints、CSS containment、HTTP/2 和 Service Worker 一同工作的华丽的加载模式真的有价值吗？最重要的是，<strong>我们从哪里开始优化性能</strong>，以及我们如何建立长期的性能文化呢？</p>
<p>以前，性能往往只是事后的想法。通常直到项目最后的时候才会被考虑，然后被归结为压缩、合并、静态资源优化或者对服务器配置文件的一些细微调整。现在回想起来，事情似乎已经发生了很大的变化。</p>
<p>性能不仅仅是一个技术问题：它很重要，而且当把它引入到工作流时，设计决策必须根据其性能影响来决定。<strong>我们必须不断的测量、监视和改进性能</strong>，而且 Web 日益复杂的情况带来了新的挑战，使得性能指标难以被跟踪，因为性能指标将因设备、浏览器、协议、网络类型和延迟（CDN、运营商、缓存、代理、防火墙、负载平衡器和服务器都在其中发挥作用）而有很大差异。</p>
<p>因此，如果我们创作一个在提高性能时必须牢记的所有事项的概述——从流程的一开始到网站的最终发布——这样的列表将是什么样子？下面就是 2018 前端性能检查表（但愿不偏不倚和足够客观）——说明您可能需要考虑的问题，以确保您的站点响应时间快、用户交互流畅，并且不会用尽用户的带宽。</p>
<p>下面是您可能需要考虑的<strong>前端性能问题</strong>的概述，以确保您的响应时间快速而流畅。</p>
<p>（译注：原文详细地阐述了文中所涉及的所有优化策略的原理和来龙去脉。此处仅翻译了原文中附带的 PDF 检查表文件，意在提供一个快速、简洁的性能优化清单。）</p>
<h2 id="一、准备：规划和指标"><a href="#一、准备：规划和指标" class="headerlink" title="一、准备：规划和指标"></a>一、准备：规划和指标</h2><h3 id="01-建立性能文化"><a href="#01-建立性能文化" class="headerlink" title="01 建立性能文化"></a>01 建立性能文化</h3><p>只要团队之间没有协作，高性能就无法长期维持。研究用户反馈中常见的抱怨，看看提高性能是否可以帮助缓解其中一些问题。用真实数据来建立适合自己的案例和模型。在设计过程中就开始规划加载顺序和权衡。</p>
<h3 id="02-选择正确的性能指标"><a href="#02-选择正确的性能指标" class="headerlink" title="02 选择正确的性能指标"></a>02 选择正确的性能指标</h3><p>并非每个指标都同等重要。研究最重要的度量标准：一般而言，它与您开始渲染最重要像素的速度以及提供输入响应的速度有关。根据客户的感受确定页面加载的优先级。可交互时间、页面大标题元素的渲染时间、首次有效绘制时间（FMP）、速度指数（Speed Index）一般都很重要。</p>
<h3 id="03-比你的竞争对手快至少-20"><a href="#03-比你的竞争对手快至少-20" class="headerlink" title="03 比你的竞争对手快至少 20%"></a>03 比你的竞争对手快至少 20%</h3><p>收集代表您受众的设备上的数据。在数据来源上，真实设备比模拟数据更好。选择一台 Moto G4、中端三星设备或者 Nexus 5X 等性能良好的中端设备。或者，也可以通过在电脑上，通过设置网络限速（例如：150ms RTT，1.5Mbps 下载，0.7Mbps 上传）和 CPU 限速（5 倍慢速）以模拟移动体验。最后在常规 3G、4G 和 Wi-Fi 之间切换。收集数据、设置电子表格、将指标提高 20% 并设置目标（即，“性能预算”）。</p>
<h3 id="04-把这张检查表分享给你的同事"><a href="#04-把这张检查表分享给你的同事" class="headerlink" title="04 把这张检查表分享给你的同事"></a>04 把这张检查表分享给你的同事</h3><p>确保团队中的每个成员都熟悉该清单。每一个决策都涉及性能问题，前端开发人员的积极参与将使您的项目受益匪浅。将你的性能预算映射到设计决策上。</p>
<h2 id="二、制定现实的目标"><a href="#二、制定现实的目标" class="headerlink" title="二、制定现实的目标"></a>二、制定现实的目标</h2><h3 id="05-100-毫秒的响应时间-每秒60帧"><a href="#05-100-毫秒的响应时间-每秒60帧" class="headerlink" title="05 100 毫秒的响应时间 + 每秒60帧"></a>05 100 毫秒的响应时间 + 每秒60帧</h3><p>每帧动画应在少于 16 毫秒（理想情况下为 10 毫秒）内完成，从而达到每秒 60 帧（1 秒 ÷ 60 = 16.6毫秒）。保持乐观，明智地利用空闲时间。对于像动画这样的高压点，只要能，就不要做任何其它事情。预计输入延迟时间（Estimated Input Latency）应低于 50 毫秒。</p>
<h3 id="06-速度指数（SpeedIndex）小于-1250，可交互时间（Time-To-Interactive）在-3G-上小于-5-秒"><a href="#06-速度指数（SpeedIndex）小于-1250，可交互时间（Time-To-Interactive）在-3G-上小于-5-秒" class="headerlink" title="06 速度指数（SpeedIndex）小于 1250，可交互时间（Time-To-Interactive）在 3G 上小于 5 秒"></a>06 速度指数（SpeedIndex）小于 1250，可交互时间（Time-To-Interactive）在 3G 上小于 5 秒</h3><p>目标是在 1 秒内（在高速网络下）完成首次绘制（FMP），速度指数（SpeedIndex）低于 1250 毫秒。考虑速度基线是一台有着 3G 网络的，价格为 200 美元左右的 Android 手机（译注：国产千元机水平），那么可以以 400 毫秒 RTT 和 400kb/s 的传输速度进行网络模拟，以达成可交互时间（Time-To-Interactive）小于 5 秒，第二次打开的速度低于 2 秒。尽你所能地降低这些指标。</p>
<h3 id="07-核心块-15kb，关键文件-lt-170-kb"><a href="#07-核心块-15kb，关键文件-lt-170-kb" class="headerlink" title="07 核心块 = 15kb，关键文件 &lt; 170 kb"></a>07 核心块 = 15kb，关键文件 &lt; 170 kb</h3><p>HTML 的前 14<del>15kb 是最关键的核心块（chunk），也是整个文件中唯一可以在第一个 RTT 内被下载的部分。要实现上述目标，请设定关键文件的最大尺寸“预算”。170kb gzip 后的文件（原始文件尺寸 0.8</del>1mb），在普通手机上可能需要 1 秒才能解析和编译完成。</p>
<h2 id="三、定义环境"><a href="#三、定义环境" class="headerlink" title="三、定义环境"></a>三、定义环境</h2><h3 id="08-选择并设置你的构建工具"><a href="#08-选择并设置你的构建工具" class="headerlink" title="08 选择并设置你的构建工具"></a>08 选择并设置你的构建工具</h3><p>不要太注意所谓的“酷”。只要您能够快速获得结果，而且在维护构建过程上没有问题就很好了。</p>
<h3 id="09-渐进增强"><a href="#09-渐进增强" class="headerlink" title="09 渐进增强"></a>09 渐进增强</h3><p>首先设计和构建核心功能，然后再在此基础上为功能强大的浏览器的高级功能增强效果，从而创建弹性的体验。如果您的网站在性能差、网络差的机器上还能运行得比较快，那在性能好、网络棒的机器上只会运行得更快。</p>
<h3 id="10-设定硬性的性能基准"><a href="#10-设定硬性的性能基准" class="headerlink" title="10 设定硬性的性能基准"></a>10 设定硬性的性能基准</h3><p>用 JavaScript 实现交互效果的成本相当高昂。170kb 的尺寸预算已经包含了核心的 HTML / CSS / JavaScript、路由、状态管理、工具函数、框架还有产品逻辑，因此，请彻底检查我们选择的框架的网络传输成本、解析 / 编译时间和其运行时的时间成本。</p>
<h3 id="11-圣战止于智者：Angular-React-还是-Ember"><a href="#11-圣战止于智者：Angular-React-还是-Ember" class="headerlink" title="11 圣战止于智者：Angular, React 还是 Ember"></a>11 圣战止于智者：Angular, React 还是 Ember</h3><p>并不是每个项目都需要框架。但是如果你的项目需要框架，那么最好选择使用一个支持服务器端渲染（SSR）的框架。在使用框架之前，请确保在移动设备上以服务器端渲染和客户端渲染两种模式来评估框架的启动时间。了解您将依赖的框架的具体细节。了解 PRPL 模式和 App Shell 模型。</p>
<h3 id="12-你会使用-AMP-或者-Instant-Articles-吗"><a href="#12-你会使用-AMP-或者-Instant-Articles-吗" class="headerlink" title="12 你会使用 AMP 或者 Instant Articles 吗"></a>12 你会使用 AMP 或者 Instant Articles 吗</h3><p>（译注：AMP 为 Google 的开源项目，意在以组件化的形式以提升移动设备对网站的访问速度；Instant Articles 是 Facebook 的协议，意在通过渲染页面的精简版本以提升页面在 Facebook App 内的打开速度。在国内，MIP 是和 AMP 类似的解决方案。）</p>
<p>没有它们，你也可以获得良好的性能。但是 AMP 提供了一个可靠的性能框架，有免费的 CDN ，而 Instant Articles 将提高你在 Facebook 上的知名度和性能。你也可以构建一个渐进式 AMP（译注：Progressive Web AMP，PWA 和 AMP 的结合体）。</p>
<h3 id="13-选择合适的-CDN"><a href="#13-选择合适的-CDN" class="headerlink" title="13 选择合适的 CDN"></a>13 选择合适的 CDN</h3><p>您可以将部分内容“外包”给静态站点生成器，然后将其推送到 CDN，并从CDN 提供静态版本，从而避免数据库请求（即 JAMStack）。当然，这取决于您拥有的动态数据量。仔细检查 CDN 是否为您执行了内容压缩和转换、智能 HTTP/2 和边缘端包含（ESI, edge-side includes）。</p>
<h2 id="四、优化构建"><a href="#四、优化构建" class="headerlink" title="四、优化构建"></a>四、优化构建</h2><h3 id="14-合理安排优先级"><a href="#14-合理安排优先级" class="headerlink" title="14 合理安排优先级"></a>14 合理安排优先级</h3><p>把你所有的静态资源（JavaScript，图片，字体，第三方脚本，尺寸大的模块）列成一个表，然后把它们按优先级分成三组：基本核心功能（老浏览器也能浏览的核心内容）、增强体验效果（为现代浏览器设计的强大功能和丰富体验）、附加功能（不一定需要并且可以惰性加载的资源，比如字体、轮播脚本、视频播放器、分享按钮等）。</p>
<h3 id="15-使用“符合标准”技术"><a href="#15-使用“符合标准”技术" class="headerlink" title="15 使用“符合标准”技术"></a>15 使用“符合标准”技术</h3><p>（译注：<a href="https://link.juejin.im/?target=http://responsivenews.co.uk/post/18948466399/cutting-the-mustard">“符合标准”技术（cutting-the-mustard technique）</a>是 BBC News 开发者博客提出的，一种基于浏览器特性来检测其支持程度，并以此选择要加载哪些功能的技术。）</p>
<p>对老旧的浏览器，仅输出核心功能代码；对现代浏览器输出增强的功能代码。严格按标准加载静态资源：直接加载核心代码，在 DOMContentLoaded 事件中加载增强代码，并在 load 事件中加载剩下的代码。注意：廉价的 Android 手机虽然很符合标准，但这些手机的内存和 CPU 性能有限。因此，您可能需要使用读取设备内存大小的 JavaScript API 来检测设备性能，只有不支持的时候才按“符合标准”技术来。</p>
<h3 id="16-减少-JavaScript-体积"><a href="#16-减少-JavaScript-体积" class="headerlink" title="16 减少 JavaScript 体积"></a>16 减少 JavaScript 体积</h3><p>由于解析 JavaScript 很耗时，所以请尽可能的减少 JavaScript 的体积。在构建 SPA 时，您可能需要用一定时间初始化应用程序之后，才能开始渲染页面。寻找可以加快初始渲染事件的模块和技术（在低端移动设备上，这可以轻松将速度提高 2-5 倍）。彻底检查每一个 JavaScript 依赖，以找出谁在消耗初始化的宝贵时间。</p>
<h3 id="17-使用微优化和渐进式启动"><a href="#17-使用微优化和渐进式启动" class="headerlink" title="17 使用微优化和渐进式启动"></a>17 使用微优化和渐进式启动</h3><p>使用服务器端渲染来获得快速的首次有效绘制时间（FMP），但也在页面里输出一些最小功能的 JavaScript 来保持交互时间（TTI）接近首次有效绘制时间（FMP）。然后，如果有需要或者有多余的时间，才开始启动应用程序的非必要部分。在加载时显示一个骨架屏幕，而不是“加载中”动画。</p>
<h3 id="18-使用摇树和代码分割"><a href="#18-使用摇树和代码分割" class="headerlink" title="18 使用摇树和代码分割"></a>18 使用摇树和代码分割</h3><p>使用摇树（Tree Shaking）技术和代码分割（Code Splitting）技术以减少代码体积。</p>
<p>摇树（Tree Shaking）技术是一种通过丢弃未使用的代码以在构建过程清理代码的方法。代码分割（Code Splitting）技术将您的代码拆分为按需加载的“chunks（块）”。作用域提升（Scope Hoisting）技术使得链式的依赖能被无缝地转换成行内函数。通过 WebPack 将上述技术用于您的代码。使用 AOT 编译器（译注：例如 Closure Compiler）将一些客户端计算移到服务端。</p>
<h3 id="19-异步加载-JavaScript"><a href="#19-异步加载-JavaScript" class="headerlink" title="19 异步加载 JavaScript"></a>19 异步加载 JavaScript</h3><p>作为开发者，我们必须显式地使用 <code>defer</code> 和 <code>async</code> 属性来告诉浏览器不要等待脚本下载、开始渲染页面。如果你不需要关注 IE 9 及以下版本的浏览器，那么使用 <code>defer</code> 更好；否则，使用 <code>async</code> 更好。使用静态的分享按钮、静态链接交互式地图而不是使用第三方库。</p>
<h3 id="20-HTTP-缓存头是否设置好了"><a href="#20-HTTP-缓存头是否设置好了" class="headerlink" title="20 HTTP 缓存头是否设置好了"></a>20 HTTP 缓存头是否设置好了</h3><p>重新检查你是否正确的设置了 Expires, Cache-Control, Max-Age 等 HTTP 缓存控制响应头。通常而言，一个资源要么只被缓存很短的时间（比如经常修改的资源），要么永久缓存（比如不会被更改的那种资源）。使用专为带哈希指纹的静态文件设计的响应头 <code>Cache-Control: imuutable</code> 以避免浏览器重新请求文件。</p>
<h2 id="五、静态资源优化"><a href="#五、静态资源优化" class="headerlink" title="五、静态资源优化"></a>五、静态资源优化</h2><h3 id="21-是否使用了-Brotli-或-Zopfli-压缩"><a href="#21-是否使用了-Brotli-或-Zopfli-压缩" class="headerlink" title="21 是否使用了 Brotli 或 Zopfli 压缩"></a>21 是否使用了 Brotli 或 Zopfli 压缩</h3><p>Brotli 是一种新的无损压缩格式。现在，所有的现代浏览器都支持它。它比 Gzip 和 Deflate 压缩率更高，压缩非常慢，但是解压速度很快。使用最高压缩比的 Brotli+Gzip 预压缩静态文件，并使用 1~4 级的 Brotli 实时压缩动态内容。也顺便检查一下 CDN 是否支持 Brotli。或者，你也可以试试在不常变化的资源上使用 Zopfli —— 它将数据用 Deflate、Gzip 和 Zlib 格式压缩，并且被设计为一次压缩、多次下载。</p>
<h3 id="22-图片是否被正确优化"><a href="#22-图片是否被正确优化" class="headerlink" title="22 图片是否被正确优化"></a>22 图片是否被正确优化</h3><p>尽可能使用通过 <code>srcset</code>、<code>sizes</code> 和 <code>&lt;picture&gt;</code> 元素实现的响应式图片。使用 WebP 格式的图片；这可通过 <code>&lt;picutre&gt;</code> 标签配合 JPEG fallback，或者通过 <code>Accept</code> 请求头来实现。对于核心图片，使用渐进式的 JPEG 并用高斯滤镜模糊掉不重要的部分。</p>
<h3 id="23-Web-Font-是否被正确优化"><a href="#23-Web-Font-是否被正确优化" class="headerlink" title="23 Web Font 是否被正确优化"></a>23 Web Font 是否被正确优化</h3><p>您使用的 Web Font 很可能包含未真正被使用的执行和额外的特性。制作字体的子集（译注：仅包含部分文字的字体，如 fontmin 等方案）。优先使用 WOFF2 并使用 WOFF 作为后备。立即使用后备字体显示文字、异步加载字体（例如，使用 loadCSS），然后再切换字体。同时也考虑本地操作系统中已经安装了的字体。不要忘记在 CSS 中写 <code>font-display: optional</code>；如果你无法从您的服务器加载字体，请记得使用 Font Load Events。</p>
<h2 id="六、分发优化"><a href="#六、分发优化" class="headerlink" title="六、分发优化"></a>六、分发优化</h2><h3 id="24-快速推送核心-CSS"><a href="#24-快速推送核心-CSS" class="headerlink" title="24 快速推送核心 CSS"></a>24 快速推送核心 CSS</h3><p>将所有首屏渲染所需要的 CSS 放在一起，然后方法在 <code>&lt;head&gt;</code> 标签中。考虑有选择的内联的方法。或者，使用 HTTP/2 服务端推送；但这样你可能需要构建一个可感知缓存的 HTTP/2 服务端推送机制。</p>
<h3 id="25-使用-babel-preset-env-以仅转译-ES2015-特性"><a href="#25-使用-babel-preset-env-以仅转译-ES2015-特性" class="headerlink" title="25 使用 babel-preset-env 以仅转译 ES2015+ 特性"></a>25 使用 babel-preset-env 以仅转译 ES2015+ 特性</h3><p>由于 ES2015 已被广泛支持了，您可以考虑使用 <code>babel-preset-env</code> 以仅转译现代浏览器不支持的 ES2015+ 特性。然后你可以编译两份，一份是 ES6 ，另一份是 ES5。使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 使得有 ESM 支持的浏览器加载新文件，剩下的老的浏览器可以使用 <code>&lt;script nomodule&gt;</code> 来加载老的文件。</p>
<h3 id="26-提升渲染性能"><a href="#26-提升渲染性能" class="headerlink" title="26 提升渲染性能"></a>26 提升渲染性能</h3><p>使用 CSS 包含（CSS Containment）隔离渲染十分耗时的组件。请保证在滑动页面或者元素动画的时候，页面不会卡顿，而且你的页面能持续以 60fps 的速度渲染。如果那不可能，那么至少也要把 fps 控制在 15~60 之间。使用 CSS 的 <code>will-change</code> 属性通知浏览器哪个元素将会变化。</p>
<h3 id="27-使用-Intersection-Observer-懒加载大型脚本"><a href="#27-使用-Intersection-Observer-懒加载大型脚本" class="headerlink" title="27 使用 Intersection Observer 懒加载大型脚本"></a>27 使用 Intersection Observer 懒加载大型脚本</h3><p>Intersection Observer API 提供了异步监听目标元素与祖先元素或顶层文档视口交点中的更改的能力。浏览器支持？Chrome, Firefox, Edge 和三星浏览器都支持了。WebKit 还在开发。浏览器不支持？懒加载一个 polyfill。</p>
<h3 id="28-是否优化了渲染体验"><a href="#28-是否优化了渲染体验" class="headerlink" title="28 是否优化了渲染体验"></a>28 是否优化了渲染体验</h3><p>不要低估感知性能的作用。在加载静态文件时，尽量始终领先用户一步，这样在后台发生很多事情时，会感觉体验上很快。例如，要让用户持续关注你的页面，请使用骨架屏幕而不是一些加载中的动画。</p>
<h3 id="29-预热连接以加快分发速度"><a href="#29-预热连接以加快分发速度" class="headerlink" title="29 预热连接以加快分发速度"></a>29 预热连接以加快分发速度</h3><p>使用骨架屏幕，然后懒加载所有的大型组件，比如字体、JavaScript、轮播图、视频和 iframe 等。使用资源提示（Resource Hints），如 <code>dns-prefetch</code>、<code>preconnect</code>、<code>prefetch</code> 和 <code>preload</code>来节省时间。</p>
<h2 id="七、HTTP-2"><a href="#七、HTTP-2" class="headerlink" title="七、HTTP/2"></a>七、HTTP/2</h2><h3 id="30-为-HTTP-2-做准备"><a href="#30-为-HTTP-2-做准备" class="headerlink" title="30 为 HTTP/2 做准备"></a>30 为 HTTP/2 做准备</h3><p>HTTP/2 支持很好，而且提供了不小的性能提升。缺点是，您必须迁移到 HTTPS；根据您不支持 HTTP/2 的用户群大小，你可能需要为 HTTP/1.1 和 HTTP/2 的用户返回不同版本的代码，这就要求您调整您的编译工具。</p>
<h3 id="31-正确地部署-HTTP-2"><a href="#31-正确地部署-HTTP-2" class="headerlink" title="31 正确地部署 HTTP/2"></a>31 正确地部署 HTTP/2</h3><p>您需要在打包模块和并行加载许多小模块之间找到一个良好的平衡。将整个界面分解为许多小模块；然后分组、压缩和打包。整个网站分为大约 6 到 10 个包应该是一个不错的折衷方案（对于传统浏览器来说也不错）。通过实验和数据监测来为您的网站找到正确的平衡。</p>
<h3 id="32-你为-Save-Data-头节约数据流量了吗"><a href="#32-你为-Save-Data-头节约数据流量了吗" class="headerlink" title="32 你为 Save-Data 头节约数据流量了吗"></a>32 你为 Save-Data 头节约数据流量了吗</h3><p>Save-Data 请求提示头可以让我们为关心流量费用和性能的用户提供个性化的响应。例如，你可以把所有高清的图片都改成低清的，不用 Web Font 和华丽的动效，关掉视频自动播放和服务器推送，甚至修改你的应用界面。</p>
<h3 id="34-确保服务器上的安全性是无懈可击的"><a href="#34-确保服务器上的安全性是无懈可击的" class="headerlink" title="34 确保服务器上的安全性是无懈可击的"></a>34 确保服务器上的安全性是无懈可击的</h3><p>再次检查安全标头是否设置正确，消除已知漏洞，并检查 SSL 证书。确保所有外部插件和跟踪脚本都是通过 HTTPS 加载的、没有 XSS，并且 HSTS 响应头和内容安全策略（CSP）响应头都已正确设置。</p>
<h3 id="35-你的服务器和-CDN-都支持-HTTP-2-吗"><a href="#35-你的服务器和-CDN-都支持-HTTP-2-吗" class="headerlink" title="35 你的服务器和 CDN 都支持 HTTP/2 吗"></a>35 你的服务器和 CDN 都支持 HTTP/2 吗</h3><p>不同的服务器和 CDN 可能对 HTTP/2 有不同的支持。使用 <a href="https://link.juejin.im/?target=https://istlsfastyet.com/">Is TLS Fast Yet?</a> 来检查你的设置，或者直接看看你的服务器性能如何，支持的特性情况怎么样。</p>
<h3 id="36-是否启用了-OCSP-Stapling"><a href="#36-是否启用了-OCSP-Stapling" class="headerlink" title="36 是否启用了 OCSP Stapling"></a>36 是否启用了 OCSP Stapling</h3><p>在服务器上启用 OCSP Stapling 有助于提升 TLS 握手速度。OCSP 协议可以让浏览器无需下载并检索证书信息，从而减少握手时间。</p>
<h3 id="37-你使用-IPv6-了吗"><a href="#37-你使用-IPv6-了吗" class="headerlink" title="37 你使用 IPv6 了吗"></a>37 你使用 IPv6 了吗</h3><p>研究标明，IPv6 的邻居发现（NDP）和路由优化可以使网站快 10% ~ 15%。升级到支持 IPv6 的 DNS 以为未来做好准备。只需确保双栈网络能正常工作——这使得 IPv6 和 IPv4 能同时运行。毕竟，IPv6 不是向后兼容的。</p>
<h3 id="38-HPACK-压缩启用了吗"><a href="#38-HPACK-压缩启用了吗" class="headerlink" title="38 HPACK 压缩启用了吗"></a>38 HPACK 压缩启用了吗</h3><p>如果你使用了 HTTP/2，再次检查你的服务器是否实现了 HPACK 压缩。HPACK 压缩可以压缩 HTTP 响应头，以减少不必要的开支。由于 HTTP/2 服务器现在都很新，他们可能不能完全支持包括 HPACK 压缩在内的所有标准。H2spec 是一个非常好的用于检测标准支持程度的工具。</p>
<h3 id="39-你使用了-Service-Worker-来缓存或者提供离线内容吗"><a href="#39-你使用了-Service-Worker-来缓存或者提供离线内容吗" class="headerlink" title="39 你使用了 Service Worker 来缓存或者提供离线内容吗"></a>39 你使用了 Service Worker 来缓存或者提供离线内容吗</h3><p>网络再怎么优化，也不会比本地缓存更快。如果你的网站使用了 HTTPS，那么你可以把静态资源放在 Service Worker 的缓存中，而不用请求网络。</p>
<h2 id="八、测试和监控"><a href="#八、测试和监控" class="headerlink" title="八、测试和监控"></a>八、测试和监控</h2><h3 id="40-监控混合内容警告"><a href="#40-监控混合内容警告" class="headerlink" title="40 监控混合内容警告"></a>40 监控混合内容警告</h3><p>如果您最近从 HTTP 迁移到了 HTTPS，请确保使用类似 Report-URI.io 之类的服务监控了严格的或被动的混合内容报警。你也可以用 <a href="https://link.juejin.im/?target=https://github.com/bramus/mixed-content-scan">Mixed Content Scan</a> 来扫描你的 HTTPS 站点上是否有非 HTTPS 的混合内容。</p>
<h3 id="41-使用-DevTools-的开发工作流是优化过的吗"><a href="#41-使用-DevTools-的开发工作流是优化过的吗" class="headerlink" title="41 使用 DevTools 的开发工作流是优化过的吗"></a>41 使用 DevTools 的开发工作流是优化过的吗</h3><p>选择一个调试工具，并试着点击每一个按钮。请确保您理解如何分析渲染性能、控制台输出、调试 JavaScript 和编辑 CSS 样式。</p>
<h3 id="42-是否在代理浏览器和老式浏览器上测试过了"><a href="#42-是否在代理浏览器和老式浏览器上测试过了" class="headerlink" title="42 是否在代理浏览器和老式浏览器上测试过了"></a>42 是否在代理浏览器和老式浏览器上测试过了</h3><p>在 Chrome 和 Firefox 上测试是不够的。请看看你的网站在代理浏览器和老式浏览器（包括 UC 浏览器和 Opera Mini 等。译者注：此处的代理浏览器即指国内浏览器中常见的云加速功能）上是什么样子。统计你受众国家的网络平均速度，避免出现重大意外。使用网络节流并模拟高 DPI 设备。虽然 BrowserStack 很好，但也得在真机上测试。</p>
<h3 id="43-是否设置了持续的监控"><a href="#43-是否设置了持续的监控" class="headerlink" title="43 是否设置了持续的监控"></a>43 是否设置了持续的监控</h3><p>良好的性能指标是被动和主动监控工具的组合。拥有 WebPagetest 的私有实例和使用 Lighthouse 确实有利于快速测试，但也需要使用诸如 Calibre、speedscurve 等 RUM 工具建立持续的监控体系。设置您自己的用户计时打点以监控特定的业务速度指标。</p>
<h2 id="九、速战速决"><a href="#九、速战速决" class="headerlink" title="九、速战速决"></a>九、速战速决</h2><p>此列表相当全面，完成所有优化可能需要相当长的时间。如果你只有一个小时的时间，但又想获得显著的提升，你应该怎么做？我们挑出了 10 个最容易实现的方法。显然，在开始之前和完成之后，请统计结果，包括 3G 和有线连接上的开始渲染时间和速度指数（SpeedIndex）。</p>
<ol>
<li> 统计真实的用户体验，设置可接受的目标。一个好的目标大致是：FMP &lt; 1s，速度指数 &lt; 1250，TTI 在 3G 网络上 &lt; 5s 、二次访问 &lt; 2s。优化开始渲染时间和 TTI。</li>
<li> 为你的主模板准备核心 CSS，并放在 <code>&lt;head&gt;</code> 标签里（你的预算是 14KB）。对于 CSS/JS，请保证核心文件尺寸最大为 170kb （gzip 后的尺寸；压缩前 0.8~1Mb）</li>
<li> 延迟或懒加载尽可能多的脚本，不管是你自己的还是第三方的——特别是分享按钮、视频播放器和其它的复杂模块。</li>
<li> 增加资源提示，包括 <code>dns-lookup</code>, <code>preconnect</code>, <code>prefetch</code> 和 <code>preload</code>。</li>
<li> 为 Web Font 创建子集，并异步加载（或者干脆别用）。</li>
<li> 优化图片。考虑在关键的页面（比如落地页）上用 WebP 格式。</li>
<li> 检查 HTTP 缓存头和安全头是否正确设置了。</li>
<li> 在服务器上启用 Brotli 或者 Zopfli 压缩。如果不支持，别忘了开 gzip。</li>
<li> 如果有 HTTP/2，启用 HPACK 压缩并上报混合内容警告。如果使用了 LTS，那么请打开 OCSP 装订。</li>
<li> 如果可能，将静态资源（包括字体、样式、脚本和图片等）尽可能多地在 service worker 里缓存起来。</li>
</ol>
<p><em>Huge thanks to Yoav Weiss, Addy Osmani, Artem Denysov, Denys Mishunov, Ilya Pukhalski, Jeremy Wagner, Colin Bendell, Mark Zeman, Patrick Meenan, Leonardo Losoviz, Guy Podjarny, Andy Davies, Rachel Andrew, Anselm Hannemann, Patrick Hamann, Andy Davies, Tim Kadlec, Rey Bango, Matthias Ott, Mariana Peralta, Philipp Tellis, Ryan Townsend, Mohamed Hussain S H, Jacob Groß, Tim Swalling, Bob Visser, Kev Adamson and Rodney Rehm for reviewing this article, as well as our fantastic community, which has shared techniques and lessons learned from its work in performance optimization for everybody to use. You are truly smashing!</em></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>性能</tag>
        <tag>优化</tag>
      </tags>
  </entry>
</search>
